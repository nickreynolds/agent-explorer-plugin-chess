var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to2, from6, except, desc) => {
  if (from6 && typeof from6 === "object" || typeof from6 === "function") {
    for (let key of __getOwnPropNames(from6))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from6[key], enumerable: !(desc = __getOwnPropDesc(from6, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));

// external-global-plugin:react
var require_react = __commonJS({
  "external-global-plugin:react"(exports2, module2) {
    module2.exports = window.React;
  }
});

// external-global-plugin:react-router-dom
var require_react_router_dom = __commonJS({
  "external-global-plugin:react-router-dom"(exports2, module2) {
    module2.exports = window.reactrouterdom;
  }
});

// external-global-plugin:react-query
var require_react_query = __commonJS({
  "external-global-plugin:react-query"(exports2, module2) {
    module2.exports = window.reactquery;
  }
});

// external-global-plugin:@veramo-community/veramo-react
var require_veramo_react = __commonJS({
  "external-global-plugin:@veramo-community/veramo-react"(exports2, module2) {
    module2.exports = window.veramoreact;
  }
});

// external-global-plugin:@ant-design/pro-components
var require_pro_components = __commonJS({
  "external-global-plugin:@ant-design/pro-components"(exports2, module2) {
    module2.exports = window.antdPro;
  }
});

// node_modules/.pnpm/classnames@2.3.2/node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/.pnpm/classnames@2.3.2/node_modules/classnames/index.js"(exports2, module2) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      var nativeCodeString = "[native code]";
      function classNames2() {
        var classes = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames2.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// external-global-plugin:@veramo-community/agent-explorer-plugin
var require_agent_explorer_plugin = __commonJS({
  "external-global-plugin:@veramo-community/agent-explorer-plugin"(exports2, module2) {
    module2.exports = window.agentexplorerplugin;
  }
});

// external-global-plugin:antd
var require_antd = __commonJS({
  "external-global-plugin:antd"(exports2, module2) {
    module2.exports = window.antd;
  }
});

// node_modules/.pnpm/requires-port@1.0.0/node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/.pnpm/requires-port@1.0.0/node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/.pnpm/querystringify@2.2.0/node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/.pnpm/querystringify@2.2.0/node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var undef;
    function decode16(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e2) {
        return null;
      }
    }
    function encode13(input) {
      try {
        return encodeURIComponent(input);
      } catch (e2) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key = decode16(part[1]), value = decode16(part[2]);
        if (key === null || value === null || key in result)
          continue;
        result[key] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix)
        prefix = "?";
      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode13(key);
          value = encode13(value);
          if (key === null || value === null)
            continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// node_modules/.pnpm/url-parse@1.5.10/node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/.pnpm/url-parse@1.5.10/node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof global !== "undefined")
        globalVar = global;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore)
          delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore)
            continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base5) {
      if (relative === "")
        return base5;
      var path = (base5 || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path.length, last = path[i2 - 1], unshift = false, up = 0;
      while (i2--) {
        if (path[i2] === ".") {
          path.splice(i2, 1);
        } else if (path[i2] === "..") {
          path.splice(i2, 1);
          up++;
        } else if (up) {
          if (i2 === 0)
            unshift = true;
          path.splice(i2, 1);
          up--;
        }
      }
      if (unshift)
        path.unshift("");
      if (last === "." || last === "..")
        path.push("");
      return path.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i2 = 0;
      if ("object" !== type && "string" !== type) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser)
        parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i2 < instructions.length; i2++) {
        instruction = instructions[i2];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse2 = instruction[0];
        key = instruction[1];
        if (parse2 !== parse2) {
          url[key] = address;
        } else if ("string" === typeof parse2) {
          index = parse2 === "@" ? address.lastIndexOf(parse2) : address.indexOf(parse2);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse2.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4])
          url[key] = url[key].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set(part, value, fn2) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn2 || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn2;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i2 = 0; i2 < rules.length; i2++) {
        var ins = rules[i2];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString5(stringify) {
      if (!stringify || "function" !== typeof stringify)
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query)
        result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set, toString: toString5 };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// node_modules/.pnpm/@multiformats+base-x@4.0.1/node_modules/@multiformats/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@multiformats+base-x@4.0.1/node_modules/@multiformats/base-x/src/index.js"(exports2, module2) {
    "use strict";
    function base5(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
        BASE_MAP[j2] = 255;
      }
      for (var i2 = 0; i2 < ALPHABET.length; i2++) {
        var x2 = ALPHABET.charAt(i2);
        var xc = x2.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x2 + " is ambiguous");
        }
        BASE_MAP[xc] = i2;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode13(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length4 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size2);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i3 = 0;
          for (var it1 = size2 - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length4 = i3;
          pbegin++;
        }
        var it2 = size2 - length4;
        while (it2 !== size2 && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size2; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length4 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size2);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i3 = 0;
          for (var it3 = size2 - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length4 = i3;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size2 - length4;
        while (it4 !== size2 && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size2 - it4));
        var j3 = zeroes;
        while (it4 !== size2) {
          vch[j3++] = b256[it4++];
        }
        return vch;
      }
      function decode16(string3) {
        var buffer = decodeUnsafe(string3);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode13,
        decodeUnsafe,
        decode: decode16
      };
    }
    module2.exports = base5;
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/util.js"(exports2, module2) {
    "use strict";
    var textDecoder4 = new TextDecoder();
    var decodeText = (bytes2) => textDecoder4.decode(bytes2);
    var textEncoder5 = new TextEncoder();
    var encodeText = (text) => textEncoder5.encode(text);
    function concat3(arrs, length4) {
      const output2 = new Uint8Array(length4);
      let offset = 0;
      for (const arr of arrs) {
        output2.set(arr, offset);
        offset += arr.length;
      }
      return output2;
    }
    module2.exports = { decodeText, encodeText, concat: concat3 };
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/base.js
var require_base = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/base.js"(exports2, module2) {
    "use strict";
    var { encodeText } = require_util();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name3, code4, factory, alphabet4) {
        this.name = name3;
        this.code = code4;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet4;
        this.codec = factory(alphabet4);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf) {
        return this.codec.encode(buf);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string3) {
        for (const char of string3) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string3}'`);
          }
        }
        return this.codec.decode(string3);
      }
    };
    module2.exports = Base;
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/rfc4648.js"(exports2, module2) {
    "use strict";
    var decode16 = (string3, alphabet4, bitsPerChar) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet4.length; ++i2) {
        codes[alphabet4[i2]] = i2;
      }
      let end = string3.length;
      while (string3[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string3[i2]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string3[i2]);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode13 = (data, alphabet4, bitsPerChar) => {
      const pad = alphabet4[alphabet4.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer = buffer << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet4[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet4[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46484 = (bitsPerChar) => (alphabet4) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode13(input, alphabet4, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode16(input, alphabet4, bitsPerChar);
        }
      };
    };
    module2.exports = { rfc4648: rfc46484 };
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/constants.js"(exports2, module2) {
    "use strict";
    var baseX4 = require_src();
    var Base = require_base();
    var { rfc4648: rfc46484 } = require_rfc4648();
    var { decodeText, encodeText } = require_util();
    var identity5 = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants = [
      ["identity", "\0", identity5, ""],
      ["base2", "0", rfc46484(1), "01"],
      ["base8", "7", rfc46484(3), "01234567"],
      ["base10", "9", baseX4, "0123456789"],
      ["base16", "f", rfc46484(4), "0123456789abcdef"],
      ["base16upper", "F", rfc46484(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc46484(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc46484(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc46484(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc46484(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc46484(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc46484(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc46484(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc46484(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc46484(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX4, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX4, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX4, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX4, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc46484(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc46484(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc46484(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc46484(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names2 = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names2[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module2.exports = {
      names: names2,
      codes
    };
  }
});

// node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/multibase@4.0.6/node_modules/multibase/src/index.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var { encodeText, decodeText, concat: concat3 } = require_util();
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name: name3, codeBuf } = encoding(nameOrCode);
      validEncode(name3, buf);
      return concat3([codeBuf, buf], codeBuf.length + buf.length);
    }
    function encode13(nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf));
      return concat3([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode16(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name3, buf) {
      const enc = encoding(name3);
      enc.decode(decodeText(buf));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    exports2 = module2.exports = multibase;
    exports2.encode = encode13;
    exports2.decode = decode16;
    exports2.isEncoded = isEncoded;
    exports2.encoding = encoding;
    exports2.encodingFromData = encodingFromData;
    var names2 = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports2.names = names2;
    exports2.codes = codes;
  }
});

// node_modules/.pnpm/canonicalize@2.0.0/node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS({
  "node_modules/.pnpm/canonicalize@2.0.0/node_modules/canonicalize/lib/canonicalize.js"(exports2, module2) {
    "use strict";
    module2.exports = function serialize(object) {
      if (typeof object === "number" && isNaN(object)) {
        throw new Error("NaN is not allowed");
      }
      if (typeof object === "number" && !isFinite(object)) {
        throw new Error("Infinity is not allowed");
      }
      if (object === null || typeof object !== "object") {
        return JSON.stringify(object);
      }
      if (object.toJSON instanceof Function) {
        return serialize(object.toJSON());
      }
      if (Array.isArray(object)) {
        const values2 = object.reduce((t2, cv, ci2) => {
          const comma = ci2 === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return `${t2}${comma}${serialize(value)}`;
        }, "");
        return `[${values2}]`;
      }
      const values = Object.keys(object).sort().reduce((t2, cv) => {
        if (object[cv] === void 0 || typeof object[cv] === "symbol") {
          return t2;
        }
        const comma = t2.length === 0 ? "" : ",";
        return `${t2}${comma}${serialize(cv)}:${serialize(object[cv])}`;
      }, "");
      return `{${values}}`;
    };
  }
});

// node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code4, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code4 === "object") {
        props = code4;
        code4 = "";
      }
      if (code4) {
        props.code = code4;
      }
      try {
        return assign(err, props);
      } catch (_2) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output2 = assign(new ErrClass(), props);
        return output2;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn2, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn2.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base643 = exports2;
    base643.length = function length4(string3) {
      var p2 = string3.length;
      if (!p2)
        return 0;
      var n2 = 0;
      while (--p2 % 4 > 1 && string3.charAt(p2) === "=")
        ++n2;
      return Math.ceil(string3.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    var i2;
    base643.encode = function encode13(buffer, start, end) {
      var parts = null, chunk = [];
      var i3 = 0, j2 = 0, t2;
      while (start < end) {
        var b2 = buffer[start++];
        switch (j2) {
          case 0:
            chunk[i3++] = b64[b2 >> 2];
            t2 = (b2 & 3) << 4;
            j2 = 1;
            break;
          case 1:
            chunk[i3++] = b64[t2 | b2 >> 4];
            t2 = (b2 & 15) << 2;
            j2 = 2;
            break;
          case 2:
            chunk[i3++] = b64[t2 | b2 >> 6];
            chunk[i3++] = b64[b2 & 63];
            j2 = 0;
            break;
        }
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j2) {
        chunk[i3++] = b64[t2];
        chunk[i3++] = 61;
        if (j2 === 1)
          chunk[i3++] = 61;
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base643.decode = function decode16(string3, buffer, offset) {
      var start = offset;
      var j2 = 0, t2;
      for (var i3 = 0; i3 < string3.length; ) {
        var c2 = string3.charCodeAt(i3++);
        if (c2 === 61 && j2 > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j2) {
          case 0:
            t2 = c2;
            j2 = 1;
            break;
          case 1:
            buffer[offset++] = t2 << 2 | (c2 & 48) >> 4;
            t2 = c2;
            j2 = 2;
            break;
          case 2:
            buffer[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
            t2 = c2;
            j2 = 3;
            break;
          case 3:
            buffer[offset++] = (t2 & 3) << 6 | c2;
            j2 = 0;
            break;
        }
      }
      if (j2 === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base643.test = function test(string3) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string3);
    };
  }
});

// node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on2(evt, fn2, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn: fn2,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn2) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn2 === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i2 = 0; i2 < listeners.length; )
            if (listeners[i2].fn === fn2)
              listeners.splice(i2, 1);
            else
              ++i2;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i2 = 1;
        for (; i2 < arguments.length; )
          args.push(arguments[i2++]);
        for (i2 = 0; i2 < listeners.length; )
          listeners[i2].fn.apply(listeners[i2++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo2 = readUint(buf, pos + off0), hi2 = readUint(buf, pos + off1);
            var sign = (hi2 >> 31) * 2 + 1, exponent = hi2 >>> 20 & 2047, mantissa = 4294967296 * (hi2 & 1048575) + lo2;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string3) {
      var len = 0, c2 = 0;
      for (var i2 = 0; i2 < string3.length; ++i2) {
        c2 = string3.charCodeAt(i2);
        if (c2 < 128)
          len += 1;
        else if (c2 < 2048)
          len += 2;
        else if ((c2 & 64512) === 55296 && (string3.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i2 = 0, t2;
      while (start < end) {
        t2 = buffer[start++];
        if (t2 < 128)
          chunk[i2++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i2++] = (t2 & 31) << 6 | buffer[start++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i2++] = 55296 + (t2 >> 10);
          chunk[i2++] = 56320 + (t2 & 1023);
        } else
          chunk[i2++] = (t2 & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf8.write = function utf8_write(string3, buffer, offset) {
      var start = offset, c1, c2;
      for (var i2 = 0; i2 < string3.length; ++i2) {
        c1 = string3.charCodeAt(i2);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string3.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size2) {
      var SIZE = size2 || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size3) {
        if (size3 < 1 || size3 > MAX)
          return alloc(size3);
        if (offset + size3 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size3);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util2 = require_minimal();
    function LongBits(lo2, hi2) {
      this.lo = lo2 >>> 0;
      this.hi = hi2 >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo2 = value >>> 0, hi2 = (value - lo2) / 4294967296 >>> 0;
      if (sign) {
        hi2 = ~hi2 >>> 0;
        lo2 = ~lo2 >>> 0;
        if (++lo2 > 4294967295) {
          lo2 = 0;
          if (++hi2 > 4294967295)
            hi2 = 0;
        }
      }
      return new LongBits(lo2, hi2);
    };
    LongBits.from = function from6(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util2.isString(value)) {
        if (util2.Long)
          value = util2.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo2 = ~this.lo + 1 >>> 0, hi2 = ~this.hi >>> 0;
        if (!lo2)
          hi2 = hi2 + 1 >>> 0;
        return -(lo2 + hi2 * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
        (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length4() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util2 = exports2;
    util2.asPromise = require_aspromise();
    util2.base64 = require_base64();
    util2.EventEmitter = require_eventemitter();
    util2.float = require_float();
    util2.inquire = require_inquire();
    util2.utf8 = require_utf8();
    util2.pool = require_pool();
    util2.LongBits = require_longbits();
    util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src4, ifNotSet) {
      for (var keys = Object.keys(src4), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src4[keys[i2]];
      return dst;
    }
    util2.merge = merge;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name3) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get2() {
            return name3;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name3) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name3)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size2) {
        return new Buffer2(size2);
      };
    };
  }
});

// node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util2 = require_minimal();
    var BufferReader;
    var LongBits = util2.LongBits;
    var utf8 = util2.utf8;
    function indexOutOfRange(reader2, writeLength) {
      return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create4 = function create5() {
      return util2.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util2.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create4();
    Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
    util2.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length4 = this.uint32(), start = this.pos, end = this.pos + length4;
      if (end > this.len)
        throw indexOutOfRange(this, length4);
      this.pos += length4;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util2.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip(length4) {
      if (typeof length4 === "number") {
        if (this.pos + length4 > this.len)
          throw indexOutOfRange(this, length4);
        this.pos += length4;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create4();
      BufferReader._configure();
      var fn2 = util2.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util2.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn2](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn2](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn2](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn2](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn2](false);
        }
      });
    };
  }
});

// node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util2 = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util2.Buffer)
        BufferReader.prototype._slice = util2.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util2 = require_minimal();
    var BufferWriter;
    var LongBits = util2.LongBits;
    var base643 = util2.base64;
    var utf8 = util2.utf8;
    function Op(fn2, len, val) {
      this.fn = fn2;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer2) {
      this.head = writer2.head;
      this.tail = writer2.tail;
      this.len = writer2.len;
      this.next = writer2.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create4 = function create5() {
      return util2.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create4();
    Writer.alloc = function alloc(size2) {
      return new util2.Array(size2);
    };
    if (util2.Array !== Array)
      Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
    Writer.prototype._push = function push(fn2, len, val) {
      this.tail = this.tail.next = new Op(fn2, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util2.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util2.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util2.isString(value)) {
        var buf = Writer.alloc(len = base643.length(value));
        base643.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create4();
      BufferWriter._configure();
    };
  }
});

// node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util2 = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util2._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util2.isString(value))
        value = util2._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util2.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util2.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y2;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name3) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce4;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args) {
          if (!debug4.enabled) {
            return;
          }
          const self2 = debug4;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format3];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug4.namespace = namespace;
        debug4.useColors = createDebug.useColors();
        debug4.color = createDebug.selectColor(namespace);
        debug4.extend = extend;
        debug4.destroy = createDebug.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug4);
        }
        return debug4;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split2[i2]) {
            continue;
          }
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name3) {
        if (name3[name3.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name3)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name3)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce4(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// external-global-plugin:uuid
var require_uuid = __commonJS({
  "external-global-plugin:uuid"(exports2, module2) {
    module2.exports = window.uuid;
  }
});

// external-global-plugin:react/jsx-runtime
var require_jsx_runtime = __commonJS({
  "external-global-plugin:react/jsx-runtime"(exports2, module2) {
    module2.exports = window.reactjsxruntime;
  }
});

// node_modules/.pnpm/chess.js@0.12.1/node_modules/chess.js/chess.js
var require_chess = __commonJS({
  "node_modules/.pnpm/chess.js@0.12.1/node_modules/chess.js/chess.js"(exports2) {
    var Chess2 = function(fen) {
      var BLACK = "b";
      var WHITE = "w";
      var EMPTY = -1;
      var PAWN = "p";
      var KNIGHT = "n";
      var BISHOP = "b";
      var ROOK = "r";
      var QUEEN = "q";
      var KING = "k";
      var SYMBOLS = "pnbrqkPNBRQK";
      var DEFAULT_POSITION = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
      var TERMINATION_MARKERS = ["1-0", "0-1", "1/2-1/2", "*"];
      var PAWN_OFFSETS = {
        b: [16, 32, 17, 15],
        w: [-16, -32, -17, -15]
      };
      var PIECE_OFFSETS = {
        n: [-18, -33, -31, -14, 18, 33, 31, 14],
        b: [-17, -15, 17, 15],
        r: [-16, 1, 16, -1],
        q: [-17, -16, -15, 1, 17, 16, 15, -1],
        k: [-17, -16, -15, 1, 17, 16, 15, -1]
      };
      var ATTACKS = [
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        24,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        2,
        24,
        2,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        53,
        56,
        53,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        24,
        24,
        24,
        56,
        0,
        56,
        24,
        24,
        24,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        53,
        56,
        53,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        2,
        24,
        2,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        24,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        20,
        0,
        0,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        20
      ];
      var RAYS = [
        17,
        0,
        0,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        0,
        0,
        15,
        0,
        0,
        17,
        0,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        17,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        0,
        0,
        16,
        0,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        0,
        16,
        0,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        16,
        15,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        -16,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        -16,
        0,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        -16,
        0,
        0,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        -17,
        0,
        0,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        0,
        -17,
        0,
        0,
        0,
        0,
        -15,
        0,
        0,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        0,
        0,
        -17,
        0,
        0,
        -15,
        0,
        0,
        0,
        0,
        0,
        0,
        -16,
        0,
        0,
        0,
        0,
        0,
        0,
        -17
      ];
      var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };
      var FLAGS = {
        NORMAL: "n",
        CAPTURE: "c",
        BIG_PAWN: "b",
        EP_CAPTURE: "e",
        PROMOTION: "p",
        KSIDE_CASTLE: "k",
        QSIDE_CASTLE: "q"
      };
      var BITS = {
        NORMAL: 1,
        CAPTURE: 2,
        BIG_PAWN: 4,
        EP_CAPTURE: 8,
        PROMOTION: 16,
        KSIDE_CASTLE: 32,
        QSIDE_CASTLE: 64
      };
      var RANK_1 = 7;
      var RANK_2 = 6;
      var RANK_3 = 5;
      var RANK_4 = 4;
      var RANK_5 = 3;
      var RANK_6 = 2;
      var RANK_7 = 1;
      var RANK_8 = 0;
      var SQUARES = {
        a8: 0,
        b8: 1,
        c8: 2,
        d8: 3,
        e8: 4,
        f8: 5,
        g8: 6,
        h8: 7,
        a7: 16,
        b7: 17,
        c7: 18,
        d7: 19,
        e7: 20,
        f7: 21,
        g7: 22,
        h7: 23,
        a6: 32,
        b6: 33,
        c6: 34,
        d6: 35,
        e6: 36,
        f6: 37,
        g6: 38,
        h6: 39,
        a5: 48,
        b5: 49,
        c5: 50,
        d5: 51,
        e5: 52,
        f5: 53,
        g5: 54,
        h5: 55,
        a4: 64,
        b4: 65,
        c4: 66,
        d4: 67,
        e4: 68,
        f4: 69,
        g4: 70,
        h4: 71,
        a3: 80,
        b3: 81,
        c3: 82,
        d3: 83,
        e3: 84,
        f3: 85,
        g3: 86,
        h3: 87,
        a2: 96,
        b2: 97,
        c2: 98,
        d2: 99,
        e2: 100,
        f2: 101,
        g2: 102,
        h2: 103,
        a1: 112,
        b1: 113,
        c1: 114,
        d1: 115,
        e1: 116,
        f1: 117,
        g1: 118,
        h1: 119
      };
      var ROOKS = {
        w: [
          { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },
          { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE }
        ],
        b: [
          { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },
          { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE }
        ]
      };
      var board = new Array(128);
      var kings = { w: EMPTY, b: EMPTY };
      var turn = WHITE;
      var castling = { w: 0, b: 0 };
      var ep_square = EMPTY;
      var half_moves = 0;
      var move_number = 1;
      var history = [];
      var header = {};
      var comments = {};
      if (typeof fen === "undefined") {
        load(DEFAULT_POSITION);
      } else {
        load(fen);
      }
      function clear(keep_headers) {
        if (typeof keep_headers === "undefined") {
          keep_headers = false;
        }
        board = new Array(128);
        kings = { w: EMPTY, b: EMPTY };
        turn = WHITE;
        castling = { w: 0, b: 0 };
        ep_square = EMPTY;
        half_moves = 0;
        move_number = 1;
        history = [];
        if (!keep_headers)
          header = {};
        comments = {};
        update_setup(generate_fen());
      }
      function prune_comments() {
        var reversed_history = [];
        var current_comments = {};
        var copy_comment = function(fen2) {
          if (fen2 in comments) {
            current_comments[fen2] = comments[fen2];
          }
        };
        while (history.length > 0) {
          reversed_history.push(undo_move());
        }
        copy_comment(generate_fen());
        while (reversed_history.length > 0) {
          make_move(reversed_history.pop());
          copy_comment(generate_fen());
        }
        comments = current_comments;
      }
      function reset() {
        load(DEFAULT_POSITION);
      }
      function load(fen2, keep_headers) {
        if (typeof keep_headers === "undefined") {
          keep_headers = false;
        }
        var tokens = fen2.split(/\s+/);
        var position = tokens[0];
        var square = 0;
        if (!validate_fen(fen2).valid) {
          return false;
        }
        clear(keep_headers);
        for (var i2 = 0; i2 < position.length; i2++) {
          var piece = position.charAt(i2);
          if (piece === "/") {
            square += 8;
          } else if (is_digit(piece)) {
            square += parseInt(piece, 10);
          } else {
            var color = piece < "a" ? WHITE : BLACK;
            put({ type: piece.toLowerCase(), color }, algebraic(square));
            square++;
          }
        }
        turn = tokens[1];
        if (tokens[2].indexOf("K") > -1) {
          castling.w |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf("Q") > -1) {
          castling.w |= BITS.QSIDE_CASTLE;
        }
        if (tokens[2].indexOf("k") > -1) {
          castling.b |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf("q") > -1) {
          castling.b |= BITS.QSIDE_CASTLE;
        }
        ep_square = tokens[3] === "-" ? EMPTY : SQUARES[tokens[3]];
        half_moves = parseInt(tokens[4], 10);
        move_number = parseInt(tokens[5], 10);
        update_setup(generate_fen());
        return true;
      }
      function validate_fen(fen2) {
        var errors = {
          0: "No errors.",
          1: "FEN string must contain six space-delimited fields.",
          2: "6th field (move number) must be a positive integer.",
          3: "5th field (half move counter) must be a non-negative integer.",
          4: "4th field (en-passant square) is invalid.",
          5: "3rd field (castling availability) is invalid.",
          6: "2nd field (side to move) is invalid.",
          7: "1st field (piece positions) does not contain 8 '/'-delimited rows.",
          8: "1st field (piece positions) is invalid [consecutive numbers].",
          9: "1st field (piece positions) is invalid [invalid piece].",
          10: "1st field (piece positions) is invalid [row too large].",
          11: "Illegal en-passant square"
        };
        var tokens = fen2.split(/\s+/);
        if (tokens.length !== 6) {
          return { valid: false, error_number: 1, error: errors[1] };
        }
        if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {
          return { valid: false, error_number: 2, error: errors[2] };
        }
        if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {
          return { valid: false, error_number: 3, error: errors[3] };
        }
        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
          return { valid: false, error_number: 4, error: errors[4] };
        }
        if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {
          return { valid: false, error_number: 5, error: errors[5] };
        }
        if (!/^(w|b)$/.test(tokens[1])) {
          return { valid: false, error_number: 6, error: errors[6] };
        }
        var rows = tokens[0].split("/");
        if (rows.length !== 8) {
          return { valid: false, error_number: 7, error: errors[7] };
        }
        for (var i2 = 0; i2 < rows.length; i2++) {
          var sum_fields = 0;
          var previous_was_number = false;
          for (var k2 = 0; k2 < rows[i2].length; k2++) {
            if (!isNaN(rows[i2][k2])) {
              if (previous_was_number) {
                return { valid: false, error_number: 8, error: errors[8] };
              }
              sum_fields += parseInt(rows[i2][k2], 10);
              previous_was_number = true;
            } else {
              if (!/^[prnbqkPRNBQK]$/.test(rows[i2][k2])) {
                return { valid: false, error_number: 9, error: errors[9] };
              }
              sum_fields += 1;
              previous_was_number = false;
            }
          }
          if (sum_fields !== 8) {
            return { valid: false, error_number: 10, error: errors[10] };
          }
        }
        if (tokens[3][1] == "3" && tokens[1] == "w" || tokens[3][1] == "6" && tokens[1] == "b") {
          return { valid: false, error_number: 11, error: errors[11] };
        }
        return { valid: true, error_number: 0, error: errors[0] };
      }
      function generate_fen() {
        var empty4 = 0;
        var fen2 = "";
        for (var i2 = SQUARES.a8; i2 <= SQUARES.h1; i2++) {
          if (board[i2] == null) {
            empty4++;
          } else {
            if (empty4 > 0) {
              fen2 += empty4;
              empty4 = 0;
            }
            var color = board[i2].color;
            var piece = board[i2].type;
            fen2 += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
          }
          if (i2 + 1 & 136) {
            if (empty4 > 0) {
              fen2 += empty4;
            }
            if (i2 !== SQUARES.h1) {
              fen2 += "/";
            }
            empty4 = 0;
            i2 += 8;
          }
        }
        var cflags = "";
        if (castling[WHITE] & BITS.KSIDE_CASTLE) {
          cflags += "K";
        }
        if (castling[WHITE] & BITS.QSIDE_CASTLE) {
          cflags += "Q";
        }
        if (castling[BLACK] & BITS.KSIDE_CASTLE) {
          cflags += "k";
        }
        if (castling[BLACK] & BITS.QSIDE_CASTLE) {
          cflags += "q";
        }
        cflags = cflags || "-";
        var epflags = ep_square === EMPTY ? "-" : algebraic(ep_square);
        return [fen2, turn, cflags, epflags, half_moves, move_number].join(" ");
      }
      function set_header(args) {
        for (var i2 = 0; i2 < args.length; i2 += 2) {
          if (typeof args[i2] === "string" && typeof args[i2 + 1] === "string") {
            header[args[i2]] = args[i2 + 1];
          }
        }
        return header;
      }
      function update_setup(fen2) {
        if (history.length > 0)
          return;
        if (fen2 !== DEFAULT_POSITION) {
          header["SetUp"] = "1";
          header["FEN"] = fen2;
        } else {
          delete header["SetUp"];
          delete header["FEN"];
        }
      }
      function get2(square) {
        var piece = board[SQUARES[square]];
        return piece ? { type: piece.type, color: piece.color } : null;
      }
      function put(piece, square) {
        if (!("type" in piece && "color" in piece)) {
          return false;
        }
        if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {
          return false;
        }
        if (!(square in SQUARES)) {
          return false;
        }
        var sq = SQUARES[square];
        if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {
          return false;
        }
        board[sq] = { type: piece.type, color: piece.color };
        if (piece.type === KING) {
          kings[piece.color] = sq;
        }
        update_setup(generate_fen());
        return true;
      }
      function remove(square) {
        var piece = get2(square);
        board[SQUARES[square]] = null;
        if (piece && piece.type === KING) {
          kings[piece.color] = EMPTY;
        }
        update_setup(generate_fen());
        return piece;
      }
      function build_move(board2, from6, to2, flags, promotion) {
        var move = {
          color: turn,
          from: from6,
          to: to2,
          flags,
          piece: board2[from6].type
        };
        if (promotion) {
          move.flags |= BITS.PROMOTION;
          move.promotion = promotion;
        }
        if (board2[to2]) {
          move.captured = board2[to2].type;
        } else if (flags & BITS.EP_CAPTURE) {
          move.captured = PAWN;
        }
        return move;
      }
      function generate_moves(options) {
        function add_move(board2, moves2, from6, to2, flags) {
          if (board2[from6].type === PAWN && (rank(to2) === RANK_8 || rank(to2) === RANK_1)) {
            var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];
            for (var i3 = 0, len2 = pieces.length; i3 < len2; i3++) {
              moves2.push(build_move(board2, from6, to2, flags, pieces[i3]));
            }
          } else {
            moves2.push(build_move(board2, from6, to2, flags));
          }
        }
        var moves = [];
        var us = turn;
        var them = swap_color(us);
        var second_rank = { b: RANK_7, w: RANK_2 };
        var first_sq = SQUARES.a8;
        var last_sq = SQUARES.h1;
        var single_square = false;
        var legal = typeof options !== "undefined" && "legal" in options ? options.legal : true;
        var piece_type = typeof options !== "undefined" && "piece" in options && typeof options.piece === "string" ? options.piece.toLowerCase() : true;
        if (typeof options !== "undefined" && "square" in options) {
          if (options.square in SQUARES) {
            first_sq = last_sq = SQUARES[options.square];
            single_square = true;
          } else {
            return [];
          }
        }
        for (var i2 = first_sq; i2 <= last_sq; i2++) {
          if (i2 & 136) {
            i2 += 7;
            continue;
          }
          var piece = board[i2];
          if (piece == null || piece.color !== us) {
            continue;
          }
          if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {
            var square = i2 + PAWN_OFFSETS[us][0];
            if (board[square] == null) {
              add_move(board, moves, i2, square, BITS.NORMAL);
              var square = i2 + PAWN_OFFSETS[us][1];
              if (second_rank[us] === rank(i2) && board[square] == null) {
                add_move(board, moves, i2, square, BITS.BIG_PAWN);
              }
            }
            for (j2 = 2; j2 < 4; j2++) {
              var square = i2 + PAWN_OFFSETS[us][j2];
              if (square & 136)
                continue;
              if (board[square] != null && board[square].color === them) {
                add_move(board, moves, i2, square, BITS.CAPTURE);
              } else if (square === ep_square) {
                add_move(board, moves, i2, ep_square, BITS.EP_CAPTURE);
              }
            }
          } else if (piece_type === true || piece_type === piece.type) {
            for (var j2 = 0, len = PIECE_OFFSETS[piece.type].length; j2 < len; j2++) {
              var offset = PIECE_OFFSETS[piece.type][j2];
              var square = i2;
              while (true) {
                square += offset;
                if (square & 136)
                  break;
                if (board[square] == null) {
                  add_move(board, moves, i2, square, BITS.NORMAL);
                } else {
                  if (board[square].color === us)
                    break;
                  add_move(board, moves, i2, square, BITS.CAPTURE);
                  break;
                }
                if (piece.type === "n" || piece.type === "k")
                  break;
              }
            }
          }
        }
        if (piece_type === true || piece_type === KING) {
          if (!single_square || last_sq === kings[us]) {
            if (castling[us] & BITS.KSIDE_CASTLE) {
              var castling_from = kings[us];
              var castling_to = castling_from + 2;
              if (board[castling_from + 1] == null && board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) {
                add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);
              }
            }
            if (castling[us] & BITS.QSIDE_CASTLE) {
              var castling_from = kings[us];
              var castling_to = castling_from - 2;
              if (board[castling_from - 1] == null && board[castling_from - 2] == null && board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) {
                add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);
              }
            }
          }
        }
        if (!legal) {
          return moves;
        }
        var legal_moves = [];
        for (var i2 = 0, len = moves.length; i2 < len; i2++) {
          make_move(moves[i2]);
          if (!king_attacked(us)) {
            legal_moves.push(moves[i2]);
          }
          undo_move();
        }
        return legal_moves;
      }
      function move_to_san(move, moves) {
        var output2 = "";
        if (move.flags & BITS.KSIDE_CASTLE) {
          output2 = "O-O";
        } else if (move.flags & BITS.QSIDE_CASTLE) {
          output2 = "O-O-O";
        } else {
          if (move.piece !== PAWN) {
            var disambiguator = get_disambiguator(move, moves);
            output2 += move.piece.toUpperCase() + disambiguator;
          }
          if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
            if (move.piece === PAWN) {
              output2 += algebraic(move.from)[0];
            }
            output2 += "x";
          }
          output2 += algebraic(move.to);
          if (move.flags & BITS.PROMOTION) {
            output2 += "=" + move.promotion.toUpperCase();
          }
        }
        make_move(move);
        if (in_check()) {
          if (in_checkmate()) {
            output2 += "#";
          } else {
            output2 += "+";
          }
        }
        undo_move();
        return output2;
      }
      function stripped_san(move) {
        return move.replace(/=/, "").replace(/[+#]?[?!]*$/, "");
      }
      function attacked(color, square) {
        for (var i2 = SQUARES.a8; i2 <= SQUARES.h1; i2++) {
          if (i2 & 136) {
            i2 += 7;
            continue;
          }
          if (board[i2] == null || board[i2].color !== color)
            continue;
          var piece = board[i2];
          var difference = i2 - square;
          var index = difference + 119;
          if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {
            if (piece.type === PAWN) {
              if (difference > 0) {
                if (piece.color === WHITE)
                  return true;
              } else {
                if (piece.color === BLACK)
                  return true;
              }
              continue;
            }
            if (piece.type === "n" || piece.type === "k")
              return true;
            var offset = RAYS[index];
            var j2 = i2 + offset;
            var blocked = false;
            while (j2 !== square) {
              if (board[j2] != null) {
                blocked = true;
                break;
              }
              j2 += offset;
            }
            if (!blocked)
              return true;
          }
        }
        return false;
      }
      function king_attacked(color) {
        return attacked(swap_color(color), kings[color]);
      }
      function in_check() {
        return king_attacked(turn);
      }
      function in_checkmate() {
        return in_check() && generate_moves().length === 0;
      }
      function in_stalemate() {
        return !in_check() && generate_moves().length === 0;
      }
      function insufficient_material() {
        var pieces = {};
        var bishops = [];
        var num_pieces = 0;
        var sq_color = 0;
        for (var i2 = SQUARES.a8; i2 <= SQUARES.h1; i2++) {
          sq_color = (sq_color + 1) % 2;
          if (i2 & 136) {
            i2 += 7;
            continue;
          }
          var piece = board[i2];
          if (piece) {
            pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;
            if (piece.type === BISHOP) {
              bishops.push(sq_color);
            }
            num_pieces++;
          }
        }
        if (num_pieces === 2) {
          return true;
        } else if (
          /* k vs. kn .... or .... k vs. kb */
          num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)
        ) {
          return true;
        } else if (num_pieces === pieces[BISHOP] + 2) {
          var sum = 0;
          var len = bishops.length;
          for (var i2 = 0; i2 < len; i2++) {
            sum += bishops[i2];
          }
          if (sum === 0 || sum === len) {
            return true;
          }
        }
        return false;
      }
      function in_threefold_repetition() {
        var moves = [];
        var positions = {};
        var repetition = false;
        while (true) {
          var move = undo_move();
          if (!move)
            break;
          moves.push(move);
        }
        while (true) {
          var fen2 = generate_fen().split(" ").slice(0, 4).join(" ");
          positions[fen2] = fen2 in positions ? positions[fen2] + 1 : 1;
          if (positions[fen2] >= 3) {
            repetition = true;
          }
          if (!moves.length) {
            break;
          }
          make_move(moves.pop());
        }
        return repetition;
      }
      function push(move) {
        history.push({
          move,
          kings: { b: kings.b, w: kings.w },
          turn,
          castling: { b: castling.b, w: castling.w },
          ep_square,
          half_moves,
          move_number
        });
      }
      function make_move(move) {
        var us = turn;
        var them = swap_color(us);
        push(move);
        board[move.to] = board[move.from];
        board[move.from] = null;
        if (move.flags & BITS.EP_CAPTURE) {
          if (turn === BLACK) {
            board[move.to - 16] = null;
          } else {
            board[move.to + 16] = null;
          }
        }
        if (move.flags & BITS.PROMOTION) {
          board[move.to] = { type: move.promotion, color: us };
        }
        if (board[move.to].type === KING) {
          kings[board[move.to].color] = move.to;
          if (move.flags & BITS.KSIDE_CASTLE) {
            var castling_to = move.to - 1;
            var castling_from = move.to + 1;
            board[castling_to] = board[castling_from];
            board[castling_from] = null;
          } else if (move.flags & BITS.QSIDE_CASTLE) {
            var castling_to = move.to + 1;
            var castling_from = move.to - 2;
            board[castling_to] = board[castling_from];
            board[castling_from] = null;
          }
          castling[us] = "";
        }
        if (castling[us]) {
          for (var i2 = 0, len = ROOKS[us].length; i2 < len; i2++) {
            if (move.from === ROOKS[us][i2].square && castling[us] & ROOKS[us][i2].flag) {
              castling[us] ^= ROOKS[us][i2].flag;
              break;
            }
          }
        }
        if (castling[them]) {
          for (var i2 = 0, len = ROOKS[them].length; i2 < len; i2++) {
            if (move.to === ROOKS[them][i2].square && castling[them] & ROOKS[them][i2].flag) {
              castling[them] ^= ROOKS[them][i2].flag;
              break;
            }
          }
        }
        if (move.flags & BITS.BIG_PAWN) {
          if (turn === "b") {
            ep_square = move.to - 16;
          } else {
            ep_square = move.to + 16;
          }
        } else {
          ep_square = EMPTY;
        }
        if (move.piece === PAWN) {
          half_moves = 0;
        } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
          half_moves = 0;
        } else {
          half_moves++;
        }
        if (turn === BLACK) {
          move_number++;
        }
        turn = swap_color(turn);
      }
      function undo_move() {
        var old = history.pop();
        if (old == null) {
          return null;
        }
        var move = old.move;
        kings = old.kings;
        turn = old.turn;
        castling = old.castling;
        ep_square = old.ep_square;
        half_moves = old.half_moves;
        move_number = old.move_number;
        var us = turn;
        var them = swap_color(turn);
        board[move.from] = board[move.to];
        board[move.from].type = move.piece;
        board[move.to] = null;
        if (move.flags & BITS.CAPTURE) {
          board[move.to] = { type: move.captured, color: them };
        } else if (move.flags & BITS.EP_CAPTURE) {
          var index;
          if (us === BLACK) {
            index = move.to - 16;
          } else {
            index = move.to + 16;
          }
          board[index] = { type: PAWN, color: them };
        }
        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
          var castling_to, castling_from;
          if (move.flags & BITS.KSIDE_CASTLE) {
            castling_to = move.to + 1;
            castling_from = move.to - 1;
          } else if (move.flags & BITS.QSIDE_CASTLE) {
            castling_to = move.to - 2;
            castling_from = move.to + 1;
          }
          board[castling_to] = board[castling_from];
          board[castling_from] = null;
        }
        return move;
      }
      function get_disambiguator(move, moves) {
        var from6 = move.from;
        var to2 = move.to;
        var piece = move.piece;
        var ambiguities = 0;
        var same_rank = 0;
        var same_file = 0;
        for (var i2 = 0, len = moves.length; i2 < len; i2++) {
          var ambig_from = moves[i2].from;
          var ambig_to = moves[i2].to;
          var ambig_piece = moves[i2].piece;
          if (piece === ambig_piece && from6 !== ambig_from && to2 === ambig_to) {
            ambiguities++;
            if (rank(from6) === rank(ambig_from)) {
              same_rank++;
            }
            if (file(from6) === file(ambig_from)) {
              same_file++;
            }
          }
        }
        if (ambiguities > 0) {
          if (same_rank > 0 && same_file > 0) {
            return algebraic(from6);
          } else if (same_file > 0) {
            return algebraic(from6).charAt(1);
          } else {
            return algebraic(from6).charAt(0);
          }
        }
        return "";
      }
      function infer_piece_type(san) {
        var piece_type = san.charAt(0);
        if (piece_type >= "a" && piece_type <= "h") {
          var matches = san.match(/[a-h]\d.*[a-h]\d/);
          if (matches) {
            return void 0;
          }
          return PAWN;
        }
        piece_type = piece_type.toLowerCase();
        if (piece_type === "o") {
          return KING;
        }
        return piece_type;
      }
      function ascii3() {
        var s2 = "   +------------------------+\n";
        for (var i2 = SQUARES.a8; i2 <= SQUARES.h1; i2++) {
          if (file(i2) === 0) {
            s2 += " " + "87654321"[rank(i2)] + " |";
          }
          if (board[i2] == null) {
            s2 += " . ";
          } else {
            var piece = board[i2].type;
            var color = board[i2].color;
            var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
            s2 += " " + symbol + " ";
          }
          if (i2 + 1 & 136) {
            s2 += "|\n";
            i2 += 8;
          }
        }
        s2 += "   +------------------------+\n";
        s2 += "     a  b  c  d  e  f  g  h\n";
        return s2;
      }
      function move_from_san(move, sloppy) {
        var clean_move = stripped_san(move);
        var overly_disambiguated = false;
        if (sloppy) {
          var matches = clean_move.match(
            /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/
          );
          if (matches) {
            var piece = matches[1];
            var from6 = matches[2];
            var to2 = matches[3];
            var promotion = matches[4];
            if (from6.length == 1) {
              overly_disambiguated = true;
            }
          } else {
            var matches = clean_move.match(
              /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/
            );
            if (matches) {
              var piece = matches[1];
              var from6 = matches[2];
              var to2 = matches[3];
              var promotion = matches[4];
              if (from6.length == 1) {
                var overly_disambiguated = true;
              }
            }
          }
        }
        var piece_type = infer_piece_type(clean_move);
        var moves = generate_moves({
          legal: true,
          piece: piece ? piece : piece_type
        });
        for (var i2 = 0, len = moves.length; i2 < len; i2++) {
          if (clean_move === stripped_san(move_to_san(moves[i2], moves))) {
            return moves[i2];
          } else {
            if (sloppy && matches) {
              if ((!piece || piece.toLowerCase() == moves[i2].piece) && SQUARES[from6] == moves[i2].from && SQUARES[to2] == moves[i2].to && (!promotion || promotion.toLowerCase() == moves[i2].promotion)) {
                return moves[i2];
              } else if (overly_disambiguated) {
                var square = algebraic(moves[i2].from);
                if ((!piece || piece.toLowerCase() == moves[i2].piece) && SQUARES[to2] == moves[i2].to && (from6 == square[0] || from6 == square[1]) && (!promotion || promotion.toLowerCase() == moves[i2].promotion)) {
                  return moves[i2];
                }
              }
            }
          }
        }
        return null;
      }
      function rank(i2) {
        return i2 >> 4;
      }
      function file(i2) {
        return i2 & 15;
      }
      function algebraic(i2) {
        var f3 = file(i2), r2 = rank(i2);
        return "abcdefgh".substring(f3, f3 + 1) + "87654321".substring(r2, r2 + 1);
      }
      function swap_color(c2) {
        return c2 === WHITE ? BLACK : WHITE;
      }
      function is_digit(c2) {
        return "0123456789".indexOf(c2) !== -1;
      }
      function make_pretty(ugly_move) {
        var move = clone(ugly_move);
        move.san = move_to_san(move, generate_moves({ legal: true }));
        move.to = algebraic(move.to);
        move.from = algebraic(move.from);
        var flags = "";
        for (var flag in BITS) {
          if (BITS[flag] & move.flags) {
            flags += FLAGS[flag];
          }
        }
        move.flags = flags;
        return move;
      }
      function clone(obj) {
        var dupe = obj instanceof Array ? [] : {};
        for (var property in obj) {
          if (typeof property === "object") {
            dupe[property] = clone(obj[property]);
          } else {
            dupe[property] = obj[property];
          }
        }
        return dupe;
      }
      function trim(str) {
        return str.replace(/^\s+|\s+$/g, "");
      }
      function perft(depth) {
        var moves = generate_moves({ legal: false });
        var nodes = 0;
        var color = turn;
        for (var i2 = 0, len = moves.length; i2 < len; i2++) {
          make_move(moves[i2]);
          if (!king_attacked(color)) {
            if (depth - 1 > 0) {
              var child_nodes = perft(depth - 1);
              nodes += child_nodes;
            } else {
              nodes++;
            }
          }
          undo_move();
        }
        return nodes;
      }
      return {
        /***************************************************************************
         * PUBLIC CONSTANTS (is there a better way to do this?)
         **************************************************************************/
        WHITE,
        BLACK,
        PAWN,
        KNIGHT,
        BISHOP,
        ROOK,
        QUEEN,
        KING,
        SQUARES: function() {
          var keys = [];
          for (var i2 = SQUARES.a8; i2 <= SQUARES.h1; i2++) {
            if (i2 & 136) {
              i2 += 7;
              continue;
            }
            keys.push(algebraic(i2));
          }
          return keys;
        }(),
        FLAGS,
        /***************************************************************************
         * PUBLIC API
         **************************************************************************/
        load: function(fen2) {
          return load(fen2);
        },
        reset: function() {
          return reset();
        },
        moves: function(options) {
          var ugly_moves = generate_moves(options);
          var moves = [];
          for (var i2 = 0, len = ugly_moves.length; i2 < len; i2++) {
            if (typeof options !== "undefined" && "verbose" in options && options.verbose) {
              moves.push(make_pretty(ugly_moves[i2]));
            } else {
              moves.push(
                move_to_san(ugly_moves[i2], generate_moves({ legal: true }))
              );
            }
          }
          return moves;
        },
        in_check: function() {
          return in_check();
        },
        in_checkmate: function() {
          return in_checkmate();
        },
        in_stalemate: function() {
          return in_stalemate();
        },
        in_draw: function() {
          return half_moves >= 100 || in_stalemate() || insufficient_material() || in_threefold_repetition();
        },
        insufficient_material: function() {
          return insufficient_material();
        },
        in_threefold_repetition: function() {
          return in_threefold_repetition();
        },
        game_over: function() {
          return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition();
        },
        validate_fen: function(fen2) {
          return validate_fen(fen2);
        },
        fen: function() {
          return generate_fen();
        },
        board: function() {
          var output2 = [], row = [];
          for (var i2 = SQUARES.a8; i2 <= SQUARES.h1; i2++) {
            if (board[i2] == null) {
              row.push(null);
            } else {
              row.push({ type: board[i2].type, color: board[i2].color });
            }
            if (i2 + 1 & 136) {
              output2.push(row);
              row = [];
              i2 += 8;
            }
          }
          return output2;
        },
        pgn: function(options) {
          var newline = typeof options === "object" && typeof options.newline_char === "string" ? options.newline_char : "\n";
          var max_width = typeof options === "object" && typeof options.max_width === "number" ? options.max_width : 0;
          var result = [];
          var header_exists = false;
          for (var i2 in header) {
            result.push("[" + i2 + ' "' + header[i2] + '"]' + newline);
            header_exists = true;
          }
          if (header_exists && history.length) {
            result.push(newline);
          }
          var append_comment = function(move_string2) {
            var comment = comments[generate_fen()];
            if (typeof comment !== "undefined") {
              var delimiter = move_string2.length > 0 ? " " : "";
              move_string2 = `${move_string2}${delimiter}{${comment}}`;
            }
            return move_string2;
          };
          var reversed_history = [];
          while (history.length > 0) {
            reversed_history.push(undo_move());
          }
          var moves = [];
          var move_string = "";
          if (reversed_history.length === 0) {
            moves.push(append_comment(""));
          }
          while (reversed_history.length > 0) {
            move_string = append_comment(move_string);
            var move = reversed_history.pop();
            if (!history.length && move.color === "b") {
              move_string = move_number + ". ...";
            } else if (move.color === "w") {
              if (move_string.length) {
                moves.push(move_string);
              }
              move_string = move_number + ".";
            }
            move_string = move_string + " " + move_to_san(move, generate_moves({ legal: true }));
            make_move(move);
          }
          if (move_string.length) {
            moves.push(append_comment(move_string));
          }
          if (typeof header.Result !== "undefined") {
            moves.push(header.Result);
          }
          if (max_width === 0) {
            return result.join("") + moves.join(" ");
          }
          var strip = function() {
            if (result.length > 0 && result[result.length - 1] === " ") {
              result.pop();
              return true;
            }
            return false;
          };
          var wrap_comment = function(width, move2) {
            for (var token of move2.split(" ")) {
              if (!token) {
                continue;
              }
              if (width + token.length > max_width) {
                while (strip()) {
                  width--;
                }
                result.push(newline);
                width = 0;
              }
              result.push(token);
              width += token.length;
              result.push(" ");
              width++;
            }
            if (strip()) {
              width--;
            }
            return width;
          };
          var current_width = 0;
          for (var i2 = 0; i2 < moves.length; i2++) {
            if (current_width + moves[i2].length > max_width) {
              if (moves[i2].includes("{")) {
                current_width = wrap_comment(current_width, moves[i2]);
                continue;
              }
            }
            if (current_width + moves[i2].length > max_width && i2 !== 0) {
              if (result[result.length - 1] === " ") {
                result.pop();
              }
              result.push(newline);
              current_width = 0;
            } else if (i2 !== 0) {
              result.push(" ");
              current_width++;
            }
            result.push(moves[i2]);
            current_width += moves[i2].length;
          }
          return result.join("");
        },
        load_pgn: function(pgn, options) {
          var sloppy = typeof options !== "undefined" && "sloppy" in options ? options.sloppy : false;
          function mask(str) {
            return str.replace(/\\/g, "\\");
          }
          function has_keys(object) {
            for (var key2 in object) {
              return true;
            }
            return false;
          }
          function parse_pgn_header(header2, options2) {
            var newline_char2 = typeof options2 === "object" && typeof options2.newline_char === "string" ? options2.newline_char : "\r?\n";
            var header_obj = {};
            var headers2 = header2.split(new RegExp(mask(newline_char2)));
            var key2 = "";
            var value = "";
            for (var i2 = 0; i2 < headers2.length; i2++) {
              key2 = headers2[i2].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/, "$1");
              value = headers2[i2].replace(/^\[[A-Za-z]+\s"(.*)"\ *\]$/, "$1");
              if (trim(key2).length > 0) {
                header_obj[key2] = value;
              }
            }
            return header_obj;
          }
          var newline_char = typeof options === "object" && typeof options.newline_char === "string" ? options.newline_char : "\r?\n";
          var header_regex = new RegExp(
            "^(\\[((?:" + mask(newline_char) + ")|.)*\\])(?:" + mask(newline_char) + "){2}"
          );
          var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : "";
          reset();
          var headers = parse_pgn_header(header_string, options);
          for (var key in headers) {
            set_header([key, headers[key]]);
          }
          if (headers["SetUp"] === "1") {
            if (!("FEN" in headers && load(headers["FEN"], true))) {
              return false;
            }
          }
          var to_hex = function(string3) {
            return Array.from(string3).map(function(c2) {
              return c2.charCodeAt(0) < 128 ? c2.charCodeAt(0).toString(16) : encodeURIComponent(c2).replace(/\%/g, "").toLowerCase();
            }).join("");
          };
          var from_hex = function(string3) {
            return string3.length == 0 ? "" : decodeURIComponent("%" + string3.match(/.{1,2}/g).join("%"));
          };
          var encode_comment = function(string3) {
            string3 = string3.replace(new RegExp(mask(newline_char), "g"), " ");
            return `{${to_hex(string3.slice(1, string3.length - 1))}}`;
          };
          var decode_comment = function(string3) {
            if (string3.startsWith("{") && string3.endsWith("}")) {
              return from_hex(string3.slice(1, string3.length - 1));
            }
          };
          var ms = pgn.replace(header_string, "").replace(
            /* encode comments so they don't get deleted below */
            new RegExp(`({[^}]*})+?|;([^${mask(newline_char)}]*)`, "g"),
            function(match, bracket, semicolon) {
              return bracket !== void 0 ? encode_comment(bracket) : " " + encode_comment(`{${semicolon.slice(1)}}`);
            }
          ).replace(new RegExp(mask(newline_char), "g"), " ");
          var rav_regex = /(\([^\(\)]+\))+?/g;
          while (rav_regex.test(ms)) {
            ms = ms.replace(rav_regex, "");
          }
          ms = ms.replace(/\d+\.(\.\.)?/g, "");
          ms = ms.replace(/\.\.\./g, "");
          ms = ms.replace(/\$\d+/g, "");
          var moves = trim(ms).split(new RegExp(/\s+/));
          moves = moves.join(",").replace(/,,+/g, ",").split(",");
          var move = "";
          var result = "";
          for (var half_move = 0; half_move < moves.length; half_move++) {
            var comment = decode_comment(moves[half_move]);
            if (comment !== void 0) {
              comments[generate_fen()] = comment;
              continue;
            }
            move = move_from_san(moves[half_move], sloppy);
            if (move == null) {
              if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {
                result = moves[half_move];
              } else {
                return false;
              }
            } else {
              result = "";
              make_move(move);
            }
          }
          if (result && Object.keys(header).length && !header["Result"]) {
            set_header(["Result", result]);
          }
          return true;
        },
        header: function() {
          return set_header(arguments);
        },
        ascii: function() {
          return ascii3();
        },
        turn: function() {
          return turn;
        },
        move: function(move, options) {
          var sloppy = typeof options !== "undefined" && "sloppy" in options ? options.sloppy : false;
          var move_obj = null;
          if (typeof move === "string") {
            move_obj = move_from_san(move, sloppy);
          } else if (typeof move === "object") {
            var moves = generate_moves();
            for (var i2 = 0, len = moves.length; i2 < len; i2++) {
              if (move.from === algebraic(moves[i2].from) && move.to === algebraic(moves[i2].to) && (!("promotion" in moves[i2]) || move.promotion === moves[i2].promotion)) {
                move_obj = moves[i2];
                break;
              }
            }
          }
          if (!move_obj) {
            return null;
          }
          var pretty_move = make_pretty(move_obj);
          make_move(move_obj);
          return pretty_move;
        },
        undo: function() {
          var move = undo_move();
          return move ? make_pretty(move) : null;
        },
        clear: function() {
          return clear();
        },
        put: function(piece, square) {
          return put(piece, square);
        },
        get: function(square) {
          return get2(square);
        },
        remove: function(square) {
          return remove(square);
        },
        perft: function(depth) {
          return perft(depth);
        },
        square_color: function(square) {
          if (square in SQUARES) {
            var sq_0x88 = SQUARES[square];
            return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? "light" : "dark";
          }
          return null;
        },
        history: function(options) {
          var reversed_history = [];
          var move_history = [];
          var verbose = typeof options !== "undefined" && "verbose" in options && options.verbose;
          while (history.length > 0) {
            reversed_history.push(undo_move());
          }
          while (reversed_history.length > 0) {
            var move = reversed_history.pop();
            if (verbose) {
              move_history.push(make_pretty(move));
            } else {
              move_history.push(move_to_san(move, generate_moves({ legal: true })));
            }
            make_move(move);
          }
          return move_history;
        },
        get_comment: function() {
          return comments[generate_fen()];
        },
        set_comment: function(comment) {
          comments[generate_fen()] = comment.replace("{", "[").replace("}", "]");
        },
        delete_comment: function() {
          var comment = comments[generate_fen()];
          delete comments[generate_fen()];
          return comment;
        },
        get_comments: function() {
          prune_comments();
          return Object.keys(comments).map(function(fen2) {
            return { fen: fen2, comment: comments[fen2] };
          });
        },
        delete_comments: function() {
          prune_comments();
          return Object.keys(comments).map(function(fen2) {
            var comment = comments[fen2];
            delete comments[fen2];
            return { fen: fen2, comment };
          });
        }
      };
    };
    if (typeof exports2 !== "undefined")
      exports2.Chess = Chess2;
    if (typeof define !== "undefined")
      define(function() {
        return Chess2;
      });
  }
});

// src/components/Games.tsx
var import_react5 = __toESM(require_react(), 1);
var import_react_router_dom2 = __toESM(require_react_router_dom(), 1);
var import_react_query = __toESM(require_react_query(), 1);
var import_veramo_react2 = __toESM(require_veramo_react(), 1);
var import_pro_components = __toESM(require_pro_components(), 1);

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/components/Context.js
var import_react = __toESM(require_react());
var IconContext = /* @__PURE__ */ (0, import_react.createContext)({});
var Context_default = IconContext;

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f3 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f3 = false;
      } else
        for (; !(f3 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f3 = true)
          ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f3 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a2;
  }
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/components/AntdIcon.js
var React3 = __toESM(require_react());
var import_classnames = __toESM(require_classnames());

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/util.js
function bound01(n2, max) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/conversion.js
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
      default:
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2);
  var f3 = h2 - i2;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f3 * s2);
  var t2 = v2 * (1 - (1 - f3) * s2);
  var mod3 = i2 % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod3];
  var g2 = [t2, v2, v2, q2, p2, p2][mod3];
  var b2 = [p2, p2, t2, v2, v2, q2][mod3];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/format-input.js
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format3 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format3 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v2 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v2);
      ok = true;
      format3 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok = true;
      format3 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format3,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}

// node_modules/.pnpm/@ant-design+colors@7.0.0/node_modules/@ant-design/colors/es/generate.js
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b2, false));
}
function mix(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate(color) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue(hsv, i2, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (var _i2 = 1; _i2 <= darkColorCount; _i2 += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex(inputToRGB({
      h: getHue(_hsv, _i2),
      s: getSaturation(_hsv, _i2),
      v: getValue(_hsv, _i2)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}

// node_modules/.pnpm/@ant-design+colors@7.0.0/node_modules/@ant-design/colors/es/index.js
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key) {
  presetPalettes[key] = generate(presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5];
  presetDarkPalettes[key] = generate(presetPrimaryColors[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});
var red = presetPalettes.red;
var volcano = presetPalettes.volcano;
var gold = presetPalettes.gold;
var orange = presetPalettes.orange;
var yellow = presetPalettes.yellow;
var lime = presetPalettes.lime;
var green = presetPalettes.green;
var cyan = presetPalettes.cyan;
var blue = presetPalettes.blue;
var geekblue = presetPalettes.geekblue;
var purple = presetPalettes.purple;
var magenta = presetPalettes.magenta;
var grey = presetPalettes.grey;
var gray = presetPalettes.grey;

// node_modules/.pnpm/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/components/IconBase.js
var React2 = __toESM(require_react());

// node_modules/.pnpm/rc-util@5.37.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/Dom/canUseDom.js
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}

// node_modules/.pnpm/rc-util@5.37.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/Dom/contains.js
function contains(root, n2) {
  if (!root) {
    return false;
  }
  if (root.contains) {
    return root.contains(n2);
  }
  var node = n2;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}

// node_modules/.pnpm/rc-util@5.37.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/Dom/dynamicCSS.js
var APPEND_ORDER = "data-rc-order";
var APPEND_PRIORITY = "data-rc-priority";
var MARK_KEY = "rc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  if (mark) {
    return mark.startsWith("data-") ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function(node) {
    return node.tagName === "STYLE";
  });
}
function injectCSS(css) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
  var mergedOrder = getOrder(prepend);
  var isPrependQueue = mergedOrder === "prependQueue";
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, mergedOrder);
  if (isPrependQueue && priority) {
    styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
  }
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (isPrependQueue) {
      var existStyle = findStyles(container).filter(function(node) {
        if (!["prepend", "prependQueue"].includes(node.getAttribute(APPEND_ORDER))) {
          return false;
        }
        var nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
        return priority >= nodePriority;
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer(option);
  return findStyles(container).find(function(node) {
    return node.getAttribute(getMark(option)) === key;
  });
}
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS(css, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer(option);
  syncRealContainer(container, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css) {
      existNode.innerHTML = css;
    }
    return existNode;
  }
  var newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}

// node_modules/.pnpm/rc-util@5.37.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/Dom/shadow.js
function getRoot(ele) {
  var _ele$getRootNode;
  return ele === null || ele === void 0 ? void 0 : (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
}
function inShadow(ele) {
  return getRoot(ele) instanceof ShadowRoot;
}
function getShadowRoot(ele) {
  return inShadow(ele) ? getRoot(ele) : null;
}

// node_modules/.pnpm/rc-util@5.37.0_react-dom@18.2.0_react@18.2.0/node_modules/rc-util/es/warning.js
var warned = {};
var preWarningFns = [];
var preMessage = function preMessage2(fn2) {
  preWarningFns.push(fn2);
};
function warning(valid, message2) {
  if (!valid && console !== void 0) {
    var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
      return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "warning");
    }, message2);
    if (finalMessage) {
      console.error("Warning: ".concat(finalMessage));
    }
  }
}
function note(valid, message2) {
  if (!valid && console !== void 0) {
    var finalMessage = preWarningFns.reduce(function(msg, preMessageFn) {
      return preMessageFn(msg !== null && msg !== void 0 ? msg : "", "note");
    }, message2);
    if (finalMessage) {
      console.warn("Note: ".concat(finalMessage));
    }
  }
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message2) {
  if (!valid && !warned[message2]) {
    method(false, message2);
    warned[message2] = true;
  }
}
function warningOnce(valid, message2) {
  call(warning, valid, message2);
}
function noteOnce(valid, message2) {
  call(note, valid, message2);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
var warning_default = warningOnce;

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/utils.js
var import_react2 = __toESM(require_react());
function camelCase(input) {
  return input.replace(/-(.)/g, function(match, g2) {
    return g2.toUpperCase();
  });
}
function warning2(valid, message2) {
  warning_default(valid, "[@ant-design/icons] ".concat(message2));
}
function isIconDefinition(target) {
  return _typeof(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key) {
    var val = attrs[key];
    switch (key) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        delete acc[key];
        acc[camelCase(key)] = val;
    }
    return acc;
  }, {});
}
function generate2(node, key, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ import_react2.default.createElement(node.tag, _objectSpread2({
      key
    }, normalizeAttrs(node.attrs)), (node.children || []).map(function(child, index) {
      return generate2(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
    }));
  }
  return /* @__PURE__ */ import_react2.default.createElement(node.tag, _objectSpread2(_objectSpread2({
    key
  }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map(function(child, index) {
    return generate2(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
  }));
}
function getSecondaryColor(primaryColor) {
  return generate(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles = function useInsertStyles2(eleRef) {
  var _useContext = (0, import_react2.useContext)(Context_default), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
  var mergedStyleStr = iconStyles;
  if (prefixCls) {
    mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
  }
  (0, import_react2.useEffect)(function() {
    var ele = eleRef.current;
    var shadowRoot = getShadowRoot(ele);
    updateCSS(mergedStyleStr, "@ant-design-icons", {
      prepend: true,
      csp,
      attachTo: shadowRoot
    });
  }, []);
};

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/components/IconBase.js
var _excluded = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread2({}, twoToneColorPalette);
}
var IconBase = function IconBase2(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded);
  var svgRef = React2.useRef();
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles(svgRef);
  warning2(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread2(_objectSpread2({}, target), {}, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate2(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
    className,
    onClick,
    style,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps), {}, {
    ref: svgRef
  }));
};
IconBase.displayName = "IconReact";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
var IconBase_default = IconBase;

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/components/twoTonePrimaryColor.js
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return IconBase_default.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors = IconBase_default.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/components/AntdIcon.js
var _excluded2 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor(blue.primary);
var Icon = /* @__PURE__ */ React3.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded2);
  var _React$useContext = React3.useContext(Context_default), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
  var classString = (0, import_classnames.default)(rootClassName, prefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ React3.createElement("span", _extends({
    role: "img",
    "aria-label": icon.name
  }, restProps, {
    ref,
    tabIndex: iconTabIndex,
    onClick,
    className: classString
  }), /* @__PURE__ */ React3.createElement(IconBase_default, {
    icon,
    primaryColor,
    secondaryColor,
    style: svgStyle
  }));
});
Icon.displayName = "AntdIcon";
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
var AntdIcon_default = Icon;

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/icons/PlusOutlined.js
var React4 = __toESM(require_react());

// node_modules/.pnpm/@ant-design+icons-svg@4.3.1/node_modules/@ant-design/icons-svg/es/asn/PlusOutlined.js
var PlusOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
var PlusOutlined_default = PlusOutlined;

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/icons/PlusOutlined.js
var PlusOutlined2 = function PlusOutlined3(props, ref) {
  return /* @__PURE__ */ React4.createElement(AntdIcon_default, _extends({}, props, {
    ref,
    icon: PlusOutlined_default
  }));
};
if (true) {
  PlusOutlined2.displayName = "PlusOutlined";
}
var PlusOutlined_default2 = /* @__PURE__ */ React4.forwardRef(PlusOutlined2);

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/icons/QrcodeOutlined.js
var React5 = __toESM(require_react());

// node_modules/.pnpm/@ant-design+icons-svg@4.3.1/node_modules/@ant-design/icons-svg/es/asn/QrcodeOutlined.js
var QrcodeOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M468 128H160c-17.7 0-32 14.3-32 32v308c0 4.4 3.6 8 8 8h332c4.4 0 8-3.6 8-8V136c0-4.4-3.6-8-8-8zm-56 284H192V192h220v220zm-138-74h56c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm194 210H136c-4.4 0-8 3.6-8 8v308c0 17.7 14.3 32 32 32h308c4.4 0 8-3.6 8-8V556c0-4.4-3.6-8-8-8zm-56 284H192V612h220v220zm-138-74h56c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm590-630H556c-4.4 0-8 3.6-8 8v332c0 4.4 3.6 8 8 8h332c4.4 0 8-3.6 8-8V160c0-17.7-14.3-32-32-32zm-32 284H612V192h220v220zm-138-74h56c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm194 210h-48c-4.4 0-8 3.6-8 8v134h-78V556c0-4.4-3.6-8-8-8H556c-4.4 0-8 3.6-8 8v332c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V644h78v102c0 4.4 3.6 8 8 8h190c4.4 0 8-3.6 8-8V556c0-4.4-3.6-8-8-8zM746 832h-48c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm142 0h-48c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8z" } }] }, "name": "qrcode", "theme": "outlined" };
var QrcodeOutlined_default = QrcodeOutlined;

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/icons/QrcodeOutlined.js
var QrcodeOutlined2 = function QrcodeOutlined3(props, ref) {
  return /* @__PURE__ */ React5.createElement(AntdIcon_default, _extends({}, props, {
    ref,
    icon: QrcodeOutlined_default
  }));
};
if (true) {
  QrcodeOutlined2.displayName = "QrcodeOutlined";
}
var QrcodeOutlined_default2 = /* @__PURE__ */ React5.forwardRef(QrcodeOutlined2);

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/icons/SketchOutlined.js
var React6 = __toESM(require_react());

// node_modules/.pnpm/@ant-design+icons-svg@4.3.1/node_modules/@ant-design/icons-svg/es/asn/SketchOutlined.js
var SketchOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M925.6 405.1l-203-253.7a6.5 6.5 0 00-5-2.4H306.4c-1.9 0-3.8.9-5 2.4l-203 253.7a6.5 6.5 0 00.2 8.3l408.6 459.5c1.2 1.4 3 2.1 4.8 2.1 1.8 0 3.5-.8 4.8-2.1l408.6-459.5a6.5 6.5 0 00.2-8.3zM645.2 206.4l34.4 133.9-132.5-133.9h98.1zm8.2 178.5H370.6L512 242l141.4 142.9zM378.8 206.4h98.1L344.3 340.3l34.5-133.9zm-53.4 7l-44.1 171.5h-93.1l137.2-171.5zM194.6 434.9H289l125.8 247.7-220.2-247.7zM512 763.4L345.1 434.9h333.7L512 763.4zm97.1-80.8L735 434.9h94.4L609.1 682.6zm133.6-297.7l-44.1-171.5 137.2 171.5h-93.1z" } }] }, "name": "sketch", "theme": "outlined" };
var SketchOutlined_default = SketchOutlined;

// node_modules/.pnpm/@ant-design+icons@5.2.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/es/icons/SketchOutlined.js
var SketchOutlined2 = function SketchOutlined3(props, ref) {
  return /* @__PURE__ */ React6.createElement(AntdIcon_default, _extends({}, props, {
    ref,
    icon: SketchOutlined_default
  }));
};
if (true) {
  SketchOutlined2.displayName = "SketchOutlined";
}
var SketchOutlined_default2 = /* @__PURE__ */ React6.forwardRef(SketchOutlined2);

// src/components/Games.tsx
var import_agent_explorer_plugin3 = __toESM(require_agent_explorer_plugin(), 1);
var import_antd2 = __toESM(require_antd(), 1);

// src/components/CreateChessGame.tsx
var import_antd = __toESM(require_antd(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_veramo_react = __toESM(require_veramo_react(), 1);
var import_agent_explorer_plugin = __toESM(require_agent_explorer_plugin(), 1);

// node_modules/.pnpm/@yudiel+react-qr-scanner@1.2.10_react-dom@18.2.0_react@18.2.0/node_modules/@yudiel/react-qr-scanner/dist/esm/index.js
var import_react3 = __toESM(require_react());
var s = function() {
  return s = Object.assign || function(t2) {
    for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
      for (var o2 in e2 = arguments[r2])
        Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
    return t2;
  }, s.apply(this, arguments);
};
function u(t2, e2, r2, n2) {
  return new (r2 || (r2 = Promise))(function(o2, i2) {
    function a2(t3) {
      try {
        u2(n2.next(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function s2(t3) {
      try {
        u2(n2.throw(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function u2(t3) {
      var e3;
      t3.done ? o2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
        t4(e3);
      })).then(a2, s2);
    }
    u2((n2 = n2.apply(t2, e2 || [])).next());
  });
}
function c(t2, e2) {
  var r2, n2, o2, i2, a2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function s2(s3) {
    return function(u2) {
      return function(s4) {
        if (r2)
          throw new TypeError("Generator is already executing.");
        for (; i2 && (i2 = 0, s4[0] && (a2 = 0)), a2; )
          try {
            if (r2 = 1, n2 && (o2 = 2 & s4[0] ? n2.return : s4[0] ? n2.throw || ((o2 = n2.return) && o2.call(n2), 0) : n2.next) && !(o2 = o2.call(n2, s4[1])).done)
              return o2;
            switch (n2 = 0, o2 && (s4 = [2 & s4[0], o2.value]), s4[0]) {
              case 0:
              case 1:
                o2 = s4;
                break;
              case 4:
                return a2.label++, { value: s4[1], done: false };
              case 5:
                a2.label++, n2 = s4[1], s4 = [0];
                continue;
              case 7:
                s4 = a2.ops.pop(), a2.trys.pop();
                continue;
              default:
                if (!(o2 = a2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== s4[0] && 2 !== s4[0])) {
                  a2 = 0;
                  continue;
                }
                if (3 === s4[0] && (!o2 || s4[1] > o2[0] && s4[1] < o2[3])) {
                  a2.label = s4[1];
                  break;
                }
                if (6 === s4[0] && a2.label < o2[1]) {
                  a2.label = o2[1], o2 = s4;
                  break;
                }
                if (o2 && a2.label < o2[2]) {
                  a2.label = o2[2], a2.ops.push(s4);
                  break;
                }
                o2[2] && a2.ops.pop(), a2.trys.pop();
                continue;
            }
            s4 = e2.call(t2, a2);
          } catch (t3) {
            s4 = [6, t3], n2 = 0;
          } finally {
            r2 = o2 = 0;
          }
        if (5 & s4[0])
          throw s4[1];
        return { value: s4[0] ? s4[1] : void 0, done: true };
      }([s3, u2]);
    };
  }
}
var f = { facingMode: "environment", width: { min: 640, ideal: 720, max: 1920 }, height: { min: 640, ideal: 720, max: 1080 } };
var h = "undefined" != typeof navigator && navigator.mediaDevices ? function(t2) {
  var n2 = (0, import_react3.useState)([]), o2 = n2[0], i2 = n2[1];
  return (0, import_react3.useEffect)(function() {
    var e2, r2 = { audio: false, video: null != t2 ? t2 : f }, n3 = function() {
      navigator.mediaDevices.getUserMedia(r2).then(function(t3) {
        var r3 = [];
        e2 = t3, t3.getVideoTracks().forEach(function(t4) {
          r3.push(t4.getSettings());
        }), i2(r3);
      }).catch(function(t3) {
        return console.log(t3);
      });
    };
    return function(t3) {
      for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
        e3[r3 - 1] = arguments[r3];
      t3 && t3.addEventListener && t3.addEventListener.apply(t3, e3);
    }(navigator.mediaDevices, "devicechange", n3), n3(), function() {
      !function(t3) {
        for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
          e3[r3 - 1] = arguments[r3];
        t3 && t3.removeEventListener && t3.removeEventListener.apply(t3, e3);
      }(navigator.mediaDevices, "devicechange", n3), void 0 !== e2 && e2.getVideoTracks().forEach(function(t3) {
        t3.stop();
      });
    };
  }, []), o2;
} : function() {
  return [];
};
var l = function(e2) {
  var o2, i2, a2 = e2.result, s2 = e2.video, u2 = e2.constraints, c2 = e2.deviceId, f3 = e2.scanDelay, l2 = (0, import_react3.useRef)(null), d2 = h(u2);
  return (0, import_react3.useEffect)(function() {
    if (void 0 !== a2 && null !== l2.current && null !== s2 && 11 === a2.getBarcodeFormat()) {
      var t2 = d2[0];
      if (void 0 !== c2 && d2.length > 1) {
        var e3 = d2.find(function(t3) {
          return t3.deviceId === c2;
        });
        void 0 !== e3 && (t2 = e3);
      }
      if (void 0 !== t2 && void 0 !== t2.width) {
        var r2 = t2.width / s2.clientWidth, n2 = l2.current, o3 = n2.getContext("2d");
        if (null !== o3) {
          var i3 = setTimeout(function() {
            o3.clearRect(0, 0, n2.width, n2.height);
          }, f3);
          o3.strokeStyle = "rgba(0, 255, 0, 0.5)", o3.lineWidth = 4;
          var u3 = a2.getResultPoints()[0];
          o3.beginPath(), o3.arc(u3.getX() / r2, u3.getY() / r2, u3.estimatedModuleSize, 0, 2 * Math.PI), o3.stroke(), o3.closePath();
          var h2 = a2.getResultPoints()[1];
          o3.beginPath(), o3.arc(h2.getX() / r2, h2.getY() / r2, h2.estimatedModuleSize, 0, 2 * Math.PI), o3.stroke(), o3.closePath();
          var p2 = a2.getResultPoints()[2];
          if (o3.beginPath(), o3.arc(p2.getX() / r2, p2.getY() / r2, p2.estimatedModuleSize, 0, 2 * Math.PI), o3.stroke(), o3.closePath(), a2.getResultPoints().length >= 4) {
            var g2 = a2.getResultPoints()[3];
            o3.beginPath(), o3.arc(g2.getX() / r2, g2.getY() / r2, g2.estimatedModuleSize, 0, 2 * Math.PI), o3.stroke(), o3.closePath();
          }
          return function() {
            return clearTimeout(i3);
          };
        }
      }
    }
  }), import_react3.default.createElement("canvas", { ref: l2, width: null !== (o2 = null == s2 ? void 0 : s2.clientWidth) && void 0 !== o2 ? o2 : 0, height: null !== (i2 = null == s2 ? void 0 : s2.clientHeight) && void 0 !== i2 ? i2 : 0, style: { position: "absolute", top: 0, zIndex: 2 } });
};
var d = { count: { bottom: 0, right: 5, fontSize: 30, color: "#fff", position: "absolute", zIndex: 1 } };
var p = function(e2) {
  var r2 = e2.scanCount;
  return import_react3.default.createElement("div", { style: d.count }, r2);
};
var g = function(n2) {
  var i2 = n2.scanCount, a2 = n2.hideCount, s2 = n2.tracker, u2 = n2.border, c2 = void 0 === u2 ? 80 : u2, f3 = n2.result, h2 = n2.video, d2 = n2.constraints, g2 = n2.deviceId, y2 = n2.scanDelay, w2 = (0, import_react3.useState)("rgba(255, 0, 0, 0.5)"), v2 = w2[0], _2 = w2[1];
  return (0, import_react3.useEffect)(function() {
    if (11 != (null == f3 ? void 0 : f3.getBarcodeFormat()) || !s2) {
      _2("rgba(0, 255, 0, 0.5)");
      var t2 = setTimeout(function() {
        _2("rgba(255, 0, 0, 0.5)");
      }, y2);
      return function() {
        clearTimeout(t2);
      };
    }
    _2("rgba(255, 0, 0, 0.5)");
  }, [i2]), import_react3.default.createElement(import_react3.Fragment, null, !a2 && import_react3.default.createElement(p, { scanCount: i2 }), s2 && import_react3.default.createElement(l, { video: h2, result: f3, constraints: d2, deviceId: g2, scanDelay: y2 }), import_react3.default.createElement("svg", { viewBox: "0 0 100 100", style: { top: 0, left: 0, zIndex: 1, boxSizing: "border-box", border: "".concat(c2, "px solid rgba(0, 0, 0, 0.1)"), position: "absolute", width: "100%", height: "100%" } }, import_react3.default.createElement("path", { fill: "none", d: "M23,0 L0,0 L0,23", stroke: v2, strokeWidth: "5" }), import_react3.default.createElement("path", { fill: "none", d: "M0,77 L0,100 L23,100", stroke: v2, strokeWidth: "5" }), import_react3.default.createElement("path", { fill: "none", d: "M77,100 L100,100 L100,77", stroke: v2, strokeWidth: "5" }), import_react3.default.createElement("path", { fill: "none", d: "M100,23 L100,0 77,0", stroke: v2, strokeWidth: "5" })));
};
var y;
var w;
var v;
var _ = (y = function(t2, e2) {
  return y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
    t3.__proto__ = e3;
  } || function(t3, e3) {
    for (var r2 in e3)
      Object.prototype.hasOwnProperty.call(e3, r2) && (t3[r2] = e3[r2]);
  }, y(t2, e2);
}, function(t2, e2) {
  if ("function" != typeof e2 && null !== e2)
    throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
  function r2() {
    this.constructor = t2;
  }
  y(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (r2.prototype = e2.prototype, new r2());
});
var A = function(t2) {
  function e2(e3, r2) {
    var n2, o2, i2, a2 = this.constructor, s2 = t2.call(this, e3, r2) || this;
    return Object.defineProperty(s2, "name", { value: a2.name, enumerable: false, configurable: true }), n2 = s2, o2 = a2.prototype, (i2 = Object.setPrototypeOf) ? i2(n2, o2) : n2.__proto__ = o2, function(t3, e4) {
      void 0 === e4 && (e4 = t3.constructor);
      var r3 = Error.captureStackTrace;
      r3 && r3(t3, e4);
    }(s2), s2;
  }
  return _(e2, t2), e2;
}(Error);
var C = (w = function(t2, e2) {
  return w = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
    t3.__proto__ = e3;
  } || function(t3, e3) {
    for (var r2 in e3)
      e3.hasOwnProperty(r2) && (t3[r2] = e3[r2]);
  }, w(t2, e2);
}, function(t2, e2) {
  function r2() {
    this.constructor = t2;
  }
  w(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (r2.prototype = e2.prototype, new r2());
});
var m = function(t2) {
  function e2(e3) {
    void 0 === e3 && (e3 = void 0);
    var r2 = t2.call(this, e3) || this;
    return r2.message = e3, r2;
  }
  return C(e2, t2), e2.prototype.getKind = function() {
    return this.constructor.kind;
  }, e2.kind = "Exception", e2;
}(A);
var E = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var I = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return E(e2, t2), e2.kind = "ArgumentException", e2;
}(m);
var S = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var T = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return S(e2, t2), e2.kind = "IllegalArgumentException", e2;
}(m);
var O = function() {
  function t2(t3) {
    if (this.binarizer = t3, null === t3)
      throw new T("Binarizer must be non-null.");
  }
  return t2.prototype.getWidth = function() {
    return this.binarizer.getWidth();
  }, t2.prototype.getHeight = function() {
    return this.binarizer.getHeight();
  }, t2.prototype.getBlackRow = function(t3, e2) {
    return this.binarizer.getBlackRow(t3, e2);
  }, t2.prototype.getBlackMatrix = function() {
    return null !== this.matrix && void 0 !== this.matrix || (this.matrix = this.binarizer.getBlackMatrix()), this.matrix;
  }, t2.prototype.isCropSupported = function() {
    return this.binarizer.getLuminanceSource().isCropSupported();
  }, t2.prototype.crop = function(e2, r2, n2, o2) {
    var i2 = this.binarizer.getLuminanceSource().crop(e2, r2, n2, o2);
    return new t2(this.binarizer.createBinarizer(i2));
  }, t2.prototype.isRotateSupported = function() {
    return this.binarizer.getLuminanceSource().isRotateSupported();
  }, t2.prototype.rotateCounterClockwise = function() {
    var e2 = this.binarizer.getLuminanceSource().rotateCounterClockwise();
    return new t2(this.binarizer.createBinarizer(e2));
  }, t2.prototype.rotateCounterClockwise45 = function() {
    var e2 = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
    return new t2(this.binarizer.createBinarizer(e2));
  }, t2.prototype.toString = function() {
    try {
      return this.getBlackMatrix().toString();
    } catch (t3) {
      return "";
    }
  }, t2;
}();
var b = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var R = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return b(e2, t2), e2.getChecksumInstance = function() {
    return new e2();
  }, e2.kind = "ChecksumException", e2;
}(m);
var N = function() {
  function t2(t3) {
    this.source = t3;
  }
  return t2.prototype.getLuminanceSource = function() {
    return this.source;
  }, t2.prototype.getWidth = function() {
    return this.source.getWidth();
  }, t2.prototype.getHeight = function() {
    return this.source.getHeight();
  }, t2;
}();
var D = function() {
  function t2() {
  }
  return t2.arraycopy = function(t3, e2, r2, n2, o2) {
    for (; o2--; )
      r2[n2++] = t3[e2++];
  }, t2.currentTimeMillis = function() {
    return Date.now();
  }, t2;
}();
var M = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var P = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return M(e2, t2), e2.kind = "IndexOutOfBoundsException", e2;
}(m);
var B = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var L = function(t2) {
  function e2(e3, r2) {
    void 0 === e3 && (e3 = void 0), void 0 === r2 && (r2 = void 0);
    var n2 = t2.call(this, r2) || this;
    return n2.index = e3, n2.message = r2, n2;
  }
  return B(e2, t2), e2.kind = "ArrayIndexOutOfBoundsException", e2;
}(P);
var F = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var k = function() {
  function t2() {
  }
  return t2.fill = function(t3, e2) {
    for (var r2 = 0, n2 = t3.length; r2 < n2; r2++)
      t3[r2] = e2;
  }, t2.fillWithin = function(e2, r2, n2, o2) {
    t2.rangeCheck(e2.length, r2, n2);
    for (var i2 = r2; i2 < n2; i2++)
      e2[i2] = o2;
  }, t2.rangeCheck = function(t3, e2, r2) {
    if (e2 > r2)
      throw new T("fromIndex(" + e2 + ") > toIndex(" + r2 + ")");
    if (e2 < 0)
      throw new L(e2);
    if (r2 > t3)
      throw new L(r2);
  }, t2.asList = function() {
    for (var t3 = [], e2 = 0; e2 < arguments.length; e2++)
      t3[e2] = arguments[e2];
    return t3;
  }, t2.create = function(t3, e2, r2) {
    return Array.from({ length: t3 }).map(function(t4) {
      return Array.from({ length: e2 }).fill(r2);
    });
  }, t2.createInt32Array = function(t3, e2, r2) {
    return Array.from({ length: t3 }).map(function(t4) {
      return Int32Array.from({ length: e2 }).fill(r2);
    });
  }, t2.equals = function(t3, e2) {
    if (!t3)
      return false;
    if (!e2)
      return false;
    if (!t3.length)
      return false;
    if (!e2.length)
      return false;
    if (t3.length !== e2.length)
      return false;
    for (var r2 = 0, n2 = t3.length; r2 < n2; r2++)
      if (t3[r2] !== e2[r2])
        return false;
    return true;
  }, t2.hashCode = function(t3) {
    var e2, r2;
    if (null === t3)
      return 0;
    var n2 = 1;
    try {
      for (var o2 = F(t3), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        n2 = 31 * n2 + i2.value;
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        i2 && !i2.done && (r2 = o2.return) && r2.call(o2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return n2;
  }, t2.fillUint8Array = function(t3, e2) {
    for (var r2 = 0; r2 !== t3.length; r2++)
      t3[r2] = e2;
  }, t2.copyOf = function(t3, e2) {
    return t3.slice(0, e2);
  }, t2.copyOfUint8Array = function(t3, e2) {
    if (t3.length <= e2) {
      var r2 = new Uint8Array(e2);
      return r2.set(t3), r2;
    }
    return t3.slice(0, e2);
  }, t2.copyOfRange = function(t3, e2, r2) {
    var n2 = r2 - e2, o2 = new Int32Array(n2);
    return D.arraycopy(t3, e2, o2, 0, n2), o2;
  }, t2.binarySearch = function(e2, r2, n2) {
    void 0 === n2 && (n2 = t2.numberComparator);
    for (var o2 = 0, i2 = e2.length - 1; o2 <= i2; ) {
      var a2 = i2 + o2 >> 1, s2 = n2(r2, e2[a2]);
      if (s2 > 0)
        o2 = a2 + 1;
      else {
        if (!(s2 < 0))
          return a2;
        i2 = a2 - 1;
      }
    }
    return -o2 - 1;
  }, t2.numberComparator = function(t3, e2) {
    return t3 - e2;
  }, t2;
}();
var x = function() {
  function t2() {
  }
  return t2.numberOfTrailingZeros = function(t3) {
    var e2;
    if (0 === t3)
      return 32;
    var r2 = 31;
    return 0 !== (e2 = t3 << 16) && (r2 -= 16, t3 = e2), 0 !== (e2 = t3 << 8) && (r2 -= 8, t3 = e2), 0 !== (e2 = t3 << 4) && (r2 -= 4, t3 = e2), 0 !== (e2 = t3 << 2) && (r2 -= 2, t3 = e2), r2 - (t3 << 1 >>> 31);
  }, t2.numberOfLeadingZeros = function(t3) {
    if (0 === t3)
      return 32;
    var e2 = 1;
    return t3 >>> 16 == 0 && (e2 += 16, t3 <<= 16), t3 >>> 24 == 0 && (e2 += 8, t3 <<= 8), t3 >>> 28 == 0 && (e2 += 4, t3 <<= 4), t3 >>> 30 == 0 && (e2 += 2, t3 <<= 2), e2 -= t3 >>> 31;
  }, t2.toHexString = function(t3) {
    return t3.toString(16);
  }, t2.toBinaryString = function(t3) {
    return String(parseInt(String(t3), 2));
  }, t2.bitCount = function(t3) {
    return t3 = (t3 = (858993459 & (t3 -= t3 >>> 1 & 1431655765)) + (t3 >>> 2 & 858993459)) + (t3 >>> 4) & 252645135, t3 += t3 >>> 8, 63 & (t3 += t3 >>> 16);
  }, t2.truncDivision = function(t3, e2) {
    return Math.trunc(t3 / e2);
  }, t2.parseInt = function(t3, e2) {
    return void 0 === e2 && (e2 = void 0), parseInt(t3, e2);
  }, t2.MIN_VALUE_32_BITS = -2147483648, t2.MAX_VALUE = Number.MAX_SAFE_INTEGER, t2;
}();
var V = function() {
  function t2(e2, r2) {
    void 0 === e2 ? (this.size = 0, this.bits = new Int32Array(1)) : (this.size = e2, this.bits = null == r2 ? t2.makeArray(e2) : r2);
  }
  return t2.prototype.getSize = function() {
    return this.size;
  }, t2.prototype.getSizeInBytes = function() {
    return Math.floor((this.size + 7) / 8);
  }, t2.prototype.ensureCapacity = function(e2) {
    if (e2 > 32 * this.bits.length) {
      var r2 = t2.makeArray(e2);
      D.arraycopy(this.bits, 0, r2, 0, this.bits.length), this.bits = r2;
    }
  }, t2.prototype.get = function(t3) {
    return 0 != (this.bits[Math.floor(t3 / 32)] & 1 << (31 & t3));
  }, t2.prototype.set = function(t3) {
    this.bits[Math.floor(t3 / 32)] |= 1 << (31 & t3);
  }, t2.prototype.flip = function(t3) {
    this.bits[Math.floor(t3 / 32)] ^= 1 << (31 & t3);
  }, t2.prototype.getNextSet = function(t3) {
    var e2 = this.size;
    if (t3 >= e2)
      return e2;
    var r2 = this.bits, n2 = Math.floor(t3 / 32), o2 = r2[n2];
    o2 &= ~((1 << (31 & t3)) - 1);
    for (var i2 = r2.length; 0 === o2; ) {
      if (++n2 === i2)
        return e2;
      o2 = r2[n2];
    }
    var a2 = 32 * n2 + x.numberOfTrailingZeros(o2);
    return a2 > e2 ? e2 : a2;
  }, t2.prototype.getNextUnset = function(t3) {
    var e2 = this.size;
    if (t3 >= e2)
      return e2;
    var r2 = this.bits, n2 = Math.floor(t3 / 32), o2 = ~r2[n2];
    o2 &= ~((1 << (31 & t3)) - 1);
    for (var i2 = r2.length; 0 === o2; ) {
      if (++n2 === i2)
        return e2;
      o2 = ~r2[n2];
    }
    var a2 = 32 * n2 + x.numberOfTrailingZeros(o2);
    return a2 > e2 ? e2 : a2;
  }, t2.prototype.setBulk = function(t3, e2) {
    this.bits[Math.floor(t3 / 32)] = e2;
  }, t2.prototype.setRange = function(t3, e2) {
    if (e2 < t3 || t3 < 0 || e2 > this.size)
      throw new T();
    if (e2 !== t3) {
      e2--;
      for (var r2 = Math.floor(t3 / 32), n2 = Math.floor(e2 / 32), o2 = this.bits, i2 = r2; i2 <= n2; i2++) {
        var a2 = (2 << (i2 < n2 ? 31 : 31 & e2)) - (1 << (i2 > r2 ? 0 : 31 & t3));
        o2[i2] |= a2;
      }
    }
  }, t2.prototype.clear = function() {
    for (var t3 = this.bits.length, e2 = this.bits, r2 = 0; r2 < t3; r2++)
      e2[r2] = 0;
  }, t2.prototype.isRange = function(t3, e2, r2) {
    if (e2 < t3 || t3 < 0 || e2 > this.size)
      throw new T();
    if (e2 === t3)
      return true;
    e2--;
    for (var n2 = Math.floor(t3 / 32), o2 = Math.floor(e2 / 32), i2 = this.bits, a2 = n2; a2 <= o2; a2++) {
      var s2 = (2 << (a2 < o2 ? 31 : 31 & e2)) - (1 << (a2 > n2 ? 0 : 31 & t3)) & 4294967295;
      if ((i2[a2] & s2) !== (r2 ? s2 : 0))
        return false;
    }
    return true;
  }, t2.prototype.appendBit = function(t3) {
    this.ensureCapacity(this.size + 1), t3 && (this.bits[Math.floor(this.size / 32)] |= 1 << (31 & this.size)), this.size++;
  }, t2.prototype.appendBits = function(t3, e2) {
    if (e2 < 0 || e2 > 32)
      throw new T("Num bits must be between 0 and 32");
    this.ensureCapacity(this.size + e2);
    for (var r2 = e2; r2 > 0; r2--)
      this.appendBit(1 == (t3 >> r2 - 1 & 1));
  }, t2.prototype.appendBitArray = function(t3) {
    var e2 = t3.size;
    this.ensureCapacity(this.size + e2);
    for (var r2 = 0; r2 < e2; r2++)
      this.appendBit(t3.get(r2));
  }, t2.prototype.xor = function(t3) {
    if (this.size !== t3.size)
      throw new T("Sizes don't match");
    for (var e2 = this.bits, r2 = 0, n2 = e2.length; r2 < n2; r2++)
      e2[r2] ^= t3.bits[r2];
  }, t2.prototype.toBytes = function(t3, e2, r2, n2) {
    for (var o2 = 0; o2 < n2; o2++) {
      for (var i2 = 0, a2 = 0; a2 < 8; a2++)
        this.get(t3) && (i2 |= 1 << 7 - a2), t3++;
      e2[r2 + o2] = i2;
    }
  }, t2.prototype.getBitArray = function() {
    return this.bits;
  }, t2.prototype.reverse = function() {
    for (var t3 = new Int32Array(this.bits.length), e2 = Math.floor((this.size - 1) / 32), r2 = e2 + 1, n2 = this.bits, o2 = 0; o2 < r2; o2++) {
      var i2 = n2[o2];
      i2 = (i2 = (i2 = (i2 = (i2 = i2 >> 1 & 1431655765 | (1431655765 & i2) << 1) >> 2 & 858993459 | (858993459 & i2) << 2) >> 4 & 252645135 | (252645135 & i2) << 4) >> 8 & 16711935 | (16711935 & i2) << 8) >> 16 & 65535 | (65535 & i2) << 16, t3[e2 - o2] = i2;
    }
    if (this.size !== 32 * r2) {
      var a2 = 32 * r2 - this.size, s2 = t3[0] >>> a2;
      for (o2 = 1; o2 < r2; o2++) {
        var u2 = t3[o2];
        s2 |= u2 << 32 - a2, t3[o2 - 1] = s2, s2 = u2 >>> a2;
      }
      t3[r2 - 1] = s2;
    }
    this.bits = t3;
  }, t2.makeArray = function(t3) {
    return new Int32Array(Math.floor((t3 + 31) / 32));
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.size === r2.size && k.equals(this.bits, r2.bits);
  }, t2.prototype.hashCode = function() {
    return 31 * this.size + k.hashCode(this.bits);
  }, t2.prototype.toString = function() {
    for (var t3 = "", e2 = 0, r2 = this.size; e2 < r2; e2++)
      0 == (7 & e2) && (t3 += " "), t3 += this.get(e2) ? "X" : ".";
    return t3;
  }, t2.prototype.clone = function() {
    return new t2(this.size, this.bits.slice());
  }, t2.prototype.toArray = function() {
    for (var t3 = [], e2 = 0, r2 = this.size; e2 < r2; e2++)
      t3.push(this.get(e2));
    return t3;
  }, t2;
}();
!function(t2) {
  t2[t2.OTHER = 0] = "OTHER", t2[t2.PURE_BARCODE = 1] = "PURE_BARCODE", t2[t2.POSSIBLE_FORMATS = 2] = "POSSIBLE_FORMATS", t2[t2.TRY_HARDER = 3] = "TRY_HARDER", t2[t2.CHARACTER_SET = 4] = "CHARACTER_SET", t2[t2.ALLOWED_LENGTHS = 5] = "ALLOWED_LENGTHS", t2[t2.ASSUME_CODE_39_CHECK_DIGIT = 6] = "ASSUME_CODE_39_CHECK_DIGIT", t2[t2.ASSUME_GS1 = 7] = "ASSUME_GS1", t2[t2.RETURN_CODABAR_START_END = 8] = "RETURN_CODABAR_START_END", t2[t2.NEED_RESULT_POINT_CALLBACK = 9] = "NEED_RESULT_POINT_CALLBACK", t2[t2.ALLOWED_EAN_EXTENSIONS = 10] = "ALLOWED_EAN_EXTENSIONS";
}(v || (v = {}));
var H;
var U = v;
var X = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var G = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return X(e2, t2), e2.getFormatInstance = function() {
    return new e2();
  }, e2.kind = "FormatException", e2;
}(m);
var W = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
!function(t2) {
  t2[t2.Cp437 = 0] = "Cp437", t2[t2.ISO8859_1 = 1] = "ISO8859_1", t2[t2.ISO8859_2 = 2] = "ISO8859_2", t2[t2.ISO8859_3 = 3] = "ISO8859_3", t2[t2.ISO8859_4 = 4] = "ISO8859_4", t2[t2.ISO8859_5 = 5] = "ISO8859_5", t2[t2.ISO8859_6 = 6] = "ISO8859_6", t2[t2.ISO8859_7 = 7] = "ISO8859_7", t2[t2.ISO8859_8 = 8] = "ISO8859_8", t2[t2.ISO8859_9 = 9] = "ISO8859_9", t2[t2.ISO8859_10 = 10] = "ISO8859_10", t2[t2.ISO8859_11 = 11] = "ISO8859_11", t2[t2.ISO8859_13 = 12] = "ISO8859_13", t2[t2.ISO8859_14 = 13] = "ISO8859_14", t2[t2.ISO8859_15 = 14] = "ISO8859_15", t2[t2.ISO8859_16 = 15] = "ISO8859_16", t2[t2.SJIS = 16] = "SJIS", t2[t2.Cp1250 = 17] = "Cp1250", t2[t2.Cp1251 = 18] = "Cp1251", t2[t2.Cp1252 = 19] = "Cp1252", t2[t2.Cp1256 = 20] = "Cp1256", t2[t2.UnicodeBigUnmarked = 21] = "UnicodeBigUnmarked", t2[t2.UTF8 = 22] = "UTF8", t2[t2.ASCII = 23] = "ASCII", t2[t2.Big5 = 24] = "Big5", t2[t2.GB18030 = 25] = "GB18030", t2[t2.EUC_KR = 26] = "EUC_KR";
}(H || (H = {}));
var z;
var j = function() {
  function t2(e2, r2, n2) {
    for (var o2, i2, a2 = [], s2 = 3; s2 < arguments.length; s2++)
      a2[s2 - 3] = arguments[s2];
    this.valueIdentifier = e2, this.name = n2, this.values = "number" == typeof r2 ? Int32Array.from([r2]) : r2, this.otherEncodingNames = a2, t2.VALUE_IDENTIFIER_TO_ECI.set(e2, this), t2.NAME_TO_ECI.set(n2, this);
    for (var u2 = this.values, c2 = 0, f3 = u2.length; c2 !== f3; c2++) {
      var h2 = u2[c2];
      t2.VALUES_TO_ECI.set(h2, this);
    }
    try {
      for (var l2 = W(a2), d2 = l2.next(); !d2.done; d2 = l2.next()) {
        var p2 = d2.value;
        t2.NAME_TO_ECI.set(p2, this);
      }
    } catch (t3) {
      o2 = { error: t3 };
    } finally {
      try {
        d2 && !d2.done && (i2 = l2.return) && i2.call(l2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
  }
  return t2.prototype.getValueIdentifier = function() {
    return this.valueIdentifier;
  }, t2.prototype.getName = function() {
    return this.name;
  }, t2.prototype.getValue = function() {
    return this.values[0];
  }, t2.getCharacterSetECIByValue = function(e2) {
    if (e2 < 0 || e2 >= 900)
      throw new G("incorect value");
    var r2 = t2.VALUES_TO_ECI.get(e2);
    if (void 0 === r2)
      throw new G("incorect value");
    return r2;
  }, t2.getCharacterSetECIByName = function(e2) {
    var r2 = t2.NAME_TO_ECI.get(e2);
    if (void 0 === r2)
      throw new G("incorect value");
    return r2;
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.getName() === r2.getName();
  }, t2.VALUE_IDENTIFIER_TO_ECI = /* @__PURE__ */ new Map(), t2.VALUES_TO_ECI = /* @__PURE__ */ new Map(), t2.NAME_TO_ECI = /* @__PURE__ */ new Map(), t2.Cp437 = new t2(H.Cp437, Int32Array.from([0, 2]), "Cp437"), t2.ISO8859_1 = new t2(H.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1"), t2.ISO8859_2 = new t2(H.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2"), t2.ISO8859_3 = new t2(H.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3"), t2.ISO8859_4 = new t2(H.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4"), t2.ISO8859_5 = new t2(H.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5"), t2.ISO8859_6 = new t2(H.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6"), t2.ISO8859_7 = new t2(H.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7"), t2.ISO8859_8 = new t2(H.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8"), t2.ISO8859_9 = new t2(H.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9"), t2.ISO8859_10 = new t2(H.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10"), t2.ISO8859_11 = new t2(H.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11"), t2.ISO8859_13 = new t2(H.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13"), t2.ISO8859_14 = new t2(H.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14"), t2.ISO8859_15 = new t2(H.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15"), t2.ISO8859_16 = new t2(H.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16"), t2.SJIS = new t2(H.SJIS, 20, "SJIS", "Shift_JIS"), t2.Cp1250 = new t2(H.Cp1250, 21, "Cp1250", "windows-1250"), t2.Cp1251 = new t2(H.Cp1251, 22, "Cp1251", "windows-1251"), t2.Cp1252 = new t2(H.Cp1252, 23, "Cp1252", "windows-1252"), t2.Cp1256 = new t2(H.Cp1256, 24, "Cp1256", "windows-1256"), t2.UnicodeBigUnmarked = new t2(H.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig"), t2.UTF8 = new t2(H.UTF8, 26, "UTF8", "UTF-8"), t2.ASCII = new t2(H.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII"), t2.Big5 = new t2(H.Big5, 28, "Big5"), t2.GB18030 = new t2(H.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK"), t2.EUC_KR = new t2(H.EUC_KR, 30, "EUC_KR", "EUC-KR"), t2;
}();
var Y = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Z = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return Y(e2, t2), e2.kind = "UnsupportedOperationException", e2;
}(m);
var K = function() {
  function t2() {
  }
  return t2.decode = function(t3, e2) {
    var r2 = this.encodingName(e2);
    return this.customDecoder ? this.customDecoder(t3, r2) : "undefined" == typeof TextDecoder || this.shouldDecodeOnFallback(r2) ? this.decodeFallback(t3, r2) : new TextDecoder(r2).decode(t3);
  }, t2.shouldDecodeOnFallback = function(e2) {
    return !t2.isBrowser() && "ISO-8859-1" === e2;
  }, t2.encode = function(t3, e2) {
    var r2 = this.encodingName(e2);
    return this.customEncoder ? this.customEncoder(t3, r2) : "undefined" == typeof TextEncoder ? this.encodeFallback(t3) : new TextEncoder().encode(t3);
  }, t2.isBrowser = function() {
    return "undefined" != typeof window && "[object Window]" === {}.toString.call(window);
  }, t2.encodingName = function(t3) {
    return "string" == typeof t3 ? t3 : t3.getName();
  }, t2.encodingCharacterSet = function(t3) {
    return t3 instanceof j ? t3 : j.getCharacterSetECIByName(t3);
  }, t2.decodeFallback = function(e2, r2) {
    var n2 = this.encodingCharacterSet(r2);
    if (t2.isDecodeFallbackSupported(n2)) {
      for (var o2 = "", i2 = 0, a2 = e2.length; i2 < a2; i2++) {
        var s2 = e2[i2].toString(16);
        s2.length < 2 && (s2 = "0" + s2), o2 += "%" + s2;
      }
      return decodeURIComponent(o2);
    }
    if (n2.equals(j.UnicodeBigUnmarked))
      return String.fromCharCode.apply(null, new Uint16Array(e2.buffer));
    throw new Z("Encoding " + this.encodingName(r2) + " not supported by fallback.");
  }, t2.isDecodeFallbackSupported = function(t3) {
    return t3.equals(j.UTF8) || t3.equals(j.ISO8859_1) || t3.equals(j.ASCII);
  }, t2.encodeFallback = function(t3) {
    for (var e2 = btoa(unescape(encodeURIComponent(t3))).split(""), r2 = [], n2 = 0; n2 < e2.length; n2++)
      r2.push(e2[n2].charCodeAt(0));
    return new Uint8Array(r2);
  }, t2;
}();
var q = function() {
  function t2() {
  }
  return t2.castAsNonUtf8Char = function(t3, e2) {
    void 0 === e2 && (e2 = null);
    var r2 = e2 ? e2.getName() : this.ISO88591;
    return K.decode(new Uint8Array([t3]), r2);
  }, t2.guessEncoding = function(e2, r2) {
    if (null != r2 && void 0 !== r2.get(U.CHARACTER_SET))
      return r2.get(U.CHARACTER_SET).toString();
    for (var n2 = e2.length, o2 = true, i2 = true, a2 = true, s2 = 0, u2 = 0, c2 = 0, f3 = 0, h2 = 0, l2 = 0, d2 = 0, p2 = 0, g2 = 0, y2 = 0, w2 = 0, v2 = e2.length > 3 && 239 === e2[0] && 187 === e2[1] && 191 === e2[2], _2 = 0; _2 < n2 && (o2 || i2 || a2); _2++) {
      var A2 = 255 & e2[_2];
      a2 && (s2 > 0 ? 0 == (128 & A2) ? a2 = false : s2-- : 0 != (128 & A2) && (0 == (64 & A2) ? a2 = false : (s2++, 0 == (32 & A2) ? u2++ : (s2++, 0 == (16 & A2) ? c2++ : (s2++, 0 == (8 & A2) ? f3++ : a2 = false))))), o2 && (A2 > 127 && A2 < 160 ? o2 = false : A2 > 159 && (A2 < 192 || 215 === A2 || 247 === A2) && w2++), i2 && (h2 > 0 ? A2 < 64 || 127 === A2 || A2 > 252 ? i2 = false : h2-- : 128 === A2 || 160 === A2 || A2 > 239 ? i2 = false : A2 > 160 && A2 < 224 ? (l2++, p2 = 0, ++d2 > g2 && (g2 = d2)) : A2 > 127 ? (h2++, d2 = 0, ++p2 > y2 && (y2 = p2)) : (d2 = 0, p2 = 0));
    }
    return a2 && s2 > 0 && (a2 = false), i2 && h2 > 0 && (i2 = false), a2 && (v2 || u2 + c2 + f3 > 0) ? t2.UTF8 : i2 && (t2.ASSUME_SHIFT_JIS || g2 >= 3 || y2 >= 3) ? t2.SHIFT_JIS : o2 && i2 ? 2 === g2 && 2 === l2 || 10 * w2 >= n2 ? t2.SHIFT_JIS : t2.ISO88591 : o2 ? t2.ISO88591 : i2 ? t2.SHIFT_JIS : a2 ? t2.UTF8 : t2.PLATFORM_DEFAULT_ENCODING;
  }, t2.format = function(t3) {
    for (var e2 = [], r2 = 1; r2 < arguments.length; r2++)
      e2[r2 - 1] = arguments[r2];
    var n2 = -1;
    return t3.replace(/%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g, function(t4, r3, o2, i2, a2, s2) {
      if ("%%" === t4)
        return "%";
      if (void 0 !== e2[++n2]) {
        t4 = i2 ? parseInt(i2.substr(1)) : void 0;
        var u2, c2 = a2 ? parseInt(a2.substr(1)) : void 0;
        switch (s2) {
          case "s":
            u2 = e2[n2];
            break;
          case "c":
            u2 = e2[n2][0];
            break;
          case "f":
            u2 = parseFloat(e2[n2]).toFixed(t4);
            break;
          case "p":
            u2 = parseFloat(e2[n2]).toPrecision(t4);
            break;
          case "e":
            u2 = parseFloat(e2[n2]).toExponential(t4);
            break;
          case "x":
            u2 = parseInt(e2[n2]).toString(c2 || 16);
            break;
          case "d":
            u2 = parseFloat(parseInt(e2[n2], c2 || 10).toPrecision(t4)).toFixed(0);
        }
        u2 = "object" == typeof u2 ? JSON.stringify(u2) : (+u2).toString(c2);
        for (var f3 = parseInt(o2), h2 = o2 && o2[0] + "" == "0" ? "0" : " "; u2.length < f3; )
          u2 = void 0 !== r3 ? u2 + h2 : h2 + u2;
        return u2;
      }
    });
  }, t2.getBytes = function(t3, e2) {
    return K.encode(t3, e2);
  }, t2.getCharCode = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), t3.charCodeAt(e2);
  }, t2.getCharAt = function(t3) {
    return String.fromCharCode(t3);
  }, t2.SHIFT_JIS = j.SJIS.getName(), t2.GB2312 = "GB2312", t2.ISO88591 = j.ISO8859_1.getName(), t2.EUC_JP = "EUC_JP", t2.UTF8 = j.UTF8.getName(), t2.PLATFORM_DEFAULT_ENCODING = t2.UTF8, t2.ASSUME_SHIFT_JIS = false, t2;
}();
var Q = function() {
  function t2(t3) {
    void 0 === t3 && (t3 = ""), this.value = t3;
  }
  return t2.prototype.enableDecoding = function(t3) {
    return this.encoding = t3, this;
  }, t2.prototype.append = function(t3) {
    return "string" == typeof t3 ? this.value += t3.toString() : this.encoding ? this.value += q.castAsNonUtf8Char(t3, this.encoding) : this.value += String.fromCharCode(t3), this;
  }, t2.prototype.appendChars = function(t3, e2, r2) {
    for (var n2 = e2; e2 < e2 + r2; n2++)
      this.append(t3[n2]);
    return this;
  }, t2.prototype.length = function() {
    return this.value.length;
  }, t2.prototype.charAt = function(t3) {
    return this.value.charAt(t3);
  }, t2.prototype.deleteCharAt = function(t3) {
    this.value = this.value.substr(0, t3) + this.value.substring(t3 + 1);
  }, t2.prototype.setCharAt = function(t3, e2) {
    this.value = this.value.substr(0, t3) + e2 + this.value.substr(t3 + 1);
  }, t2.prototype.substring = function(t3, e2) {
    return this.value.substring(t3, e2);
  }, t2.prototype.setLengthToZero = function() {
    this.value = "";
  }, t2.prototype.toString = function() {
    return this.value;
  }, t2.prototype.insert = function(t3, e2) {
    this.value = this.value.substring(0, t3) + e2 + this.value.substring(t3);
  }, t2;
}();
var J = function() {
  function t2(t3, e2, r2, n2) {
    if (this.width = t3, this.height = e2, this.rowSize = r2, this.bits = n2, null == e2 && (e2 = t3), this.height = e2, t3 < 1 || e2 < 1)
      throw new T("Both dimensions must be greater than 0");
    null == r2 && (r2 = Math.floor((t3 + 31) / 32)), this.rowSize = r2, null == n2 && (this.bits = new Int32Array(this.rowSize * this.height));
  }
  return t2.parseFromBooleanArray = function(e2) {
    for (var r2 = e2.length, n2 = e2[0].length, o2 = new t2(n2, r2), i2 = 0; i2 < r2; i2++)
      for (var a2 = e2[i2], s2 = 0; s2 < n2; s2++)
        a2[s2] && o2.set(s2, i2);
    return o2;
  }, t2.parseFromString = function(e2, r2, n2) {
    if (null === e2)
      throw new T("stringRepresentation cannot be null");
    for (var o2 = new Array(e2.length), i2 = 0, a2 = 0, s2 = -1, u2 = 0, c2 = 0; c2 < e2.length; )
      if ("\n" === e2.charAt(c2) || "\r" === e2.charAt(c2)) {
        if (i2 > a2) {
          if (-1 === s2)
            s2 = i2 - a2;
          else if (i2 - a2 !== s2)
            throw new T("row lengths do not match");
          a2 = i2, u2++;
        }
        c2++;
      } else if (e2.substring(c2, c2 + r2.length) === r2)
        c2 += r2.length, o2[i2] = true, i2++;
      else {
        if (e2.substring(c2, c2 + n2.length) !== n2)
          throw new T("illegal character encountered: " + e2.substring(c2));
        c2 += n2.length, o2[i2] = false, i2++;
      }
    if (i2 > a2) {
      if (-1 === s2)
        s2 = i2 - a2;
      else if (i2 - a2 !== s2)
        throw new T("row lengths do not match");
      u2++;
    }
    for (var f3 = new t2(s2, u2), h2 = 0; h2 < i2; h2++)
      o2[h2] && f3.set(Math.floor(h2 % s2), Math.floor(h2 / s2));
    return f3;
  }, t2.prototype.get = function(t3, e2) {
    var r2 = e2 * this.rowSize + Math.floor(t3 / 32);
    return 0 != (this.bits[r2] >>> (31 & t3) & 1);
  }, t2.prototype.set = function(t3, e2) {
    var r2 = e2 * this.rowSize + Math.floor(t3 / 32);
    this.bits[r2] |= 1 << (31 & t3) & 4294967295;
  }, t2.prototype.unset = function(t3, e2) {
    var r2 = e2 * this.rowSize + Math.floor(t3 / 32);
    this.bits[r2] &= ~(1 << (31 & t3) & 4294967295);
  }, t2.prototype.flip = function(t3, e2) {
    var r2 = e2 * this.rowSize + Math.floor(t3 / 32);
    this.bits[r2] ^= 1 << (31 & t3) & 4294967295;
  }, t2.prototype.xor = function(t3) {
    if (this.width !== t3.getWidth() || this.height !== t3.getHeight() || this.rowSize !== t3.getRowSize())
      throw new T("input matrix dimensions do not match");
    for (var e2 = new V(Math.floor(this.width / 32) + 1), r2 = this.rowSize, n2 = this.bits, o2 = 0, i2 = this.height; o2 < i2; o2++)
      for (var a2 = o2 * r2, s2 = t3.getRow(o2, e2).getBitArray(), u2 = 0; u2 < r2; u2++)
        n2[a2 + u2] ^= s2[u2];
  }, t2.prototype.clear = function() {
    for (var t3 = this.bits, e2 = t3.length, r2 = 0; r2 < e2; r2++)
      t3[r2] = 0;
  }, t2.prototype.setRegion = function(t3, e2, r2, n2) {
    if (e2 < 0 || t3 < 0)
      throw new T("Left and top must be nonnegative");
    if (n2 < 1 || r2 < 1)
      throw new T("Height and width must be at least 1");
    var o2 = t3 + r2, i2 = e2 + n2;
    if (i2 > this.height || o2 > this.width)
      throw new T("The region must fit inside the matrix");
    for (var a2 = this.rowSize, s2 = this.bits, u2 = e2; u2 < i2; u2++)
      for (var c2 = u2 * a2, f3 = t3; f3 < o2; f3++)
        s2[c2 + Math.floor(f3 / 32)] |= 1 << (31 & f3) & 4294967295;
  }, t2.prototype.getRow = function(t3, e2) {
    null == e2 || e2.getSize() < this.width ? e2 = new V(this.width) : e2.clear();
    for (var r2 = this.rowSize, n2 = this.bits, o2 = t3 * r2, i2 = 0; i2 < r2; i2++)
      e2.setBulk(32 * i2, n2[o2 + i2]);
    return e2;
  }, t2.prototype.setRow = function(t3, e2) {
    D.arraycopy(e2.getBitArray(), 0, this.bits, t3 * this.rowSize, this.rowSize);
  }, t2.prototype.rotate180 = function() {
    for (var t3 = this.getWidth(), e2 = this.getHeight(), r2 = new V(t3), n2 = new V(t3), o2 = 0, i2 = Math.floor((e2 + 1) / 2); o2 < i2; o2++)
      r2 = this.getRow(o2, r2), n2 = this.getRow(e2 - 1 - o2, n2), r2.reverse(), n2.reverse(), this.setRow(o2, n2), this.setRow(e2 - 1 - o2, r2);
  }, t2.prototype.getEnclosingRectangle = function() {
    for (var t3 = this.width, e2 = this.height, r2 = this.rowSize, n2 = this.bits, o2 = t3, i2 = e2, a2 = -1, s2 = -1, u2 = 0; u2 < e2; u2++)
      for (var c2 = 0; c2 < r2; c2++) {
        var f3 = n2[u2 * r2 + c2];
        if (0 !== f3) {
          if (u2 < i2 && (i2 = u2), u2 > s2 && (s2 = u2), 32 * c2 < o2) {
            for (var h2 = 0; 0 == (f3 << 31 - h2 & 4294967295); )
              h2++;
            32 * c2 + h2 < o2 && (o2 = 32 * c2 + h2);
          }
          if (32 * c2 + 31 > a2) {
            for (h2 = 31; f3 >>> h2 == 0; )
              h2--;
            32 * c2 + h2 > a2 && (a2 = 32 * c2 + h2);
          }
        }
      }
    return a2 < o2 || s2 < i2 ? null : Int32Array.from([o2, i2, a2 - o2 + 1, s2 - i2 + 1]);
  }, t2.prototype.getTopLeftOnBit = function() {
    for (var t3 = this.rowSize, e2 = this.bits, r2 = 0; r2 < e2.length && 0 === e2[r2]; )
      r2++;
    if (r2 === e2.length)
      return null;
    for (var n2 = r2 / t3, o2 = r2 % t3 * 32, i2 = e2[r2], a2 = 0; 0 == (i2 << 31 - a2 & 4294967295); )
      a2++;
    return o2 += a2, Int32Array.from([o2, n2]);
  }, t2.prototype.getBottomRightOnBit = function() {
    for (var t3 = this.rowSize, e2 = this.bits, r2 = e2.length - 1; r2 >= 0 && 0 === e2[r2]; )
      r2--;
    if (r2 < 0)
      return null;
    for (var n2 = Math.floor(r2 / t3), o2 = 32 * Math.floor(r2 % t3), i2 = e2[r2], a2 = 31; i2 >>> a2 == 0; )
      a2--;
    return o2 += a2, Int32Array.from([o2, n2]);
  }, t2.prototype.getWidth = function() {
    return this.width;
  }, t2.prototype.getHeight = function() {
    return this.height;
  }, t2.prototype.getRowSize = function() {
    return this.rowSize;
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.width === r2.width && this.height === r2.height && this.rowSize === r2.rowSize && k.equals(this.bits, r2.bits);
  }, t2.prototype.hashCode = function() {
    var t3 = this.width;
    return t3 = 31 * (t3 = 31 * (t3 = 31 * (t3 = 31 * t3 + this.width) + this.height) + this.rowSize) + k.hashCode(this.bits);
  }, t2.prototype.toString = function(t3, e2, r2) {
    return void 0 === t3 && (t3 = "X "), void 0 === e2 && (e2 = "  "), void 0 === r2 && (r2 = "\n"), this.buildToString(t3, e2, r2);
  }, t2.prototype.buildToString = function(t3, e2, r2) {
    for (var n2 = new Q(), o2 = 0, i2 = this.height; o2 < i2; o2++) {
      for (var a2 = 0, s2 = this.width; a2 < s2; a2++)
        n2.append(this.get(a2, o2) ? t3 : e2);
      n2.append(r2);
    }
    return n2.toString();
  }, t2.prototype.clone = function() {
    return new t2(this.width, this.height, this.rowSize, this.bits.slice());
  }, t2;
}();
var $ = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var tt = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return $(e2, t2), e2.getNotFoundInstance = function() {
    return new e2();
  }, e2.kind = "NotFoundException", e2;
}(m);
var et = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var rt = function(t2) {
  function e2(r2) {
    var n2 = t2.call(this, r2) || this;
    return n2.luminances = e2.EMPTY, n2.buckets = new Int32Array(e2.LUMINANCE_BUCKETS), n2;
  }
  return et(e2, t2), e2.prototype.getBlackRow = function(t3, r2) {
    var n2 = this.getLuminanceSource(), o2 = n2.getWidth();
    null == r2 || r2.getSize() < o2 ? r2 = new V(o2) : r2.clear(), this.initArrays(o2);
    for (var i2 = n2.getRow(t3, this.luminances), a2 = this.buckets, s2 = 0; s2 < o2; s2++)
      a2[(255 & i2[s2]) >> e2.LUMINANCE_SHIFT]++;
    var u2 = e2.estimateBlackPoint(a2);
    if (o2 < 3)
      for (s2 = 0; s2 < o2; s2++)
        (255 & i2[s2]) < u2 && r2.set(s2);
    else {
      var c2 = 255 & i2[0], f3 = 255 & i2[1];
      for (s2 = 1; s2 < o2 - 1; s2++) {
        var h2 = 255 & i2[s2 + 1];
        (4 * f3 - c2 - h2) / 2 < u2 && r2.set(s2), c2 = f3, f3 = h2;
      }
    }
    return r2;
  }, e2.prototype.getBlackMatrix = function() {
    var t3 = this.getLuminanceSource(), r2 = t3.getWidth(), n2 = t3.getHeight(), o2 = new J(r2, n2);
    this.initArrays(r2);
    for (var i2 = this.buckets, a2 = 1; a2 < 5; a2++)
      for (var s2 = Math.floor(n2 * a2 / 5), u2 = t3.getRow(s2, this.luminances), c2 = Math.floor(4 * r2 / 5), f3 = Math.floor(r2 / 5); f3 < c2; f3++) {
        i2[(255 & u2[f3]) >> e2.LUMINANCE_SHIFT]++;
      }
    var h2 = e2.estimateBlackPoint(i2), l2 = t3.getMatrix();
    for (a2 = 0; a2 < n2; a2++) {
      var d2 = a2 * r2;
      for (f3 = 0; f3 < r2; f3++) {
        (255 & l2[d2 + f3]) < h2 && o2.set(f3, a2);
      }
    }
    return o2;
  }, e2.prototype.createBinarizer = function(t3) {
    return new e2(t3);
  }, e2.prototype.initArrays = function(t3) {
    this.luminances.length < t3 && (this.luminances = new Uint8ClampedArray(t3));
    for (var r2 = this.buckets, n2 = 0; n2 < e2.LUMINANCE_BUCKETS; n2++)
      r2[n2] = 0;
  }, e2.estimateBlackPoint = function(t3) {
    for (var r2 = t3.length, n2 = 0, o2 = 0, i2 = 0, a2 = 0; a2 < r2; a2++)
      t3[a2] > i2 && (o2 = a2, i2 = t3[a2]), t3[a2] > n2 && (n2 = t3[a2]);
    var s2 = 0, u2 = 0;
    for (a2 = 0; a2 < r2; a2++) {
      var c2 = a2 - o2;
      (d2 = t3[a2] * c2 * c2) > u2 && (s2 = a2, u2 = d2);
    }
    if (o2 > s2) {
      var f3 = o2;
      o2 = s2, s2 = f3;
    }
    if (s2 - o2 <= r2 / 16)
      throw new tt();
    var h2 = s2 - 1, l2 = -1;
    for (a2 = s2 - 1; a2 > o2; a2--) {
      var d2, p2 = a2 - o2;
      (d2 = p2 * p2 * (s2 - a2) * (n2 - t3[a2])) > l2 && (h2 = a2, l2 = d2);
    }
    return h2 << e2.LUMINANCE_SHIFT;
  }, e2.LUMINANCE_BITS = 5, e2.LUMINANCE_SHIFT = 8 - e2.LUMINANCE_BITS, e2.LUMINANCE_BUCKETS = 1 << e2.LUMINANCE_BITS, e2.EMPTY = Uint8ClampedArray.from([0]), e2;
}(N);
var nt = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ot = function(t2) {
  function e2(e3) {
    var r2 = t2.call(this, e3) || this;
    return r2.matrix = null, r2;
  }
  return nt(e2, t2), e2.prototype.getBlackMatrix = function() {
    if (null !== this.matrix)
      return this.matrix;
    var r2 = this.getLuminanceSource(), n2 = r2.getWidth(), o2 = r2.getHeight();
    if (n2 >= e2.MINIMUM_DIMENSION && o2 >= e2.MINIMUM_DIMENSION) {
      var i2 = r2.getMatrix(), a2 = n2 >> e2.BLOCK_SIZE_POWER;
      0 != (n2 & e2.BLOCK_SIZE_MASK) && a2++;
      var s2 = o2 >> e2.BLOCK_SIZE_POWER;
      0 != (o2 & e2.BLOCK_SIZE_MASK) && s2++;
      var u2 = e2.calculateBlackPoints(i2, a2, s2, n2, o2), c2 = new J(n2, o2);
      e2.calculateThresholdForBlock(i2, a2, s2, n2, o2, u2, c2), this.matrix = c2;
    } else
      this.matrix = t2.prototype.getBlackMatrix.call(this);
    return this.matrix;
  }, e2.prototype.createBinarizer = function(t3) {
    return new e2(t3);
  }, e2.calculateThresholdForBlock = function(t3, r2, n2, o2, i2, a2, s2) {
    for (var u2 = i2 - e2.BLOCK_SIZE, c2 = o2 - e2.BLOCK_SIZE, f3 = 0; f3 < n2; f3++) {
      var h2 = f3 << e2.BLOCK_SIZE_POWER;
      h2 > u2 && (h2 = u2);
      for (var l2 = e2.cap(f3, 2, n2 - 3), d2 = 0; d2 < r2; d2++) {
        var p2 = d2 << e2.BLOCK_SIZE_POWER;
        p2 > c2 && (p2 = c2);
        for (var g2 = e2.cap(d2, 2, r2 - 3), y2 = 0, w2 = -2; w2 <= 2; w2++) {
          var v2 = a2[l2 + w2];
          y2 += v2[g2 - 2] + v2[g2 - 1] + v2[g2] + v2[g2 + 1] + v2[g2 + 2];
        }
        var _2 = y2 / 25;
        e2.thresholdBlock(t3, p2, h2, _2, o2, s2);
      }
    }
  }, e2.cap = function(t3, e3, r2) {
    return t3 < e3 ? e3 : t3 > r2 ? r2 : t3;
  }, e2.thresholdBlock = function(t3, r2, n2, o2, i2, a2) {
    for (var s2 = 0, u2 = n2 * i2 + r2; s2 < e2.BLOCK_SIZE; s2++, u2 += i2)
      for (var c2 = 0; c2 < e2.BLOCK_SIZE; c2++)
        (255 & t3[u2 + c2]) <= o2 && a2.set(r2 + c2, n2 + s2);
  }, e2.calculateBlackPoints = function(t3, r2, n2, o2, i2) {
    for (var a2 = i2 - e2.BLOCK_SIZE, s2 = o2 - e2.BLOCK_SIZE, u2 = new Array(n2), c2 = 0; c2 < n2; c2++) {
      u2[c2] = new Int32Array(r2);
      var f3 = c2 << e2.BLOCK_SIZE_POWER;
      f3 > a2 && (f3 = a2);
      for (var h2 = 0; h2 < r2; h2++) {
        var l2 = h2 << e2.BLOCK_SIZE_POWER;
        l2 > s2 && (l2 = s2);
        for (var d2 = 0, p2 = 255, g2 = 0, y2 = 0, w2 = f3 * o2 + l2; y2 < e2.BLOCK_SIZE; y2++, w2 += o2) {
          for (var v2 = 0; v2 < e2.BLOCK_SIZE; v2++) {
            var _2 = 255 & t3[w2 + v2];
            d2 += _2, _2 < p2 && (p2 = _2), _2 > g2 && (g2 = _2);
          }
          if (g2 - p2 > e2.MIN_DYNAMIC_RANGE)
            for (y2++, w2 += o2; y2 < e2.BLOCK_SIZE; y2++, w2 += o2)
              for (v2 = 0; v2 < e2.BLOCK_SIZE; v2++)
                d2 += 255 & t3[w2 + v2];
        }
        var A2 = d2 >> 2 * e2.BLOCK_SIZE_POWER;
        if (g2 - p2 <= e2.MIN_DYNAMIC_RANGE && (A2 = p2 / 2, c2 > 0 && h2 > 0)) {
          var C2 = (u2[c2 - 1][h2] + 2 * u2[c2][h2 - 1] + u2[c2 - 1][h2 - 1]) / 4;
          p2 < C2 && (A2 = C2);
        }
        u2[c2][h2] = A2;
      }
    }
    return u2;
  }, e2.BLOCK_SIZE_POWER = 3, e2.BLOCK_SIZE = 1 << e2.BLOCK_SIZE_POWER, e2.BLOCK_SIZE_MASK = e2.BLOCK_SIZE - 1, e2.MINIMUM_DIMENSION = 5 * e2.BLOCK_SIZE, e2.MIN_DYNAMIC_RANGE = 24, e2;
}(rt);
var it = function() {
  function t2(t3, e2) {
    this.width = t3, this.height = e2;
  }
  return t2.prototype.getWidth = function() {
    return this.width;
  }, t2.prototype.getHeight = function() {
    return this.height;
  }, t2.prototype.isCropSupported = function() {
    return false;
  }, t2.prototype.crop = function(t3, e2, r2, n2) {
    throw new Z("This luminance source does not support cropping.");
  }, t2.prototype.isRotateSupported = function() {
    return false;
  }, t2.prototype.rotateCounterClockwise = function() {
    throw new Z("This luminance source does not support rotation by 90 degrees.");
  }, t2.prototype.rotateCounterClockwise45 = function() {
    throw new Z("This luminance source does not support rotation by 45 degrees.");
  }, t2.prototype.toString = function() {
    for (var t3 = new Uint8ClampedArray(this.width), e2 = new Q(), r2 = 0; r2 < this.height; r2++) {
      for (var n2 = this.getRow(r2, t3), o2 = 0; o2 < this.width; o2++) {
        var i2 = 255 & n2[o2], a2 = void 0;
        a2 = i2 < 64 ? "#" : i2 < 128 ? "+" : i2 < 192 ? "." : " ", e2.append(a2);
      }
      e2.append("\n");
    }
    return e2.toString();
  }, t2;
}();
var at = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var st = function(t2) {
  function e2(e3) {
    var r2 = t2.call(this, e3.getWidth(), e3.getHeight()) || this;
    return r2.delegate = e3, r2;
  }
  return at(e2, t2), e2.prototype.getRow = function(t3, e3) {
    for (var r2 = this.delegate.getRow(t3, e3), n2 = this.getWidth(), o2 = 0; o2 < n2; o2++)
      r2[o2] = 255 - (255 & r2[o2]);
    return r2;
  }, e2.prototype.getMatrix = function() {
    for (var t3 = this.delegate.getMatrix(), e3 = this.getWidth() * this.getHeight(), r2 = new Uint8ClampedArray(e3), n2 = 0; n2 < e3; n2++)
      r2[n2] = 255 - (255 & t3[n2]);
    return r2;
  }, e2.prototype.isCropSupported = function() {
    return this.delegate.isCropSupported();
  }, e2.prototype.crop = function(t3, r2, n2, o2) {
    return new e2(this.delegate.crop(t3, r2, n2, o2));
  }, e2.prototype.isRotateSupported = function() {
    return this.delegate.isRotateSupported();
  }, e2.prototype.invert = function() {
    return this.delegate;
  }, e2.prototype.rotateCounterClockwise = function() {
    return new e2(this.delegate.rotateCounterClockwise());
  }, e2.prototype.rotateCounterClockwise45 = function() {
    return new e2(this.delegate.rotateCounterClockwise45());
  }, e2;
}(it);
var ut = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ct = function(t2) {
  function e2(r2) {
    var n2 = t2.call(this, r2.width, r2.height) || this;
    return n2.canvas = r2, n2.tempCanvasElement = null, n2.buffer = e2.makeBufferFromCanvasImageData(r2), n2;
  }
  return ut(e2, t2), e2.makeBufferFromCanvasImageData = function(t3) {
    var r2 = t3.getContext("2d").getImageData(0, 0, t3.width, t3.height);
    return e2.toGrayscaleBuffer(r2.data, t3.width, t3.height);
  }, e2.toGrayscaleBuffer = function(t3, r2, n2) {
    var o2 = new Uint8ClampedArray(r2 * n2);
    if (e2.FRAME_INDEX = !e2.FRAME_INDEX, e2.FRAME_INDEX)
      for (var i2 = 0, a2 = 0, s2 = t3.length; i2 < s2; i2 += 4, a2++) {
        var u2 = void 0;
        if (0 === t3[i2 + 3])
          u2 = 255;
        else
          u2 = 306 * t3[i2] + 601 * t3[i2 + 1] + 117 * t3[i2 + 2] + 512 >> 10;
        o2[a2] = u2;
      }
    else {
      i2 = 0, a2 = 0;
      for (var c2 = t3.length; i2 < c2; i2 += 4, a2++) {
        u2 = void 0;
        if (0 === t3[i2 + 3])
          u2 = 255;
        else
          u2 = 306 * t3[i2] + 601 * t3[i2 + 1] + 117 * t3[i2 + 2] + 512 >> 10;
        o2[a2] = 255 - u2;
      }
    }
    return o2;
  }, e2.prototype.getRow = function(t3, e3) {
    if (t3 < 0 || t3 >= this.getHeight())
      throw new T("Requested row is outside the image: " + t3);
    var r2 = this.getWidth(), n2 = t3 * r2;
    return null === e3 ? e3 = this.buffer.slice(n2, n2 + r2) : (e3.length < r2 && (e3 = new Uint8ClampedArray(r2)), e3.set(this.buffer.slice(n2, n2 + r2))), e3;
  }, e2.prototype.getMatrix = function() {
    return this.buffer;
  }, e2.prototype.isCropSupported = function() {
    return true;
  }, e2.prototype.crop = function(e3, r2, n2, o2) {
    return t2.prototype.crop.call(this, e3, r2, n2, o2), this;
  }, e2.prototype.isRotateSupported = function() {
    return true;
  }, e2.prototype.rotateCounterClockwise = function() {
    return this.rotate(-90), this;
  }, e2.prototype.rotateCounterClockwise45 = function() {
    return this.rotate(-45), this;
  }, e2.prototype.getTempCanvasElement = function() {
    if (null === this.tempCanvasElement) {
      var t3 = this.canvas.ownerDocument.createElement("canvas");
      t3.width = this.canvas.width, t3.height = this.canvas.height, this.tempCanvasElement = t3;
    }
    return this.tempCanvasElement;
  }, e2.prototype.rotate = function(t3) {
    var r2 = this.getTempCanvasElement(), n2 = r2.getContext("2d"), o2 = t3 * e2.DEGREE_TO_RADIANS, i2 = this.canvas.width, a2 = this.canvas.height, s2 = Math.ceil(Math.abs(Math.cos(o2)) * i2 + Math.abs(Math.sin(o2)) * a2), u2 = Math.ceil(Math.abs(Math.sin(o2)) * i2 + Math.abs(Math.cos(o2)) * a2);
    return r2.width = s2, r2.height = u2, n2.translate(s2 / 2, u2 / 2), n2.rotate(o2), n2.drawImage(this.canvas, i2 / -2, a2 / -2), this.buffer = e2.makeBufferFromCanvasImageData(r2), this;
  }, e2.prototype.invert = function() {
    return new st(this);
  }, e2.DEGREE_TO_RADIANS = Math.PI / 180, e2.FRAME_INDEX = true, e2;
}(it);
var ft = function() {
  function t2(t3, e2, r2) {
    this.deviceId = t3, this.label = e2, this.kind = "videoinput", this.groupId = r2 || void 0;
  }
  return t2.prototype.toJSON = function() {
    return { kind: this.kind, groupId: this.groupId, deviceId: this.deviceId, label: this.label };
  }, t2;
}();
var ht = function(t2, e2, r2, n2) {
  return new (r2 || (r2 = Promise))(function(o2, i2) {
    function a2(t3) {
      try {
        u2(n2.next(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function s2(t3) {
      try {
        u2(n2.throw(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function u2(t3) {
      var e3;
      t3.done ? o2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
        t4(e3);
      })).then(a2, s2);
    }
    u2((n2 = n2.apply(t2, e2 || [])).next());
  });
};
var lt = function(t2, e2) {
  var r2, n2, o2, i2, a2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function s2(i3) {
    return function(s3) {
      return function(i4) {
        if (r2)
          throw new TypeError("Generator is already executing.");
        for (; a2; )
          try {
            if (r2 = 1, n2 && (o2 = 2 & i4[0] ? n2.return : i4[0] ? n2.throw || ((o2 = n2.return) && o2.call(n2), 0) : n2.next) && !(o2 = o2.call(n2, i4[1])).done)
              return o2;
            switch (n2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
              case 0:
              case 1:
                o2 = i4;
                break;
              case 4:
                return a2.label++, { value: i4[1], done: false };
              case 5:
                a2.label++, n2 = i4[1], i4 = [0];
                continue;
              case 7:
                i4 = a2.ops.pop(), a2.trys.pop();
                continue;
              default:
                if (!(o2 = a2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                  a2 = 0;
                  continue;
                }
                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                  a2.label = i4[1];
                  break;
                }
                if (6 === i4[0] && a2.label < o2[1]) {
                  a2.label = o2[1], o2 = i4;
                  break;
                }
                if (o2 && a2.label < o2[2]) {
                  a2.label = o2[2], a2.ops.push(i4);
                  break;
                }
                o2[2] && a2.ops.pop(), a2.trys.pop();
                continue;
            }
            i4 = e2.call(t2, a2);
          } catch (t3) {
            i4 = [6, t3], n2 = 0;
          } finally {
            r2 = o2 = 0;
          }
        if (5 & i4[0])
          throw i4[1];
        return { value: i4[0] ? i4[1] : void 0, done: true };
      }([i3, s3]);
    };
  }
};
var dt = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var pt = function() {
  function t2(t3, e2, r2) {
    void 0 === e2 && (e2 = 500), this.reader = t3, this.timeBetweenScansMillis = e2, this._hints = r2, this._stopContinuousDecode = false, this._stopAsyncDecode = false, this._timeBetweenDecodingAttempts = 0;
  }
  return Object.defineProperty(t2.prototype, "hasNavigator", { get: function() {
    return "undefined" != typeof navigator;
  }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isMediaDevicesSuported", { get: function() {
    return this.hasNavigator && !!navigator.mediaDevices;
  }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "canEnumerateDevices", { get: function() {
    return !(!this.isMediaDevicesSuported || !navigator.mediaDevices.enumerateDevices);
  }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "timeBetweenDecodingAttempts", { get: function() {
    return this._timeBetweenDecodingAttempts;
  }, set: function(t3) {
    this._timeBetweenDecodingAttempts = t3 < 0 ? 0 : t3;
  }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "hints", { get: function() {
    return this._hints;
  }, set: function(t3) {
    this._hints = t3 || null;
  }, enumerable: false, configurable: true }), t2.prototype.listVideoInputDevices = function() {
    return ht(this, void 0, void 0, function() {
      var t3, e2, r2, n2, o2, i2, a2, s2, u2, c2, f3, h2;
      return lt(this, function(l2) {
        switch (l2.label) {
          case 0:
            if (!this.hasNavigator)
              throw new Error("Can't enumerate devices, navigator is not present.");
            if (!this.canEnumerateDevices)
              throw new Error("Can't enumerate devices, method not supported.");
            return [4, navigator.mediaDevices.enumerateDevices()];
          case 1:
            t3 = l2.sent(), e2 = [];
            try {
              for (r2 = dt(t3), n2 = r2.next(); !n2.done; n2 = r2.next())
                o2 = n2.value, "videoinput" === (i2 = "video" === o2.kind ? "videoinput" : o2.kind) && (a2 = o2.deviceId || o2.id, s2 = o2.label || "Video device " + (e2.length + 1), u2 = o2.groupId, c2 = { deviceId: a2, label: s2, kind: i2, groupId: u2 }, e2.push(c2));
            } catch (t4) {
              f3 = { error: t4 };
            } finally {
              try {
                n2 && !n2.done && (h2 = r2.return) && h2.call(r2);
              } finally {
                if (f3)
                  throw f3.error;
              }
            }
            return [2, e2];
        }
      });
    });
  }, t2.prototype.getVideoInputDevices = function() {
    return ht(this, void 0, void 0, function() {
      return lt(this, function(t3) {
        switch (t3.label) {
          case 0:
            return [4, this.listVideoInputDevices()];
          case 1:
            return [2, t3.sent().map(function(t4) {
              return new ft(t4.deviceId, t4.label);
            })];
        }
      });
    });
  }, t2.prototype.findDeviceById = function(t3) {
    return ht(this, void 0, void 0, function() {
      var e2;
      return lt(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.listVideoInputDevices()];
          case 1:
            return (e2 = r2.sent()) ? [2, e2.find(function(e3) {
              return e3.deviceId === t3;
            })] : [2, null];
        }
      });
    });
  }, t2.prototype.decodeFromInputVideoDevice = function(t3, e2) {
    return ht(this, void 0, void 0, function() {
      return lt(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.decodeOnceFromVideoDevice(t3, e2)];
          case 1:
            return [2, r2.sent()];
        }
      });
    });
  }, t2.prototype.decodeOnceFromVideoDevice = function(t3, e2) {
    return ht(this, void 0, void 0, function() {
      var r2;
      return lt(this, function(n2) {
        switch (n2.label) {
          case 0:
            return this.reset(), r2 = { video: t3 ? { deviceId: { exact: t3 } } : { facingMode: "environment" } }, [4, this.decodeOnceFromConstraints(r2, e2)];
          case 1:
            return [2, n2.sent()];
        }
      });
    });
  }, t2.prototype.decodeOnceFromConstraints = function(t3, e2) {
    return ht(this, void 0, void 0, function() {
      var r2;
      return lt(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, navigator.mediaDevices.getUserMedia(t3)];
          case 1:
            return r2 = n2.sent(), [4, this.decodeOnceFromStream(r2, e2)];
          case 2:
            return [2, n2.sent()];
        }
      });
    });
  }, t2.prototype.decodeOnceFromStream = function(t3, e2) {
    return ht(this, void 0, void 0, function() {
      var r2;
      return lt(this, function(n2) {
        switch (n2.label) {
          case 0:
            return this.reset(), [4, this.attachStreamToVideo(t3, e2)];
          case 1:
            return r2 = n2.sent(), [4, this.decodeOnce(r2)];
          case 2:
            return [2, n2.sent()];
        }
      });
    });
  }, t2.prototype.decodeFromInputVideoDeviceContinuously = function(t3, e2, r2) {
    return ht(this, void 0, void 0, function() {
      return lt(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, this.decodeFromVideoDevice(t3, e2, r2)];
          case 1:
            return [2, n2.sent()];
        }
      });
    });
  }, t2.prototype.decodeFromVideoDevice = function(t3, e2, r2) {
    return ht(this, void 0, void 0, function() {
      var n2;
      return lt(this, function(o2) {
        switch (o2.label) {
          case 0:
            return n2 = { video: t3 ? { deviceId: { exact: t3 } } : { facingMode: "environment" } }, [4, this.decodeFromConstraints(n2, e2, r2)];
          case 1:
            return [2, o2.sent()];
        }
      });
    });
  }, t2.prototype.decodeFromConstraints = function(t3, e2, r2) {
    return ht(this, void 0, void 0, function() {
      var n2;
      return lt(this, function(o2) {
        switch (o2.label) {
          case 0:
            return [4, navigator.mediaDevices.getUserMedia(t3)];
          case 1:
            return n2 = o2.sent(), [4, this.decodeFromStream(n2, e2, r2)];
          case 2:
            return [2, o2.sent()];
        }
      });
    });
  }, t2.prototype.decodeFromStream = function(t3, e2, r2) {
    return ht(this, void 0, void 0, function() {
      var n2;
      return lt(this, function(o2) {
        switch (o2.label) {
          case 0:
            return this.reset(), [4, this.attachStreamToVideo(t3, e2)];
          case 1:
            return n2 = o2.sent(), [4, this.decodeContinuously(n2, r2)];
          case 2:
            return [2, o2.sent()];
        }
      });
    });
  }, t2.prototype.stopAsyncDecode = function() {
    this._stopAsyncDecode = true;
  }, t2.prototype.stopContinuousDecode = function() {
    this._stopContinuousDecode = true;
  }, t2.prototype.attachStreamToVideo = function(t3, e2) {
    return ht(this, void 0, void 0, function() {
      var r2;
      return lt(this, function(n2) {
        switch (n2.label) {
          case 0:
            return r2 = this.prepareVideoElement(e2), this.addVideoSource(r2, t3), this.videoElement = r2, this.stream = t3, [4, this.playVideoOnLoadAsync(r2)];
          case 1:
            return n2.sent(), [2, r2];
        }
      });
    });
  }, t2.prototype.playVideoOnLoadAsync = function(t3) {
    var e2 = this;
    return new Promise(function(r2, n2) {
      return e2.playVideoOnLoad(t3, function() {
        return r2();
      });
    });
  }, t2.prototype.playVideoOnLoad = function(t3, e2) {
    var r2 = this;
    this.videoEndedListener = function() {
      return r2.stopStreams();
    }, this.videoCanPlayListener = function() {
      return r2.tryPlayVideo(t3);
    }, t3.addEventListener("ended", this.videoEndedListener), t3.addEventListener("canplay", this.videoCanPlayListener), t3.addEventListener("playing", e2), this.tryPlayVideo(t3);
  }, t2.prototype.isVideoPlaying = function(t3) {
    return t3.currentTime > 0 && !t3.paused && !t3.ended && t3.readyState > 2;
  }, t2.prototype.tryPlayVideo = function(t3) {
    return ht(this, void 0, void 0, function() {
      return lt(this, function(e2) {
        switch (e2.label) {
          case 0:
            if (this.isVideoPlaying(t3))
              return console.warn("Trying to play video that is already playing."), [2];
            e2.label = 1;
          case 1:
            return e2.trys.push([1, 3, , 4]), [4, t3.play()];
          case 2:
            return e2.sent(), [3, 4];
          case 3:
            return e2.sent(), console.warn("It was not possible to play the video."), [3, 4];
          case 4:
            return [2];
        }
      });
    });
  }, t2.prototype.getMediaElement = function(t3, e2) {
    var r2 = document.getElementById(t3);
    if (!r2)
      throw new I("element with id '" + t3 + "' not found");
    if (r2.nodeName.toLowerCase() !== e2.toLowerCase())
      throw new I("element with id '" + t3 + "' must be an " + e2 + " element");
    return r2;
  }, t2.prototype.decodeFromImage = function(t3, e2) {
    if (!t3 && !e2)
      throw new I("either imageElement with a src set or an url must be provided");
    return e2 && !t3 ? this.decodeFromImageUrl(e2) : this.decodeFromImageElement(t3);
  }, t2.prototype.decodeFromVideo = function(t3, e2) {
    if (!t3 && !e2)
      throw new I("Either an element with a src set or an URL must be provided");
    return e2 && !t3 ? this.decodeFromVideoUrl(e2) : this.decodeFromVideoElement(t3);
  }, t2.prototype.decodeFromVideoContinuously = function(t3, e2, r2) {
    if (void 0 === t3 && void 0 === e2)
      throw new I("Either an element with a src set or an URL must be provided");
    return e2 && !t3 ? this.decodeFromVideoUrlContinuously(e2, r2) : this.decodeFromVideoElementContinuously(t3, r2);
  }, t2.prototype.decodeFromImageElement = function(t3) {
    if (!t3)
      throw new I("An image element must be provided.");
    this.reset();
    var e2 = this.prepareImageElement(t3);
    return this.imageElement = e2, this.isImageLoaded(e2) ? this.decodeOnce(e2, false, true) : this._decodeOnLoadImage(e2);
  }, t2.prototype.decodeFromVideoElement = function(t3) {
    var e2 = this._decodeFromVideoElementSetup(t3);
    return this._decodeOnLoadVideo(e2);
  }, t2.prototype.decodeFromVideoElementContinuously = function(t3, e2) {
    var r2 = this._decodeFromVideoElementSetup(t3);
    return this._decodeOnLoadVideoContinuously(r2, e2);
  }, t2.prototype._decodeFromVideoElementSetup = function(t3) {
    if (!t3)
      throw new I("A video element must be provided.");
    this.reset();
    var e2 = this.prepareVideoElement(t3);
    return this.videoElement = e2, e2;
  }, t2.prototype.decodeFromImageUrl = function(t3) {
    if (!t3)
      throw new I("An URL must be provided.");
    this.reset();
    var e2 = this.prepareImageElement();
    this.imageElement = e2;
    var r2 = this._decodeOnLoadImage(e2);
    return e2.src = t3, r2;
  }, t2.prototype.decodeFromVideoUrl = function(t3) {
    if (!t3)
      throw new I("An URL must be provided.");
    this.reset();
    var e2 = this.prepareVideoElement(), r2 = this.decodeFromVideoElement(e2);
    return e2.src = t3, r2;
  }, t2.prototype.decodeFromVideoUrlContinuously = function(t3, e2) {
    if (!t3)
      throw new I("An URL must be provided.");
    this.reset();
    var r2 = this.prepareVideoElement(), n2 = this.decodeFromVideoElementContinuously(r2, e2);
    return r2.src = t3, n2;
  }, t2.prototype._decodeOnLoadImage = function(t3) {
    var e2 = this;
    return new Promise(function(r2, n2) {
      e2.imageLoadedListener = function() {
        return e2.decodeOnce(t3, false, true).then(r2, n2);
      }, t3.addEventListener("load", e2.imageLoadedListener);
    });
  }, t2.prototype._decodeOnLoadVideo = function(t3) {
    return ht(this, void 0, void 0, function() {
      return lt(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.playVideoOnLoadAsync(t3)];
          case 1:
            return e2.sent(), [4, this.decodeOnce(t3)];
          case 2:
            return [2, e2.sent()];
        }
      });
    });
  }, t2.prototype._decodeOnLoadVideoContinuously = function(t3, e2) {
    return ht(this, void 0, void 0, function() {
      return lt(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.playVideoOnLoadAsync(t3)];
          case 1:
            return r2.sent(), this.decodeContinuously(t3, e2), [2];
        }
      });
    });
  }, t2.prototype.isImageLoaded = function(t3) {
    return !!t3.complete && 0 !== t3.naturalWidth;
  }, t2.prototype.prepareImageElement = function(t3) {
    var e2;
    return void 0 === t3 && ((e2 = document.createElement("img")).width = 200, e2.height = 200), "string" == typeof t3 && (e2 = this.getMediaElement(t3, "img")), t3 instanceof HTMLImageElement && (e2 = t3), e2;
  }, t2.prototype.prepareVideoElement = function(t3) {
    var e2;
    return t3 || "undefined" == typeof document || ((e2 = document.createElement("video")).width = 200, e2.height = 200), "string" == typeof t3 && (e2 = this.getMediaElement(t3, "video")), t3 instanceof HTMLVideoElement && (e2 = t3), e2.setAttribute("autoplay", "true"), e2.setAttribute("muted", "true"), e2.setAttribute("playsinline", "true"), e2;
  }, t2.prototype.decodeOnce = function(t3, e2, r2) {
    var n2 = this;
    void 0 === e2 && (e2 = true), void 0 === r2 && (r2 = true), this._stopAsyncDecode = false;
    var o2 = function(i2, a2) {
      if (n2._stopAsyncDecode)
        return a2(new tt("Video stream has ended before any code could be detected.")), void (n2._stopAsyncDecode = void 0);
      try {
        i2(n2.decode(t3));
      } catch (t4) {
        if (e2 && t4 instanceof tt || (t4 instanceof R || t4 instanceof G) && r2)
          return setTimeout(o2, n2._timeBetweenDecodingAttempts, i2, a2);
        a2(t4);
      }
    };
    return new Promise(function(t4, e3) {
      return o2(t4, e3);
    });
  }, t2.prototype.decodeContinuously = function(t3, e2) {
    var r2 = this;
    this._stopContinuousDecode = false;
    var n2 = function() {
      if (r2._stopContinuousDecode)
        r2._stopContinuousDecode = void 0;
      else
        try {
          var o2 = r2.decode(t3);
          e2(o2, null), setTimeout(n2, r2.timeBetweenScansMillis);
        } catch (t4) {
          e2(null, t4), (t4 instanceof R || t4 instanceof G || t4 instanceof tt) && setTimeout(n2, r2._timeBetweenDecodingAttempts);
        }
    };
    n2();
  }, t2.prototype.decode = function(t3) {
    var e2 = this.createBinaryBitmap(t3);
    return this.decodeBitmap(e2);
  }, t2.prototype.createBinaryBitmap = function(t3) {
    this.getCaptureCanvasContext(t3), t3 instanceof HTMLVideoElement ? this.drawFrameOnCanvas(t3) : this.drawImageOnCanvas(t3);
    var e2 = this.getCaptureCanvas(t3), r2 = new ct(e2), n2 = new ot(r2);
    return new O(n2);
  }, t2.prototype.getCaptureCanvasContext = function(t3) {
    if (!this.captureCanvasContext) {
      var e2 = this.getCaptureCanvas(t3), r2 = void 0;
      try {
        r2 = e2.getContext("2d", { willReadFrequently: true });
      } catch (t4) {
        r2 = e2.getContext("2d");
      }
      this.captureCanvasContext = r2;
    }
    return this.captureCanvasContext;
  }, t2.prototype.getCaptureCanvas = function(t3) {
    if (!this.captureCanvas) {
      var e2 = this.createCaptureCanvas(t3);
      this.captureCanvas = e2;
    }
    return this.captureCanvas;
  }, t2.prototype.drawFrameOnCanvas = function(t3, e2, r2) {
    void 0 === e2 && (e2 = { sx: 0, sy: 0, sWidth: t3.videoWidth, sHeight: t3.videoHeight, dx: 0, dy: 0, dWidth: t3.videoWidth, dHeight: t3.videoHeight }), void 0 === r2 && (r2 = this.captureCanvasContext), r2.drawImage(t3, e2.sx, e2.sy, e2.sWidth, e2.sHeight, e2.dx, e2.dy, e2.dWidth, e2.dHeight);
  }, t2.prototype.drawImageOnCanvas = function(t3, e2, r2) {
    void 0 === e2 && (e2 = { sx: 0, sy: 0, sWidth: t3.naturalWidth, sHeight: t3.naturalHeight, dx: 0, dy: 0, dWidth: t3.naturalWidth, dHeight: t3.naturalHeight }), void 0 === r2 && (r2 = this.captureCanvasContext), r2.drawImage(t3, e2.sx, e2.sy, e2.sWidth, e2.sHeight, e2.dx, e2.dy, e2.dWidth, e2.dHeight);
  }, t2.prototype.decodeBitmap = function(t3) {
    return this.reader.decode(t3, this._hints);
  }, t2.prototype.createCaptureCanvas = function(t3) {
    if ("undefined" == typeof document)
      return this._destroyCaptureCanvas(), null;
    var e2, r2, n2 = document.createElement("canvas");
    return void 0 !== t3 && (t3 instanceof HTMLVideoElement ? (e2 = t3.videoWidth, r2 = t3.videoHeight) : t3 instanceof HTMLImageElement && (e2 = t3.naturalWidth || t3.width, r2 = t3.naturalHeight || t3.height)), n2.style.width = e2 + "px", n2.style.height = r2 + "px", n2.width = e2, n2.height = r2, n2;
  }, t2.prototype.stopStreams = function() {
    this.stream && (this.stream.getVideoTracks().forEach(function(t3) {
      return t3.stop();
    }), this.stream = void 0), false === this._stopAsyncDecode && this.stopAsyncDecode(), false === this._stopContinuousDecode && this.stopContinuousDecode();
  }, t2.prototype.reset = function() {
    this.stopStreams(), this._destroyVideoElement(), this._destroyImageElement(), this._destroyCaptureCanvas();
  }, t2.prototype._destroyVideoElement = function() {
    this.videoElement && (void 0 !== this.videoEndedListener && this.videoElement.removeEventListener("ended", this.videoEndedListener), void 0 !== this.videoPlayingEventListener && this.videoElement.removeEventListener("playing", this.videoPlayingEventListener), void 0 !== this.videoCanPlayListener && this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener), this.cleanVideoSource(this.videoElement), this.videoElement = void 0);
  }, t2.prototype._destroyImageElement = function() {
    this.imageElement && (void 0 !== this.imageLoadedListener && this.imageElement.removeEventListener("load", this.imageLoadedListener), this.imageElement.src = void 0, this.imageElement.removeAttribute("src"), this.imageElement = void 0);
  }, t2.prototype._destroyCaptureCanvas = function() {
    this.captureCanvasContext = void 0, this.captureCanvas = void 0;
  }, t2.prototype.addVideoSource = function(t3, e2) {
    try {
      t3.srcObject = e2;
    } catch (r2) {
      t3.src = URL.createObjectURL(e2);
    }
  }, t2.prototype.cleanVideoSource = function(t3) {
    try {
      t3.srcObject = null;
    } catch (e2) {
      t3.src = "";
    }
    this.videoElement.removeAttribute("src");
  }, t2;
}();
var gt = function() {
  function t2(t3, e2, r2, n2, o2, i2) {
    void 0 === r2 && (r2 = null == e2 ? 0 : 8 * e2.length), void 0 === i2 && (i2 = D.currentTimeMillis()), this.text = t3, this.rawBytes = e2, this.numBits = r2, this.resultPoints = n2, this.format = o2, this.timestamp = i2, this.text = t3, this.rawBytes = e2, this.numBits = null == r2 ? null == e2 ? 0 : 8 * e2.length : r2, this.resultPoints = n2, this.format = o2, this.resultMetadata = null, this.timestamp = null == i2 ? D.currentTimeMillis() : i2;
  }
  return t2.prototype.getText = function() {
    return this.text;
  }, t2.prototype.getRawBytes = function() {
    return this.rawBytes;
  }, t2.prototype.getNumBits = function() {
    return this.numBits;
  }, t2.prototype.getResultPoints = function() {
    return this.resultPoints;
  }, t2.prototype.getBarcodeFormat = function() {
    return this.format;
  }, t2.prototype.getResultMetadata = function() {
    return this.resultMetadata;
  }, t2.prototype.putMetadata = function(t3, e2) {
    null === this.resultMetadata && (this.resultMetadata = /* @__PURE__ */ new Map()), this.resultMetadata.set(t3, e2);
  }, t2.prototype.putAllMetadata = function(t3) {
    null !== t3 && (null === this.resultMetadata ? this.resultMetadata = t3 : this.resultMetadata = new Map(t3));
  }, t2.prototype.addResultPoints = function(t3) {
    var e2 = this.resultPoints;
    if (null === e2)
      this.resultPoints = t3;
    else if (null !== t3 && t3.length > 0) {
      var r2 = new Array(e2.length + t3.length);
      D.arraycopy(e2, 0, r2, 0, e2.length), D.arraycopy(t3, 0, r2, e2.length, t3.length), this.resultPoints = r2;
    }
  }, t2.prototype.getTimestamp = function() {
    return this.timestamp;
  }, t2.prototype.toString = function() {
    return this.text;
  }, t2;
}();
!function(t2) {
  t2[t2.AZTEC = 0] = "AZTEC", t2[t2.CODABAR = 1] = "CODABAR", t2[t2.CODE_39 = 2] = "CODE_39", t2[t2.CODE_93 = 3] = "CODE_93", t2[t2.CODE_128 = 4] = "CODE_128", t2[t2.DATA_MATRIX = 5] = "DATA_MATRIX", t2[t2.EAN_8 = 6] = "EAN_8", t2[t2.EAN_13 = 7] = "EAN_13", t2[t2.ITF = 8] = "ITF", t2[t2.MAXICODE = 9] = "MAXICODE", t2[t2.PDF_417 = 10] = "PDF_417", t2[t2.QR_CODE = 11] = "QR_CODE", t2[t2.RSS_14 = 12] = "RSS_14", t2[t2.RSS_EXPANDED = 13] = "RSS_EXPANDED", t2[t2.UPC_A = 14] = "UPC_A", t2[t2.UPC_E = 15] = "UPC_E", t2[t2.UPC_EAN_EXTENSION = 16] = "UPC_EAN_EXTENSION";
}(z || (z = {}));
var yt;
var wt = z;
!function(t2) {
  t2[t2.OTHER = 0] = "OTHER", t2[t2.ORIENTATION = 1] = "ORIENTATION", t2[t2.BYTE_SEGMENTS = 2] = "BYTE_SEGMENTS", t2[t2.ERROR_CORRECTION_LEVEL = 3] = "ERROR_CORRECTION_LEVEL", t2[t2.ISSUE_NUMBER = 4] = "ISSUE_NUMBER", t2[t2.SUGGESTED_PRICE = 5] = "SUGGESTED_PRICE", t2[t2.POSSIBLE_COUNTRY = 6] = "POSSIBLE_COUNTRY", t2[t2.UPC_EAN_EXTENSION = 7] = "UPC_EAN_EXTENSION", t2[t2.PDF417_EXTRA_METADATA = 8] = "PDF417_EXTRA_METADATA", t2[t2.STRUCTURED_APPEND_SEQUENCE = 9] = "STRUCTURED_APPEND_SEQUENCE", t2[t2.STRUCTURED_APPEND_PARITY = 10] = "STRUCTURED_APPEND_PARITY";
}(yt || (yt = {}));
var vt;
var _t = yt;
var At = function() {
  function t2(t3, e2, r2, n2, o2, i2) {
    void 0 === o2 && (o2 = -1), void 0 === i2 && (i2 = -1), this.rawBytes = t3, this.text = e2, this.byteSegments = r2, this.ecLevel = n2, this.structuredAppendSequenceNumber = o2, this.structuredAppendParity = i2, this.numBits = null == t3 ? 0 : 8 * t3.length;
  }
  return t2.prototype.getRawBytes = function() {
    return this.rawBytes;
  }, t2.prototype.getNumBits = function() {
    return this.numBits;
  }, t2.prototype.setNumBits = function(t3) {
    this.numBits = t3;
  }, t2.prototype.getText = function() {
    return this.text;
  }, t2.prototype.getByteSegments = function() {
    return this.byteSegments;
  }, t2.prototype.getECLevel = function() {
    return this.ecLevel;
  }, t2.prototype.getErrorsCorrected = function() {
    return this.errorsCorrected;
  }, t2.prototype.setErrorsCorrected = function(t3) {
    this.errorsCorrected = t3;
  }, t2.prototype.getErasures = function() {
    return this.erasures;
  }, t2.prototype.setErasures = function(t3) {
    this.erasures = t3;
  }, t2.prototype.getOther = function() {
    return this.other;
  }, t2.prototype.setOther = function(t3) {
    this.other = t3;
  }, t2.prototype.hasStructuredAppend = function() {
    return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
  }, t2.prototype.getStructuredAppendParity = function() {
    return this.structuredAppendParity;
  }, t2.prototype.getStructuredAppendSequenceNumber = function() {
    return this.structuredAppendSequenceNumber;
  }, t2;
}();
var Ct = function() {
  function t2() {
  }
  return t2.prototype.exp = function(t3) {
    return this.expTable[t3];
  }, t2.prototype.log = function(t3) {
    if (0 === t3)
      throw new T();
    return this.logTable[t3];
  }, t2.addOrSubtract = function(t3, e2) {
    return t3 ^ e2;
  }, t2;
}();
var mt = function() {
  function t2(t3, e2) {
    if (0 === e2.length)
      throw new T();
    this.field = t3;
    var r2 = e2.length;
    if (r2 > 1 && 0 === e2[0]) {
      for (var n2 = 1; n2 < r2 && 0 === e2[n2]; )
        n2++;
      n2 === r2 ? this.coefficients = Int32Array.from([0]) : (this.coefficients = new Int32Array(r2 - n2), D.arraycopy(e2, n2, this.coefficients, 0, this.coefficients.length));
    } else
      this.coefficients = e2;
  }
  return t2.prototype.getCoefficients = function() {
    return this.coefficients;
  }, t2.prototype.getDegree = function() {
    return this.coefficients.length - 1;
  }, t2.prototype.isZero = function() {
    return 0 === this.coefficients[0];
  }, t2.prototype.getCoefficient = function(t3) {
    return this.coefficients[this.coefficients.length - 1 - t3];
  }, t2.prototype.evaluateAt = function(t3) {
    if (0 === t3)
      return this.getCoefficient(0);
    var e2, r2 = this.coefficients;
    if (1 === t3) {
      e2 = 0;
      for (var n2 = 0, o2 = r2.length; n2 !== o2; n2++) {
        var i2 = r2[n2];
        e2 = Ct.addOrSubtract(e2, i2);
      }
      return e2;
    }
    e2 = r2[0];
    var a2 = r2.length, s2 = this.field;
    for (n2 = 1; n2 < a2; n2++)
      e2 = Ct.addOrSubtract(s2.multiply(t3, e2), r2[n2]);
    return e2;
  }, t2.prototype.addOrSubtract = function(e2) {
    if (!this.field.equals(e2.field))
      throw new T("GenericGFPolys do not have same GenericGF field");
    if (this.isZero())
      return e2;
    if (e2.isZero())
      return this;
    var r2 = this.coefficients, n2 = e2.coefficients;
    if (r2.length > n2.length) {
      var o2 = r2;
      r2 = n2, n2 = o2;
    }
    var i2 = new Int32Array(n2.length), a2 = n2.length - r2.length;
    D.arraycopy(n2, 0, i2, 0, a2);
    for (var s2 = a2; s2 < n2.length; s2++)
      i2[s2] = Ct.addOrSubtract(r2[s2 - a2], n2[s2]);
    return new t2(this.field, i2);
  }, t2.prototype.multiply = function(e2) {
    if (!this.field.equals(e2.field))
      throw new T("GenericGFPolys do not have same GenericGF field");
    if (this.isZero() || e2.isZero())
      return this.field.getZero();
    for (var r2 = this.coefficients, n2 = r2.length, o2 = e2.coefficients, i2 = o2.length, a2 = new Int32Array(n2 + i2 - 1), s2 = this.field, u2 = 0; u2 < n2; u2++)
      for (var c2 = r2[u2], f3 = 0; f3 < i2; f3++)
        a2[u2 + f3] = Ct.addOrSubtract(a2[u2 + f3], s2.multiply(c2, o2[f3]));
    return new t2(s2, a2);
  }, t2.prototype.multiplyScalar = function(e2) {
    if (0 === e2)
      return this.field.getZero();
    if (1 === e2)
      return this;
    for (var r2 = this.coefficients.length, n2 = this.field, o2 = new Int32Array(r2), i2 = this.coefficients, a2 = 0; a2 < r2; a2++)
      o2[a2] = n2.multiply(i2[a2], e2);
    return new t2(n2, o2);
  }, t2.prototype.multiplyByMonomial = function(e2, r2) {
    if (e2 < 0)
      throw new T();
    if (0 === r2)
      return this.field.getZero();
    for (var n2 = this.coefficients, o2 = n2.length, i2 = new Int32Array(o2 + e2), a2 = this.field, s2 = 0; s2 < o2; s2++)
      i2[s2] = a2.multiply(n2[s2], r2);
    return new t2(a2, i2);
  }, t2.prototype.divide = function(t3) {
    if (!this.field.equals(t3.field))
      throw new T("GenericGFPolys do not have same GenericGF field");
    if (t3.isZero())
      throw new T("Divide by 0");
    for (var e2 = this.field, r2 = e2.getZero(), n2 = this, o2 = t3.getCoefficient(t3.getDegree()), i2 = e2.inverse(o2); n2.getDegree() >= t3.getDegree() && !n2.isZero(); ) {
      var a2 = n2.getDegree() - t3.getDegree(), s2 = e2.multiply(n2.getCoefficient(n2.getDegree()), i2), u2 = t3.multiplyByMonomial(a2, s2), c2 = e2.buildMonomial(a2, s2);
      r2 = r2.addOrSubtract(c2), n2 = n2.addOrSubtract(u2);
    }
    return [r2, n2];
  }, t2.prototype.toString = function() {
    for (var t3 = "", e2 = this.getDegree(); e2 >= 0; e2--) {
      var r2 = this.getCoefficient(e2);
      if (0 !== r2) {
        if (r2 < 0 ? (t3 += " - ", r2 = -r2) : t3.length > 0 && (t3 += " + "), 0 === e2 || 1 !== r2) {
          var n2 = this.field.log(r2);
          0 === n2 ? t3 += "1" : 1 === n2 ? t3 += "a" : (t3 += "a^", t3 += n2);
        }
        0 !== e2 && (1 === e2 ? t3 += "x" : (t3 += "x^", t3 += e2));
      }
    }
    return t3;
  }, t2;
}();
var Et = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var It = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return Et(e2, t2), e2.kind = "ArithmeticException", e2;
}(m);
var St = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Tt = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this) || this;
    o2.primitive = e3, o2.size = r2, o2.generatorBase = n2;
    for (var i2 = new Int32Array(r2), a2 = 1, s2 = 0; s2 < r2; s2++)
      i2[s2] = a2, (a2 *= 2) >= r2 && (a2 ^= e3, a2 &= r2 - 1);
    o2.expTable = i2;
    var u2 = new Int32Array(r2);
    for (s2 = 0; s2 < r2 - 1; s2++)
      u2[i2[s2]] = s2;
    return o2.logTable = u2, o2.zero = new mt(o2, Int32Array.from([0])), o2.one = new mt(o2, Int32Array.from([1])), o2;
  }
  return St(e2, t2), e2.prototype.getZero = function() {
    return this.zero;
  }, e2.prototype.getOne = function() {
    return this.one;
  }, e2.prototype.buildMonomial = function(t3, e3) {
    if (t3 < 0)
      throw new T();
    if (0 === e3)
      return this.zero;
    var r2 = new Int32Array(t3 + 1);
    return r2[0] = e3, new mt(this, r2);
  }, e2.prototype.inverse = function(t3) {
    if (0 === t3)
      throw new It();
    return this.expTable[this.size - this.logTable[t3] - 1];
  }, e2.prototype.multiply = function(t3, e3) {
    return 0 === t3 || 0 === e3 ? 0 : this.expTable[(this.logTable[t3] + this.logTable[e3]) % (this.size - 1)];
  }, e2.prototype.getSize = function() {
    return this.size;
  }, e2.prototype.getGeneratorBase = function() {
    return this.generatorBase;
  }, e2.prototype.toString = function() {
    return "GF(0x" + x.toHexString(this.primitive) + "," + this.size + ")";
  }, e2.prototype.equals = function(t3) {
    return t3 === this;
  }, e2.AZTEC_DATA_12 = new e2(4201, 4096, 1), e2.AZTEC_DATA_10 = new e2(1033, 1024, 1), e2.AZTEC_DATA_6 = new e2(67, 64, 1), e2.AZTEC_PARAM = new e2(19, 16, 1), e2.QR_CODE_FIELD_256 = new e2(285, 256, 0), e2.DATA_MATRIX_FIELD_256 = new e2(301, 256, 1), e2.AZTEC_DATA_8 = e2.DATA_MATRIX_FIELD_256, e2.MAXICODE_FIELD_64 = e2.AZTEC_DATA_6, e2;
}(Ct);
var Ot = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var bt = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return Ot(e2, t2), e2.kind = "ReedSolomonException", e2;
}(m);
var Rt = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Nt = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return Rt(e2, t2), e2.kind = "IllegalStateException", e2;
}(m);
var Dt = function() {
  function t2(t3) {
    this.field = t3;
  }
  return t2.prototype.decode = function(t3, e2) {
    for (var r2 = this.field, n2 = new mt(r2, t3), o2 = new Int32Array(e2), i2 = true, a2 = 0; a2 < e2; a2++) {
      var s2 = n2.evaluateAt(r2.exp(a2 + r2.getGeneratorBase()));
      o2[o2.length - 1 - a2] = s2, 0 !== s2 && (i2 = false);
    }
    if (!i2) {
      var u2 = new mt(r2, o2), c2 = this.runEuclideanAlgorithm(r2.buildMonomial(e2, 1), u2, e2), f3 = c2[0], h2 = c2[1], l2 = this.findErrorLocations(f3), d2 = this.findErrorMagnitudes(h2, l2);
      for (a2 = 0; a2 < l2.length; a2++) {
        var p2 = t3.length - 1 - r2.log(l2[a2]);
        if (p2 < 0)
          throw new bt("Bad error location");
        t3[p2] = Tt.addOrSubtract(t3[p2], d2[a2]);
      }
    }
  }, t2.prototype.runEuclideanAlgorithm = function(t3, e2, r2) {
    if (t3.getDegree() < e2.getDegree()) {
      var n2 = t3;
      t3 = e2, e2 = n2;
    }
    for (var o2 = this.field, i2 = t3, a2 = e2, s2 = o2.getZero(), u2 = o2.getOne(); a2.getDegree() >= (r2 / 2 | 0); ) {
      var c2 = i2, f3 = s2;
      if (s2 = u2, (i2 = a2).isZero())
        throw new bt("r_{i-1} was zero");
      a2 = c2;
      for (var h2 = o2.getZero(), l2 = i2.getCoefficient(i2.getDegree()), d2 = o2.inverse(l2); a2.getDegree() >= i2.getDegree() && !a2.isZero(); ) {
        var p2 = a2.getDegree() - i2.getDegree(), g2 = o2.multiply(a2.getCoefficient(a2.getDegree()), d2);
        h2 = h2.addOrSubtract(o2.buildMonomial(p2, g2)), a2 = a2.addOrSubtract(i2.multiplyByMonomial(p2, g2));
      }
      if (u2 = h2.multiply(s2).addOrSubtract(f3), a2.getDegree() >= i2.getDegree())
        throw new Nt("Division algorithm failed to reduce polynomial?");
    }
    var y2 = u2.getCoefficient(0);
    if (0 === y2)
      throw new bt("sigmaTilde(0) was zero");
    var w2 = o2.inverse(y2);
    return [u2.multiplyScalar(w2), a2.multiplyScalar(w2)];
  }, t2.prototype.findErrorLocations = function(t3) {
    var e2 = t3.getDegree();
    if (1 === e2)
      return Int32Array.from([t3.getCoefficient(1)]);
    for (var r2 = new Int32Array(e2), n2 = 0, o2 = this.field, i2 = 1; i2 < o2.getSize() && n2 < e2; i2++)
      0 === t3.evaluateAt(i2) && (r2[n2] = o2.inverse(i2), n2++);
    if (n2 !== e2)
      throw new bt("Error locator degree does not match number of roots");
    return r2;
  }, t2.prototype.findErrorMagnitudes = function(t3, e2) {
    for (var r2 = e2.length, n2 = new Int32Array(r2), o2 = this.field, i2 = 0; i2 < r2; i2++) {
      for (var a2 = o2.inverse(e2[i2]), s2 = 1, u2 = 0; u2 < r2; u2++)
        if (i2 !== u2) {
          var c2 = o2.multiply(e2[u2], a2), f3 = 0 == (1 & c2) ? 1 | c2 : -2 & c2;
          s2 = o2.multiply(s2, f3);
        }
      n2[i2] = o2.multiply(t3.evaluateAt(a2), o2.inverse(s2)), 0 !== o2.getGeneratorBase() && (n2[i2] = o2.multiply(n2[i2], a2));
    }
    return n2;
  }, t2;
}();
!function(t2) {
  t2[t2.UPPER = 0] = "UPPER", t2[t2.LOWER = 1] = "LOWER", t2[t2.MIXED = 2] = "MIXED", t2[t2.DIGIT = 3] = "DIGIT", t2[t2.PUNCT = 4] = "PUNCT", t2[t2.BINARY = 5] = "BINARY";
}(vt || (vt = {}));
var Mt = function() {
  function t2() {
  }
  return t2.prototype.decode = function(e2) {
    this.ddata = e2;
    var r2 = e2.getBits(), n2 = this.extractBits(r2), o2 = this.correctBits(n2), i2 = t2.convertBoolArrayToByteArray(o2), a2 = t2.getEncodedData(o2), s2 = new At(i2, a2, null, null);
    return s2.setNumBits(o2.length), s2;
  }, t2.highLevelDecode = function(t3) {
    return this.getEncodedData(t3);
  }, t2.getEncodedData = function(e2) {
    for (var r2 = e2.length, n2 = vt.UPPER, o2 = vt.UPPER, i2 = "", a2 = 0; a2 < r2; )
      if (o2 === vt.BINARY) {
        if (r2 - a2 < 5)
          break;
        var s2 = t2.readCode(e2, a2, 5);
        if (a2 += 5, 0 === s2) {
          if (r2 - a2 < 11)
            break;
          s2 = t2.readCode(e2, a2, 11) + 31, a2 += 11;
        }
        for (var u2 = 0; u2 < s2; u2++) {
          if (r2 - a2 < 8) {
            a2 = r2;
            break;
          }
          var c2 = t2.readCode(e2, a2, 8);
          i2 += q.castAsNonUtf8Char(c2), a2 += 8;
        }
        o2 = n2;
      } else {
        var f3 = o2 === vt.DIGIT ? 4 : 5;
        if (r2 - a2 < f3)
          break;
        c2 = t2.readCode(e2, a2, f3);
        a2 += f3;
        var h2 = t2.getCharacter(o2, c2);
        h2.startsWith("CTRL_") ? (n2 = o2, o2 = t2.getTable(h2.charAt(5)), "L" === h2.charAt(6) && (n2 = o2)) : (i2 += h2, o2 = n2);
      }
    return i2;
  }, t2.getTable = function(t3) {
    switch (t3) {
      case "L":
        return vt.LOWER;
      case "P":
        return vt.PUNCT;
      case "M":
        return vt.MIXED;
      case "D":
        return vt.DIGIT;
      case "B":
        return vt.BINARY;
      default:
        return vt.UPPER;
    }
  }, t2.getCharacter = function(e2, r2) {
    switch (e2) {
      case vt.UPPER:
        return t2.UPPER_TABLE[r2];
      case vt.LOWER:
        return t2.LOWER_TABLE[r2];
      case vt.MIXED:
        return t2.MIXED_TABLE[r2];
      case vt.PUNCT:
        return t2.PUNCT_TABLE[r2];
      case vt.DIGIT:
        return t2.DIGIT_TABLE[r2];
      default:
        throw new Nt("Bad table");
    }
  }, t2.prototype.correctBits = function(e2) {
    var r2, n2;
    this.ddata.getNbLayers() <= 2 ? (n2 = 6, r2 = Tt.AZTEC_DATA_6) : this.ddata.getNbLayers() <= 8 ? (n2 = 8, r2 = Tt.AZTEC_DATA_8) : this.ddata.getNbLayers() <= 22 ? (n2 = 10, r2 = Tt.AZTEC_DATA_10) : (n2 = 12, r2 = Tt.AZTEC_DATA_12);
    var o2 = this.ddata.getNbDatablocks(), i2 = e2.length / n2;
    if (i2 < o2)
      throw new G();
    for (var a2 = e2.length % n2, s2 = new Int32Array(i2), u2 = 0; u2 < i2; u2++, a2 += n2)
      s2[u2] = t2.readCode(e2, a2, n2);
    try {
      new Dt(r2).decode(s2, i2 - o2);
    } catch (t3) {
      throw new G(t3);
    }
    var c2 = (1 << n2) - 1, f3 = 0;
    for (u2 = 0; u2 < o2; u2++) {
      if (0 === (d2 = s2[u2]) || d2 === c2)
        throw new G();
      1 !== d2 && d2 !== c2 - 1 || f3++;
    }
    var h2 = new Array(o2 * n2 - f3), l2 = 0;
    for (u2 = 0; u2 < o2; u2++) {
      var d2;
      if (1 === (d2 = s2[u2]) || d2 === c2 - 1)
        h2.fill(d2 > 1, l2, l2 + n2 - 1), l2 += n2 - 1;
      else
        for (var p2 = n2 - 1; p2 >= 0; --p2)
          h2[l2++] = 0 != (d2 & 1 << p2);
    }
    return h2;
  }, t2.prototype.extractBits = function(t3) {
    var e2 = this.ddata.isCompact(), r2 = this.ddata.getNbLayers(), n2 = (e2 ? 11 : 14) + 4 * r2, o2 = new Int32Array(n2), i2 = new Array(this.totalBitsInLayer(r2, e2));
    if (e2)
      for (var a2 = 0; a2 < o2.length; a2++)
        o2[a2] = a2;
    else {
      var s2 = n2 + 1 + 2 * x.truncDivision(x.truncDivision(n2, 2) - 1, 15), u2 = n2 / 2, c2 = x.truncDivision(s2, 2);
      for (a2 = 0; a2 < u2; a2++) {
        var f3 = a2 + x.truncDivision(a2, 15);
        o2[u2 - a2 - 1] = c2 - f3 - 1, o2[u2 + a2] = c2 + f3 + 1;
      }
    }
    a2 = 0;
    for (var h2 = 0; a2 < r2; a2++) {
      for (var l2 = 4 * (r2 - a2) + (e2 ? 9 : 12), d2 = 2 * a2, p2 = n2 - 1 - d2, g2 = 0; g2 < l2; g2++)
        for (var y2 = 2 * g2, w2 = 0; w2 < 2; w2++)
          i2[h2 + y2 + w2] = t3.get(o2[d2 + w2], o2[d2 + g2]), i2[h2 + 2 * l2 + y2 + w2] = t3.get(o2[d2 + g2], o2[p2 - w2]), i2[h2 + 4 * l2 + y2 + w2] = t3.get(o2[p2 - w2], o2[p2 - g2]), i2[h2 + 6 * l2 + y2 + w2] = t3.get(o2[p2 - g2], o2[d2 + w2]);
      h2 += 8 * l2;
    }
    return i2;
  }, t2.readCode = function(t3, e2, r2) {
    for (var n2 = 0, o2 = e2; o2 < e2 + r2; o2++)
      n2 <<= 1, t3[o2] && (n2 |= 1);
    return n2;
  }, t2.readByte = function(e2, r2) {
    var n2 = e2.length - r2;
    return n2 >= 8 ? t2.readCode(e2, r2, 8) : t2.readCode(e2, r2, n2) << 8 - n2;
  }, t2.convertBoolArrayToByteArray = function(e2) {
    for (var r2 = new Uint8Array((e2.length + 7) / 8), n2 = 0; n2 < r2.length; n2++)
      r2[n2] = t2.readByte(e2, 8 * n2);
    return r2;
  }, t2.prototype.totalBitsInLayer = function(t3, e2) {
    return ((e2 ? 88 : 112) + 16 * t3) * t3;
  }, t2.UPPER_TABLE = ["CTRL_PS", " ", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "CTRL_LL", "CTRL_ML", "CTRL_DL", "CTRL_BS"], t2.LOWER_TABLE = ["CTRL_PS", " ", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "CTRL_US", "CTRL_ML", "CTRL_DL", "CTRL_BS"], t2.MIXED_TABLE = ["CTRL_PS", " ", "\\1", "\\2", "\\3", "\\4", "\\5", "\\6", "\\7", "\b", "	", "\n", "\\13", "\f", "\r", "\\33", "\\34", "\\35", "\\36", "\\37", "@", "\\", "^", "_", "`", "|", "~", "\\177", "CTRL_LL", "CTRL_UL", "CTRL_PL", "CTRL_BS"], t2.PUNCT_TABLE = ["", "\r", "\r\n", ". ", ", ", ": ", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "[", "]", "{", "}", "CTRL_UL"], t2.DIGIT_TABLE = ["CTRL_PS", " ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ",", ".", "CTRL_UL", "CTRL_US"], t2;
}();
var Pt = function() {
  function t2() {
  }
  return t2.round = function(t3) {
    return isNaN(t3) ? 0 : t3 <= Number.MIN_SAFE_INTEGER ? Number.MIN_SAFE_INTEGER : t3 >= Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : t3 + (t3 < 0 ? -0.5 : 0.5) | 0;
  }, t2.distance = function(t3, e2, r2, n2) {
    var o2 = t3 - r2, i2 = e2 - n2;
    return Math.sqrt(o2 * o2 + i2 * i2);
  }, t2.sum = function(t3) {
    for (var e2 = 0, r2 = 0, n2 = t3.length; r2 !== n2; r2++) {
      e2 += t3[r2];
    }
    return e2;
  }, t2;
}();
var Bt = function() {
  function t2() {
  }
  return t2.floatToIntBits = function(t3) {
    return t3;
  }, t2.MAX_VALUE = Number.MAX_SAFE_INTEGER, t2;
}();
var Lt = function() {
  function t2(t3, e2) {
    this.x = t3, this.y = e2;
  }
  return t2.prototype.getX = function() {
    return this.x;
  }, t2.prototype.getY = function() {
    return this.y;
  }, t2.prototype.equals = function(e2) {
    if (e2 instanceof t2) {
      var r2 = e2;
      return this.x === r2.x && this.y === r2.y;
    }
    return false;
  }, t2.prototype.hashCode = function() {
    return 31 * Bt.floatToIntBits(this.x) + Bt.floatToIntBits(this.y);
  }, t2.prototype.toString = function() {
    return "(" + this.x + "," + this.y + ")";
  }, t2.orderBestPatterns = function(t3) {
    var e2, r2, n2, o2 = this.distance(t3[0], t3[1]), i2 = this.distance(t3[1], t3[2]), a2 = this.distance(t3[0], t3[2]);
    if (i2 >= o2 && i2 >= a2 ? (r2 = t3[0], e2 = t3[1], n2 = t3[2]) : a2 >= i2 && a2 >= o2 ? (r2 = t3[1], e2 = t3[0], n2 = t3[2]) : (r2 = t3[2], e2 = t3[0], n2 = t3[1]), this.crossProductZ(e2, r2, n2) < 0) {
      var s2 = e2;
      e2 = n2, n2 = s2;
    }
    t3[0] = e2, t3[1] = r2, t3[2] = n2;
  }, t2.distance = function(t3, e2) {
    return Pt.distance(t3.x, t3.y, e2.x, e2.y);
  }, t2.crossProductZ = function(t3, e2, r2) {
    var n2 = e2.x, o2 = e2.y;
    return (r2.x - n2) * (t3.y - o2) - (r2.y - o2) * (t3.x - n2);
  }, t2;
}();
var Ft = function() {
  function t2(t3, e2) {
    this.bits = t3, this.points = e2;
  }
  return t2.prototype.getBits = function() {
    return this.bits;
  }, t2.prototype.getPoints = function() {
    return this.points;
  }, t2;
}();
var kt = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var xt = function(t2) {
  function e2(e3, r2, n2, o2, i2) {
    var a2 = t2.call(this, e3, r2) || this;
    return a2.compact = n2, a2.nbDatablocks = o2, a2.nbLayers = i2, a2;
  }
  return kt(e2, t2), e2.prototype.getNbLayers = function() {
    return this.nbLayers;
  }, e2.prototype.getNbDatablocks = function() {
    return this.nbDatablocks;
  }, e2.prototype.isCompact = function() {
    return this.compact;
  }, e2;
}(Ft);
var Vt = function() {
  function t2(e2, r2, n2, o2) {
    this.image = e2, this.height = e2.getHeight(), this.width = e2.getWidth(), null == r2 && (r2 = t2.INIT_SIZE), null == n2 && (n2 = e2.getWidth() / 2 | 0), null == o2 && (o2 = e2.getHeight() / 2 | 0);
    var i2 = r2 / 2 | 0;
    if (this.leftInit = n2 - i2, this.rightInit = n2 + i2, this.upInit = o2 - i2, this.downInit = o2 + i2, this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width)
      throw new tt();
  }
  return t2.prototype.detect = function() {
    for (var t3 = this.leftInit, e2 = this.rightInit, r2 = this.upInit, n2 = this.downInit, o2 = false, i2 = true, a2 = false, s2 = false, u2 = false, c2 = false, f3 = false, h2 = this.width, l2 = this.height; i2; ) {
      i2 = false;
      for (var d2 = true; (d2 || !s2) && e2 < h2; )
        (d2 = this.containsBlackPoint(r2, n2, e2, false)) ? (e2++, i2 = true, s2 = true) : s2 || e2++;
      if (e2 >= h2) {
        o2 = true;
        break;
      }
      for (var p2 = true; (p2 || !u2) && n2 < l2; )
        (p2 = this.containsBlackPoint(t3, e2, n2, true)) ? (n2++, i2 = true, u2 = true) : u2 || n2++;
      if (n2 >= l2) {
        o2 = true;
        break;
      }
      for (var g2 = true; (g2 || !c2) && t3 >= 0; )
        (g2 = this.containsBlackPoint(r2, n2, t3, false)) ? (t3--, i2 = true, c2 = true) : c2 || t3--;
      if (t3 < 0) {
        o2 = true;
        break;
      }
      for (var y2 = true; (y2 || !f3) && r2 >= 0; )
        (y2 = this.containsBlackPoint(t3, e2, r2, true)) ? (r2--, i2 = true, f3 = true) : f3 || r2--;
      if (r2 < 0) {
        o2 = true;
        break;
      }
      i2 && (a2 = true);
    }
    if (!o2 && a2) {
      for (var w2 = e2 - t3, v2 = null, _2 = 1; null === v2 && _2 < w2; _2++)
        v2 = this.getBlackPointOnSegment(t3, n2 - _2, t3 + _2, n2);
      if (null == v2)
        throw new tt();
      var A2 = null;
      for (_2 = 1; null === A2 && _2 < w2; _2++)
        A2 = this.getBlackPointOnSegment(t3, r2 + _2, t3 + _2, r2);
      if (null == A2)
        throw new tt();
      var C2 = null;
      for (_2 = 1; null === C2 && _2 < w2; _2++)
        C2 = this.getBlackPointOnSegment(e2, r2 + _2, e2 - _2, r2);
      if (null == C2)
        throw new tt();
      var m2 = null;
      for (_2 = 1; null === m2 && _2 < w2; _2++)
        m2 = this.getBlackPointOnSegment(e2, n2 - _2, e2 - _2, n2);
      if (null == m2)
        throw new tt();
      return this.centerEdges(m2, v2, C2, A2);
    }
    throw new tt();
  }, t2.prototype.getBlackPointOnSegment = function(t3, e2, r2, n2) {
    for (var o2 = Pt.round(Pt.distance(t3, e2, r2, n2)), i2 = (r2 - t3) / o2, a2 = (n2 - e2) / o2, s2 = this.image, u2 = 0; u2 < o2; u2++) {
      var c2 = Pt.round(t3 + u2 * i2), f3 = Pt.round(e2 + u2 * a2);
      if (s2.get(c2, f3))
        return new Lt(c2, f3);
    }
    return null;
  }, t2.prototype.centerEdges = function(e2, r2, n2, o2) {
    var i2 = e2.getX(), a2 = e2.getY(), s2 = r2.getX(), u2 = r2.getY(), c2 = n2.getX(), f3 = n2.getY(), h2 = o2.getX(), l2 = o2.getY(), d2 = t2.CORR;
    return i2 < this.width / 2 ? [new Lt(h2 - d2, l2 + d2), new Lt(s2 + d2, u2 + d2), new Lt(c2 - d2, f3 - d2), new Lt(i2 + d2, a2 - d2)] : [new Lt(h2 + d2, l2 + d2), new Lt(s2 + d2, u2 - d2), new Lt(c2 - d2, f3 + d2), new Lt(i2 - d2, a2 - d2)];
  }, t2.prototype.containsBlackPoint = function(t3, e2, r2, n2) {
    var o2 = this.image;
    if (n2) {
      for (var i2 = t3; i2 <= e2; i2++)
        if (o2.get(i2, r2))
          return true;
    } else
      for (var a2 = t3; a2 <= e2; a2++)
        if (o2.get(r2, a2))
          return true;
    return false;
  }, t2.INIT_SIZE = 10, t2.CORR = 1, t2;
}();
var Ht = function() {
  function t2() {
  }
  return t2.checkAndNudgePoints = function(t3, e2) {
    for (var r2 = t3.getWidth(), n2 = t3.getHeight(), o2 = true, i2 = 0; i2 < e2.length && o2; i2 += 2) {
      var a2 = Math.floor(e2[i2]), s2 = Math.floor(e2[i2 + 1]);
      if (a2 < -1 || a2 > r2 || s2 < -1 || s2 > n2)
        throw new tt();
      o2 = false, -1 === a2 ? (e2[i2] = 0, o2 = true) : a2 === r2 && (e2[i2] = r2 - 1, o2 = true), -1 === s2 ? (e2[i2 + 1] = 0, o2 = true) : s2 === n2 && (e2[i2 + 1] = n2 - 1, o2 = true);
    }
    o2 = true;
    for (i2 = e2.length - 2; i2 >= 0 && o2; i2 -= 2) {
      a2 = Math.floor(e2[i2]), s2 = Math.floor(e2[i2 + 1]);
      if (a2 < -1 || a2 > r2 || s2 < -1 || s2 > n2)
        throw new tt();
      o2 = false, -1 === a2 ? (e2[i2] = 0, o2 = true) : a2 === r2 && (e2[i2] = r2 - 1, o2 = true), -1 === s2 ? (e2[i2 + 1] = 0, o2 = true) : s2 === n2 && (e2[i2 + 1] = n2 - 1, o2 = true);
    }
  }, t2;
}();
var Ut = function() {
  function t2(t3, e2, r2, n2, o2, i2, a2, s2, u2) {
    this.a11 = t3, this.a21 = e2, this.a31 = r2, this.a12 = n2, this.a22 = o2, this.a32 = i2, this.a13 = a2, this.a23 = s2, this.a33 = u2;
  }
  return t2.quadrilateralToQuadrilateral = function(e2, r2, n2, o2, i2, a2, s2, u2, c2, f3, h2, l2, d2, p2, g2, y2) {
    var w2 = t2.quadrilateralToSquare(e2, r2, n2, o2, i2, a2, s2, u2);
    return t2.squareToQuadrilateral(c2, f3, h2, l2, d2, p2, g2, y2).times(w2);
  }, t2.prototype.transformPoints = function(t3) {
    for (var e2 = t3.length, r2 = this.a11, n2 = this.a12, o2 = this.a13, i2 = this.a21, a2 = this.a22, s2 = this.a23, u2 = this.a31, c2 = this.a32, f3 = this.a33, h2 = 0; h2 < e2; h2 += 2) {
      var l2 = t3[h2], d2 = t3[h2 + 1], p2 = o2 * l2 + s2 * d2 + f3;
      t3[h2] = (r2 * l2 + i2 * d2 + u2) / p2, t3[h2 + 1] = (n2 * l2 + a2 * d2 + c2) / p2;
    }
  }, t2.prototype.transformPointsWithValues = function(t3, e2) {
    for (var r2 = this.a11, n2 = this.a12, o2 = this.a13, i2 = this.a21, a2 = this.a22, s2 = this.a23, u2 = this.a31, c2 = this.a32, f3 = this.a33, h2 = t3.length, l2 = 0; l2 < h2; l2++) {
      var d2 = t3[l2], p2 = e2[l2], g2 = o2 * d2 + s2 * p2 + f3;
      t3[l2] = (r2 * d2 + i2 * p2 + u2) / g2, e2[l2] = (n2 * d2 + a2 * p2 + c2) / g2;
    }
  }, t2.squareToQuadrilateral = function(e2, r2, n2, o2, i2, a2, s2, u2) {
    var c2 = e2 - n2 + i2 - s2, f3 = r2 - o2 + a2 - u2;
    if (0 === c2 && 0 === f3)
      return new t2(n2 - e2, i2 - n2, e2, o2 - r2, a2 - o2, r2, 0, 0, 1);
    var h2 = n2 - i2, l2 = s2 - i2, d2 = o2 - a2, p2 = u2 - a2, g2 = h2 * p2 - l2 * d2, y2 = (c2 * p2 - l2 * f3) / g2, w2 = (h2 * f3 - c2 * d2) / g2;
    return new t2(n2 - e2 + y2 * n2, s2 - e2 + w2 * s2, e2, o2 - r2 + y2 * o2, u2 - r2 + w2 * u2, r2, y2, w2, 1);
  }, t2.quadrilateralToSquare = function(e2, r2, n2, o2, i2, a2, s2, u2) {
    return t2.squareToQuadrilateral(e2, r2, n2, o2, i2, a2, s2, u2).buildAdjoint();
  }, t2.prototype.buildAdjoint = function() {
    return new t2(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
  }, t2.prototype.times = function(e2) {
    return new t2(this.a11 * e2.a11 + this.a21 * e2.a12 + this.a31 * e2.a13, this.a11 * e2.a21 + this.a21 * e2.a22 + this.a31 * e2.a23, this.a11 * e2.a31 + this.a21 * e2.a32 + this.a31 * e2.a33, this.a12 * e2.a11 + this.a22 * e2.a12 + this.a32 * e2.a13, this.a12 * e2.a21 + this.a22 * e2.a22 + this.a32 * e2.a23, this.a12 * e2.a31 + this.a22 * e2.a32 + this.a32 * e2.a33, this.a13 * e2.a11 + this.a23 * e2.a12 + this.a33 * e2.a13, this.a13 * e2.a21 + this.a23 * e2.a22 + this.a33 * e2.a23, this.a13 * e2.a31 + this.a23 * e2.a32 + this.a33 * e2.a33);
  }, t2;
}();
var Xt = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Gt = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return Xt(e2, t2), e2.prototype.sampleGrid = function(t3, e3, r2, n2, o2, i2, a2, s2, u2, c2, f3, h2, l2, d2, p2, g2, y2, w2, v2) {
    var _2 = Ut.quadrilateralToQuadrilateral(n2, o2, i2, a2, s2, u2, c2, f3, h2, l2, d2, p2, g2, y2, w2, v2);
    return this.sampleGridWithTransform(t3, e3, r2, _2);
  }, e2.prototype.sampleGridWithTransform = function(t3, e3, r2, n2) {
    if (e3 <= 0 || r2 <= 0)
      throw new tt();
    for (var o2 = new J(e3, r2), i2 = new Float32Array(2 * e3), a2 = 0; a2 < r2; a2++) {
      for (var s2 = i2.length, u2 = a2 + 0.5, c2 = 0; c2 < s2; c2 += 2)
        i2[c2] = c2 / 2 + 0.5, i2[c2 + 1] = u2;
      n2.transformPoints(i2), Ht.checkAndNudgePoints(t3, i2);
      try {
        for (c2 = 0; c2 < s2; c2 += 2)
          t3.get(Math.floor(i2[c2]), Math.floor(i2[c2 + 1])) && o2.set(c2 / 2, a2);
      } catch (t4) {
        throw new tt();
      }
    }
    return o2;
  }, e2;
}(Ht);
var Wt = function() {
  function t2() {
  }
  return t2.setGridSampler = function(e2) {
    t2.gridSampler = e2;
  }, t2.getInstance = function() {
    return t2.gridSampler;
  }, t2.gridSampler = new Gt(), t2;
}();
var zt = function() {
  function t2(t3, e2) {
    this.x = t3, this.y = e2;
  }
  return t2.prototype.toResultPoint = function() {
    return new Lt(this.getX(), this.getY());
  }, t2.prototype.getX = function() {
    return this.x;
  }, t2.prototype.getY = function() {
    return this.y;
  }, t2;
}();
var jt = function() {
  function t2(t3) {
    this.EXPECTED_CORNER_BITS = new Int32Array([3808, 476, 2107, 1799]), this.image = t3;
  }
  return t2.prototype.detect = function() {
    return this.detectMirror(false);
  }, t2.prototype.detectMirror = function(t3) {
    var e2 = this.getMatrixCenter(), r2 = this.getBullsEyeCorners(e2);
    if (t3) {
      var n2 = r2[0];
      r2[0] = r2[2], r2[2] = n2;
    }
    this.extractParameters(r2);
    var o2 = this.sampleGrid(this.image, r2[this.shift % 4], r2[(this.shift + 1) % 4], r2[(this.shift + 2) % 4], r2[(this.shift + 3) % 4]), i2 = this.getMatrixCornerPoints(r2);
    return new xt(o2, i2, this.compact, this.nbDataBlocks, this.nbLayers);
  }, t2.prototype.extractParameters = function(t3) {
    if (!(this.isValidPoint(t3[0]) && this.isValidPoint(t3[1]) && this.isValidPoint(t3[2]) && this.isValidPoint(t3[3])))
      throw new tt();
    var e2 = 2 * this.nbCenterLayers, r2 = new Int32Array([this.sampleLine(t3[0], t3[1], e2), this.sampleLine(t3[1], t3[2], e2), this.sampleLine(t3[2], t3[3], e2), this.sampleLine(t3[3], t3[0], e2)]);
    this.shift = this.getRotation(r2, e2);
    for (var n2 = 0, o2 = 0; o2 < 4; o2++) {
      var i2 = r2[(this.shift + o2) % 4];
      this.compact ? (n2 <<= 7, n2 += i2 >> 1 & 127) : (n2 <<= 10, n2 += (i2 >> 2 & 992) + (i2 >> 1 & 31));
    }
    var a2 = this.getCorrectedParameterData(n2, this.compact);
    this.compact ? (this.nbLayers = 1 + (a2 >> 6), this.nbDataBlocks = 1 + (63 & a2)) : (this.nbLayers = 1 + (a2 >> 11), this.nbDataBlocks = 1 + (2047 & a2));
  }, t2.prototype.getRotation = function(t3, e2) {
    var r2 = 0;
    t3.forEach(function(t4, n3, o2) {
      r2 = (r2 << 3) + ((t4 >> e2 - 2 << 1) + (1 & t4));
    }), r2 = ((1 & r2) << 11) + (r2 >> 1);
    for (var n2 = 0; n2 < 4; n2++)
      if (x.bitCount(r2 ^ this.EXPECTED_CORNER_BITS[n2]) <= 2)
        return n2;
    throw new tt();
  }, t2.prototype.getCorrectedParameterData = function(t3, e2) {
    var r2, n2;
    e2 ? (r2 = 7, n2 = 2) : (r2 = 10, n2 = 4);
    for (var o2 = r2 - n2, i2 = new Int32Array(r2), a2 = r2 - 1; a2 >= 0; --a2)
      i2[a2] = 15 & t3, t3 >>= 4;
    try {
      new Dt(Tt.AZTEC_PARAM).decode(i2, o2);
    } catch (t4) {
      throw new tt();
    }
    var s2 = 0;
    for (a2 = 0; a2 < n2; a2++)
      s2 = (s2 << 4) + i2[a2];
    return s2;
  }, t2.prototype.getBullsEyeCorners = function(t3) {
    var e2 = t3, r2 = t3, n2 = t3, o2 = t3, i2 = true;
    for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
      var a2 = this.getFirstDifferent(e2, i2, 1, -1), s2 = this.getFirstDifferent(r2, i2, 1, 1), u2 = this.getFirstDifferent(n2, i2, -1, 1), c2 = this.getFirstDifferent(o2, i2, -1, -1);
      if (this.nbCenterLayers > 2) {
        var f3 = this.distancePoint(c2, a2) * this.nbCenterLayers / (this.distancePoint(o2, e2) * (this.nbCenterLayers + 2));
        if (f3 < 0.75 || f3 > 1.25 || !this.isWhiteOrBlackRectangle(a2, s2, u2, c2))
          break;
      }
      e2 = a2, r2 = s2, n2 = u2, o2 = c2, i2 = !i2;
    }
    if (5 !== this.nbCenterLayers && 7 !== this.nbCenterLayers)
      throw new tt();
    this.compact = 5 === this.nbCenterLayers;
    var h2 = new Lt(e2.getX() + 0.5, e2.getY() - 0.5), l2 = new Lt(r2.getX() + 0.5, r2.getY() + 0.5), d2 = new Lt(n2.getX() - 0.5, n2.getY() + 0.5), p2 = new Lt(o2.getX() - 0.5, o2.getY() - 0.5);
    return this.expandSquare([h2, l2, d2, p2], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
  }, t2.prototype.getMatrixCenter = function() {
    var t3, e2, r2, n2;
    try {
      t3 = (u2 = new Vt(this.image).detect())[0], e2 = u2[1], r2 = u2[2], n2 = u2[3];
    } catch (a3) {
      var o2 = this.image.getWidth() / 2, i2 = this.image.getHeight() / 2;
      t3 = this.getFirstDifferent(new zt(o2 + 7, i2 - 7), false, 1, -1).toResultPoint(), e2 = this.getFirstDifferent(new zt(o2 + 7, i2 + 7), false, 1, 1).toResultPoint(), r2 = this.getFirstDifferent(new zt(o2 - 7, i2 + 7), false, -1, 1).toResultPoint(), n2 = this.getFirstDifferent(new zt(o2 - 7, i2 - 7), false, -1, -1).toResultPoint();
    }
    var a2 = Pt.round((t3.getX() + n2.getX() + e2.getX() + r2.getX()) / 4), s2 = Pt.round((t3.getY() + n2.getY() + e2.getY() + r2.getY()) / 4);
    try {
      var u2;
      t3 = (u2 = new Vt(this.image, 15, a2, s2).detect())[0], e2 = u2[1], r2 = u2[2], n2 = u2[3];
    } catch (o3) {
      t3 = this.getFirstDifferent(new zt(a2 + 7, s2 - 7), false, 1, -1).toResultPoint(), e2 = this.getFirstDifferent(new zt(a2 + 7, s2 + 7), false, 1, 1).toResultPoint(), r2 = this.getFirstDifferent(new zt(a2 - 7, s2 + 7), false, -1, 1).toResultPoint(), n2 = this.getFirstDifferent(new zt(a2 - 7, s2 - 7), false, -1, -1).toResultPoint();
    }
    return a2 = Pt.round((t3.getX() + n2.getX() + e2.getX() + r2.getX()) / 4), s2 = Pt.round((t3.getY() + n2.getY() + e2.getY() + r2.getY()) / 4), new zt(a2, s2);
  }, t2.prototype.getMatrixCornerPoints = function(t3) {
    return this.expandSquare(t3, 2 * this.nbCenterLayers, this.getDimension());
  }, t2.prototype.sampleGrid = function(t3, e2, r2, n2, o2) {
    var i2 = Wt.getInstance(), a2 = this.getDimension(), s2 = a2 / 2 - this.nbCenterLayers, u2 = a2 / 2 + this.nbCenterLayers;
    return i2.sampleGrid(t3, a2, a2, s2, s2, u2, s2, u2, u2, s2, u2, e2.getX(), e2.getY(), r2.getX(), r2.getY(), n2.getX(), n2.getY(), o2.getX(), o2.getY());
  }, t2.prototype.sampleLine = function(t3, e2, r2) {
    for (var n2 = 0, o2 = this.distanceResultPoint(t3, e2), i2 = o2 / r2, a2 = t3.getX(), s2 = t3.getY(), u2 = i2 * (e2.getX() - t3.getX()) / o2, c2 = i2 * (e2.getY() - t3.getY()) / o2, f3 = 0; f3 < r2; f3++)
      this.image.get(Pt.round(a2 + f3 * u2), Pt.round(s2 + f3 * c2)) && (n2 |= 1 << r2 - f3 - 1);
    return n2;
  }, t2.prototype.isWhiteOrBlackRectangle = function(t3, e2, r2, n2) {
    t3 = new zt(t3.getX() - 3, t3.getY() + 3), e2 = new zt(e2.getX() - 3, e2.getY() - 3), r2 = new zt(r2.getX() + 3, r2.getY() - 3), n2 = new zt(n2.getX() + 3, n2.getY() + 3);
    var o2 = this.getColor(n2, t3);
    if (0 === o2)
      return false;
    var i2 = this.getColor(t3, e2);
    return i2 === o2 && ((i2 = this.getColor(e2, r2)) === o2 && (i2 = this.getColor(r2, n2)) === o2);
  }, t2.prototype.getColor = function(t3, e2) {
    for (var r2 = this.distancePoint(t3, e2), n2 = (e2.getX() - t3.getX()) / r2, o2 = (e2.getY() - t3.getY()) / r2, i2 = 0, a2 = t3.getX(), s2 = t3.getY(), u2 = this.image.get(t3.getX(), t3.getY()), c2 = Math.ceil(r2), f3 = 0; f3 < c2; f3++)
      a2 += n2, s2 += o2, this.image.get(Pt.round(a2), Pt.round(s2)) !== u2 && i2++;
    var h2 = i2 / r2;
    return h2 > 0.1 && h2 < 0.9 ? 0 : h2 <= 0.1 === u2 ? 1 : -1;
  }, t2.prototype.getFirstDifferent = function(t3, e2, r2, n2) {
    for (var o2 = t3.getX() + r2, i2 = t3.getY() + n2; this.isValid(o2, i2) && this.image.get(o2, i2) === e2; )
      o2 += r2, i2 += n2;
    for (o2 -= r2, i2 -= n2; this.isValid(o2, i2) && this.image.get(o2, i2) === e2; )
      o2 += r2;
    for (o2 -= r2; this.isValid(o2, i2) && this.image.get(o2, i2) === e2; )
      i2 += n2;
    return new zt(o2, i2 -= n2);
  }, t2.prototype.expandSquare = function(t3, e2, r2) {
    var n2 = r2 / (2 * e2), o2 = t3[0].getX() - t3[2].getX(), i2 = t3[0].getY() - t3[2].getY(), a2 = (t3[0].getX() + t3[2].getX()) / 2, s2 = (t3[0].getY() + t3[2].getY()) / 2, u2 = new Lt(a2 + n2 * o2, s2 + n2 * i2), c2 = new Lt(a2 - n2 * o2, s2 - n2 * i2);
    return o2 = t3[1].getX() - t3[3].getX(), i2 = t3[1].getY() - t3[3].getY(), a2 = (t3[1].getX() + t3[3].getX()) / 2, s2 = (t3[1].getY() + t3[3].getY()) / 2, [u2, new Lt(a2 + n2 * o2, s2 + n2 * i2), c2, new Lt(a2 - n2 * o2, s2 - n2 * i2)];
  }, t2.prototype.isValid = function(t3, e2) {
    return t3 >= 0 && t3 < this.image.getWidth() && e2 > 0 && e2 < this.image.getHeight();
  }, t2.prototype.isValidPoint = function(t3) {
    var e2 = Pt.round(t3.getX()), r2 = Pt.round(t3.getY());
    return this.isValid(e2, r2);
  }, t2.prototype.distancePoint = function(t3, e2) {
    return Pt.distance(t3.getX(), t3.getY(), e2.getX(), e2.getY());
  }, t2.prototype.distanceResultPoint = function(t3, e2) {
    return Pt.distance(t3.getX(), t3.getY(), e2.getX(), e2.getY());
  }, t2.prototype.getDimension = function() {
    return this.compact ? 4 * this.nbLayers + 11 : this.nbLayers <= 4 ? 4 * this.nbLayers + 15 : 4 * this.nbLayers + 2 * (x.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
  }, t2;
}();
var Yt = function() {
  function t2() {
  }
  return t2.prototype.decode = function(t3, e2) {
    void 0 === e2 && (e2 = null);
    var r2 = null, n2 = new jt(t3.getBlackMatrix()), o2 = null, i2 = null;
    try {
      o2 = (a2 = n2.detectMirror(false)).getPoints(), this.reportFoundResultPoints(e2, o2), i2 = new Mt().decode(a2);
    } catch (t4) {
      r2 = t4;
    }
    if (null == i2)
      try {
        var a2;
        o2 = (a2 = n2.detectMirror(true)).getPoints(), this.reportFoundResultPoints(e2, o2), i2 = new Mt().decode(a2);
      } catch (t4) {
        if (null != r2)
          throw r2;
        throw t4;
      }
    var s2 = new gt(i2.getText(), i2.getRawBytes(), i2.getNumBits(), o2, wt.AZTEC, D.currentTimeMillis()), u2 = i2.getByteSegments();
    null != u2 && s2.putMetadata(_t.BYTE_SEGMENTS, u2);
    var c2 = i2.getECLevel();
    return null != c2 && s2.putMetadata(_t.ERROR_CORRECTION_LEVEL, c2), s2;
  }, t2.prototype.reportFoundResultPoints = function(t3, e2) {
    if (null != t3) {
      var r2 = t3.get(U.NEED_RESULT_POINT_CALLBACK);
      null != r2 && e2.forEach(function(t4, e3, n2) {
        r2.foundPossibleResultPoint(t4);
      });
    }
  }, t2.prototype.reset = function() {
  }, t2;
}();
var Zt = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  function e2(e3) {
    return void 0 === e3 && (e3 = 500), t2.call(this, new Yt(), e3) || this;
  }
  Zt(e2, t2);
}(pt);
var Kt = function() {
  function t2() {
  }
  return t2.prototype.decode = function(t3, e2) {
    try {
      return this.doDecode(t3, e2);
    } catch (c2) {
      if (e2 && true === e2.get(U.TRY_HARDER) && t3.isRotateSupported()) {
        var r2 = t3.rotateCounterClockwise(), n2 = this.doDecode(r2, e2), o2 = n2.getResultMetadata(), i2 = 270;
        null !== o2 && true === o2.get(_t.ORIENTATION) && (i2 += o2.get(_t.ORIENTATION) % 360), n2.putMetadata(_t.ORIENTATION, i2);
        var a2 = n2.getResultPoints();
        if (null !== a2)
          for (var s2 = r2.getHeight(), u2 = 0; u2 < a2.length; u2++)
            a2[u2] = new Lt(s2 - a2[u2].getY() - 1, a2[u2].getX());
        return n2;
      }
      throw new tt();
    }
  }, t2.prototype.reset = function() {
  }, t2.prototype.doDecode = function(t3, e2) {
    var r2, n2 = t3.getWidth(), o2 = t3.getHeight(), i2 = new V(n2), a2 = e2 && true === e2.get(U.TRY_HARDER), s2 = Math.max(1, o2 >> (a2 ? 8 : 5));
    r2 = a2 ? o2 : 15;
    for (var u2 = Math.trunc(o2 / 2), c2 = 0; c2 < r2; c2++) {
      var f3 = Math.trunc((c2 + 1) / 2), h2 = u2 + s2 * (0 == (1 & c2) ? f3 : -f3);
      if (h2 < 0 || h2 >= o2)
        break;
      try {
        i2 = t3.getBlackRow(h2, i2);
      } catch (t4) {
        continue;
      }
      for (var l2 = function(t4) {
        if (1 === t4 && (i2.reverse(), e2 && true === e2.get(U.NEED_RESULT_POINT_CALLBACK))) {
          var r3 = /* @__PURE__ */ new Map();
          e2.forEach(function(t5, e3) {
            return r3.set(e3, t5);
          }), r3.delete(U.NEED_RESULT_POINT_CALLBACK), e2 = r3;
        }
        try {
          var o3 = d2.decodeRow(h2, i2, e2);
          if (1 === t4) {
            o3.putMetadata(_t.ORIENTATION, 180);
            var a3 = o3.getResultPoints();
            null !== a3 && (a3[0] = new Lt(n2 - a3[0].getX() - 1, a3[0].getY()), a3[1] = new Lt(n2 - a3[1].getX() - 1, a3[1].getY()));
          }
          return { value: o3 };
        } catch (t5) {
        }
      }, d2 = this, p2 = 0; p2 < 2; p2++) {
        var g2 = l2(p2);
        if ("object" == typeof g2)
          return g2.value;
      }
    }
    throw new tt();
  }, t2.recordPattern = function(t3, e2, r2) {
    for (var n2 = r2.length, o2 = 0; o2 < n2; o2++)
      r2[o2] = 0;
    var i2 = t3.getSize();
    if (e2 >= i2)
      throw new tt();
    for (var a2 = !t3.get(e2), s2 = 0, u2 = e2; u2 < i2; ) {
      if (t3.get(u2) !== a2)
        r2[s2]++;
      else {
        if (++s2 === n2)
          break;
        r2[s2] = 1, a2 = !a2;
      }
      u2++;
    }
    if (s2 !== n2 && (s2 !== n2 - 1 || u2 !== i2))
      throw new tt();
  }, t2.recordPatternInReverse = function(e2, r2, n2) {
    for (var o2 = n2.length, i2 = e2.get(r2); r2 > 0 && o2 >= 0; )
      e2.get(--r2) !== i2 && (o2--, i2 = !i2);
    if (o2 >= 0)
      throw new tt();
    t2.recordPattern(e2, r2 + 1, n2);
  }, t2.patternMatchVariance = function(t3, e2, r2) {
    for (var n2 = t3.length, o2 = 0, i2 = 0, a2 = 0; a2 < n2; a2++)
      o2 += t3[a2], i2 += e2[a2];
    if (o2 < i2)
      return Number.POSITIVE_INFINITY;
    var s2 = o2 / i2;
    r2 *= s2;
    for (var u2 = 0, c2 = 0; c2 < n2; c2++) {
      var f3 = t3[c2], h2 = e2[c2] * s2, l2 = f3 > h2 ? f3 - h2 : h2 - f3;
      if (l2 > r2)
        return Number.POSITIVE_INFINITY;
      u2 += l2;
    }
    return u2 / o2;
  }, t2;
}();
var qt = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Qt = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return qt(e2, t2), e2.findStartPattern = function(t3) {
    for (var r2 = t3.getSize(), n2 = t3.getNextSet(0), o2 = 0, i2 = Int32Array.from([0, 0, 0, 0, 0, 0]), a2 = n2, s2 = false, u2 = n2; u2 < r2; u2++)
      if (t3.get(u2) !== s2)
        i2[o2]++;
      else {
        if (5 === o2) {
          for (var c2 = e2.MAX_AVG_VARIANCE, f3 = -1, h2 = e2.CODE_START_A; h2 <= e2.CODE_START_C; h2++) {
            var l2 = Kt.patternMatchVariance(i2, e2.CODE_PATTERNS[h2], e2.MAX_INDIVIDUAL_VARIANCE);
            l2 < c2 && (c2 = l2, f3 = h2);
          }
          if (f3 >= 0 && t3.isRange(Math.max(0, a2 - (u2 - a2) / 2), a2, false))
            return Int32Array.from([a2, u2, f3]);
          a2 += i2[0] + i2[1], (i2 = i2.slice(2, i2.length - 1))[o2 - 1] = 0, i2[o2] = 0, o2--;
        } else
          o2++;
        i2[o2] = 1, s2 = !s2;
      }
    throw new tt();
  }, e2.decodeCode = function(t3, r2, n2) {
    Kt.recordPattern(t3, n2, r2);
    for (var o2 = e2.MAX_AVG_VARIANCE, i2 = -1, a2 = 0; a2 < e2.CODE_PATTERNS.length; a2++) {
      var s2 = e2.CODE_PATTERNS[a2], u2 = this.patternMatchVariance(r2, s2, e2.MAX_INDIVIDUAL_VARIANCE);
      u2 < o2 && (o2 = u2, i2 = a2);
    }
    if (i2 >= 0)
      return i2;
    throw new tt();
  }, e2.prototype.decodeRow = function(t3, r2, n2) {
    var o2, i2 = n2 && true === n2.get(U.ASSUME_GS1), a2 = e2.findStartPattern(r2), s2 = a2[2], u2 = 0, c2 = new Uint8Array(20);
    switch (c2[u2++] = s2, s2) {
      case e2.CODE_START_A:
        o2 = e2.CODE_CODE_A;
        break;
      case e2.CODE_START_B:
        o2 = e2.CODE_CODE_B;
        break;
      case e2.CODE_START_C:
        o2 = e2.CODE_CODE_C;
        break;
      default:
        throw new G();
    }
    for (var f3 = false, h2 = false, l2 = "", d2 = a2[0], p2 = a2[1], g2 = Int32Array.from([0, 0, 0, 0, 0, 0]), y2 = 0, w2 = 0, v2 = s2, _2 = 0, A2 = true, C2 = false, m2 = false; !f3; ) {
      var E2 = h2;
      switch (h2 = false, y2 = w2, w2 = e2.decodeCode(r2, g2, p2), c2[u2++] = w2, w2 !== e2.CODE_STOP && (A2 = true), w2 !== e2.CODE_STOP && (v2 += ++_2 * w2), d2 = p2, p2 += g2.reduce(function(t4, e3) {
        return t4 + e3;
      }, 0), w2) {
        case e2.CODE_START_A:
        case e2.CODE_START_B:
        case e2.CODE_START_C:
          throw new G();
      }
      switch (o2) {
        case e2.CODE_CODE_A:
          if (w2 < 64)
            l2 += m2 === C2 ? String.fromCharCode(" ".charCodeAt(0) + w2) : String.fromCharCode(" ".charCodeAt(0) + w2 + 128), m2 = false;
          else if (w2 < 96)
            l2 += m2 === C2 ? String.fromCharCode(w2 - 64) : String.fromCharCode(w2 + 64), m2 = false;
          else
            switch (w2 !== e2.CODE_STOP && (A2 = false), w2) {
              case e2.CODE_FNC_1:
                i2 && (0 === l2.length ? l2 += "]C1" : l2 += String.fromCharCode(29));
                break;
              case e2.CODE_FNC_2:
              case e2.CODE_FNC_3:
                break;
              case e2.CODE_FNC_4_A:
                !C2 && m2 ? (C2 = true, m2 = false) : C2 && m2 ? (C2 = false, m2 = false) : m2 = true;
                break;
              case e2.CODE_SHIFT:
                h2 = true, o2 = e2.CODE_CODE_B;
                break;
              case e2.CODE_CODE_B:
                o2 = e2.CODE_CODE_B;
                break;
              case e2.CODE_CODE_C:
                o2 = e2.CODE_CODE_C;
                break;
              case e2.CODE_STOP:
                f3 = true;
            }
          break;
        case e2.CODE_CODE_B:
          if (w2 < 96)
            l2 += m2 === C2 ? String.fromCharCode(" ".charCodeAt(0) + w2) : String.fromCharCode(" ".charCodeAt(0) + w2 + 128), m2 = false;
          else
            switch (w2 !== e2.CODE_STOP && (A2 = false), w2) {
              case e2.CODE_FNC_1:
                i2 && (0 === l2.length ? l2 += "]C1" : l2 += String.fromCharCode(29));
                break;
              case e2.CODE_FNC_2:
              case e2.CODE_FNC_3:
                break;
              case e2.CODE_FNC_4_B:
                !C2 && m2 ? (C2 = true, m2 = false) : C2 && m2 ? (C2 = false, m2 = false) : m2 = true;
                break;
              case e2.CODE_SHIFT:
                h2 = true, o2 = e2.CODE_CODE_A;
                break;
              case e2.CODE_CODE_A:
                o2 = e2.CODE_CODE_A;
                break;
              case e2.CODE_CODE_C:
                o2 = e2.CODE_CODE_C;
                break;
              case e2.CODE_STOP:
                f3 = true;
            }
          break;
        case e2.CODE_CODE_C:
          if (w2 < 100)
            w2 < 10 && (l2 += "0"), l2 += w2;
          else
            switch (w2 !== e2.CODE_STOP && (A2 = false), w2) {
              case e2.CODE_FNC_1:
                i2 && (0 === l2.length ? l2 += "]C1" : l2 += String.fromCharCode(29));
                break;
              case e2.CODE_CODE_A:
                o2 = e2.CODE_CODE_A;
                break;
              case e2.CODE_CODE_B:
                o2 = e2.CODE_CODE_B;
                break;
              case e2.CODE_STOP:
                f3 = true;
            }
      }
      E2 && (o2 = o2 === e2.CODE_CODE_A ? e2.CODE_CODE_B : e2.CODE_CODE_A);
    }
    var I2 = p2 - d2;
    if (p2 = r2.getNextUnset(p2), !r2.isRange(p2, Math.min(r2.getSize(), p2 + (p2 - d2) / 2), false))
      throw new tt();
    if ((v2 -= _2 * y2) % 103 !== y2)
      throw new R();
    var S2 = l2.length;
    if (0 === S2)
      throw new tt();
    S2 > 0 && A2 && (l2 = o2 === e2.CODE_CODE_C ? l2.substring(0, S2 - 2) : l2.substring(0, S2 - 1));
    for (var T2 = (a2[1] + a2[0]) / 2, O2 = d2 + I2 / 2, b2 = c2.length, N10 = new Uint8Array(b2), D2 = 0; D2 < b2; D2++)
      N10[D2] = c2[D2];
    var M2 = [new Lt(T2, t3), new Lt(O2, t3)];
    return new gt(l2, N10, 0, M2, wt.CODE_128, (/* @__PURE__ */ new Date()).getTime());
  }, e2.CODE_PATTERNS = [Int32Array.from([2, 1, 2, 2, 2, 2]), Int32Array.from([2, 2, 2, 1, 2, 2]), Int32Array.from([2, 2, 2, 2, 2, 1]), Int32Array.from([1, 2, 1, 2, 2, 3]), Int32Array.from([1, 2, 1, 3, 2, 2]), Int32Array.from([1, 3, 1, 2, 2, 2]), Int32Array.from([1, 2, 2, 2, 1, 3]), Int32Array.from([1, 2, 2, 3, 1, 2]), Int32Array.from([1, 3, 2, 2, 1, 2]), Int32Array.from([2, 2, 1, 2, 1, 3]), Int32Array.from([2, 2, 1, 3, 1, 2]), Int32Array.from([2, 3, 1, 2, 1, 2]), Int32Array.from([1, 1, 2, 2, 3, 2]), Int32Array.from([1, 2, 2, 1, 3, 2]), Int32Array.from([1, 2, 2, 2, 3, 1]), Int32Array.from([1, 1, 3, 2, 2, 2]), Int32Array.from([1, 2, 3, 1, 2, 2]), Int32Array.from([1, 2, 3, 2, 2, 1]), Int32Array.from([2, 2, 3, 2, 1, 1]), Int32Array.from([2, 2, 1, 1, 3, 2]), Int32Array.from([2, 2, 1, 2, 3, 1]), Int32Array.from([2, 1, 3, 2, 1, 2]), Int32Array.from([2, 2, 3, 1, 1, 2]), Int32Array.from([3, 1, 2, 1, 3, 1]), Int32Array.from([3, 1, 1, 2, 2, 2]), Int32Array.from([3, 2, 1, 1, 2, 2]), Int32Array.from([3, 2, 1, 2, 2, 1]), Int32Array.from([3, 1, 2, 2, 1, 2]), Int32Array.from([3, 2, 2, 1, 1, 2]), Int32Array.from([3, 2, 2, 2, 1, 1]), Int32Array.from([2, 1, 2, 1, 2, 3]), Int32Array.from([2, 1, 2, 3, 2, 1]), Int32Array.from([2, 3, 2, 1, 2, 1]), Int32Array.from([1, 1, 1, 3, 2, 3]), Int32Array.from([1, 3, 1, 1, 2, 3]), Int32Array.from([1, 3, 1, 3, 2, 1]), Int32Array.from([1, 1, 2, 3, 1, 3]), Int32Array.from([1, 3, 2, 1, 1, 3]), Int32Array.from([1, 3, 2, 3, 1, 1]), Int32Array.from([2, 1, 1, 3, 1, 3]), Int32Array.from([2, 3, 1, 1, 1, 3]), Int32Array.from([2, 3, 1, 3, 1, 1]), Int32Array.from([1, 1, 2, 1, 3, 3]), Int32Array.from([1, 1, 2, 3, 3, 1]), Int32Array.from([1, 3, 2, 1, 3, 1]), Int32Array.from([1, 1, 3, 1, 2, 3]), Int32Array.from([1, 1, 3, 3, 2, 1]), Int32Array.from([1, 3, 3, 1, 2, 1]), Int32Array.from([3, 1, 3, 1, 2, 1]), Int32Array.from([2, 1, 1, 3, 3, 1]), Int32Array.from([2, 3, 1, 1, 3, 1]), Int32Array.from([2, 1, 3, 1, 1, 3]), Int32Array.from([2, 1, 3, 3, 1, 1]), Int32Array.from([2, 1, 3, 1, 3, 1]), Int32Array.from([3, 1, 1, 1, 2, 3]), Int32Array.from([3, 1, 1, 3, 2, 1]), Int32Array.from([3, 3, 1, 1, 2, 1]), Int32Array.from([3, 1, 2, 1, 1, 3]), Int32Array.from([3, 1, 2, 3, 1, 1]), Int32Array.from([3, 3, 2, 1, 1, 1]), Int32Array.from([3, 1, 4, 1, 1, 1]), Int32Array.from([2, 2, 1, 4, 1, 1]), Int32Array.from([4, 3, 1, 1, 1, 1]), Int32Array.from([1, 1, 1, 2, 2, 4]), Int32Array.from([1, 1, 1, 4, 2, 2]), Int32Array.from([1, 2, 1, 1, 2, 4]), Int32Array.from([1, 2, 1, 4, 2, 1]), Int32Array.from([1, 4, 1, 1, 2, 2]), Int32Array.from([1, 4, 1, 2, 2, 1]), Int32Array.from([1, 1, 2, 2, 1, 4]), Int32Array.from([1, 1, 2, 4, 1, 2]), Int32Array.from([1, 2, 2, 1, 1, 4]), Int32Array.from([1, 2, 2, 4, 1, 1]), Int32Array.from([1, 4, 2, 1, 1, 2]), Int32Array.from([1, 4, 2, 2, 1, 1]), Int32Array.from([2, 4, 1, 2, 1, 1]), Int32Array.from([2, 2, 1, 1, 1, 4]), Int32Array.from([4, 1, 3, 1, 1, 1]), Int32Array.from([2, 4, 1, 1, 1, 2]), Int32Array.from([1, 3, 4, 1, 1, 1]), Int32Array.from([1, 1, 1, 2, 4, 2]), Int32Array.from([1, 2, 1, 1, 4, 2]), Int32Array.from([1, 2, 1, 2, 4, 1]), Int32Array.from([1, 1, 4, 2, 1, 2]), Int32Array.from([1, 2, 4, 1, 1, 2]), Int32Array.from([1, 2, 4, 2, 1, 1]), Int32Array.from([4, 1, 1, 2, 1, 2]), Int32Array.from([4, 2, 1, 1, 1, 2]), Int32Array.from([4, 2, 1, 2, 1, 1]), Int32Array.from([2, 1, 2, 1, 4, 1]), Int32Array.from([2, 1, 4, 1, 2, 1]), Int32Array.from([4, 1, 2, 1, 2, 1]), Int32Array.from([1, 1, 1, 1, 4, 3]), Int32Array.from([1, 1, 1, 3, 4, 1]), Int32Array.from([1, 3, 1, 1, 4, 1]), Int32Array.from([1, 1, 4, 1, 1, 3]), Int32Array.from([1, 1, 4, 3, 1, 1]), Int32Array.from([4, 1, 1, 1, 1, 3]), Int32Array.from([4, 1, 1, 3, 1, 1]), Int32Array.from([1, 1, 3, 1, 4, 1]), Int32Array.from([1, 1, 4, 1, 3, 1]), Int32Array.from([3, 1, 1, 1, 4, 1]), Int32Array.from([4, 1, 1, 1, 3, 1]), Int32Array.from([2, 1, 1, 4, 1, 2]), Int32Array.from([2, 1, 1, 2, 1, 4]), Int32Array.from([2, 1, 1, 2, 3, 2]), Int32Array.from([2, 3, 3, 1, 1, 1, 2])], e2.MAX_AVG_VARIANCE = 0.25, e2.MAX_INDIVIDUAL_VARIANCE = 0.7, e2.CODE_SHIFT = 98, e2.CODE_CODE_C = 99, e2.CODE_CODE_B = 100, e2.CODE_CODE_A = 101, e2.CODE_FNC_1 = 102, e2.CODE_FNC_2 = 97, e2.CODE_FNC_3 = 96, e2.CODE_FNC_4_A = 101, e2.CODE_FNC_4_B = 100, e2.CODE_START_A = 103, e2.CODE_START_B = 104, e2.CODE_START_C = 105, e2.CODE_STOP = 106, e2;
}(Kt);
var Jt = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var $t = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var te = function(t2) {
  function e2(e3, r2) {
    void 0 === e3 && (e3 = false), void 0 === r2 && (r2 = false);
    var n2 = t2.call(this) || this;
    return n2.usingCheckDigit = e3, n2.extendedMode = r2, n2.decodeRowResult = "", n2.counters = new Int32Array(9), n2;
  }
  return Jt(e2, t2), e2.prototype.decodeRow = function(t3, r2, n2) {
    var o2, i2, a2, s2, u2 = this.counters;
    u2.fill(0), this.decodeRowResult = "";
    var c2, f3, h2 = e2.findAsteriskPattern(r2, u2), l2 = r2.getNextSet(h2[1]), d2 = r2.getSize();
    do {
      e2.recordPattern(r2, l2, u2);
      var p2 = e2.toNarrowWidePattern(u2);
      if (p2 < 0)
        throw new tt();
      c2 = e2.patternToChar(p2), this.decodeRowResult += c2, f3 = l2;
      try {
        for (var g2 = (o2 = void 0, $t(u2)), y2 = g2.next(); !y2.done; y2 = g2.next()) {
          l2 += y2.value;
        }
      } catch (t4) {
        o2 = { error: t4 };
      } finally {
        try {
          y2 && !y2.done && (i2 = g2.return) && i2.call(g2);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
      l2 = r2.getNextSet(l2);
    } while ("*" !== c2);
    this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
    var w2, v2 = 0;
    try {
      for (var _2 = $t(u2), A2 = _2.next(); !A2.done; A2 = _2.next()) {
        v2 += A2.value;
      }
    } catch (t4) {
      a2 = { error: t4 };
    } finally {
      try {
        A2 && !A2.done && (s2 = _2.return) && s2.call(_2);
      } finally {
        if (a2)
          throw a2.error;
      }
    }
    if (l2 !== d2 && 2 * (l2 - f3 - v2) < v2)
      throw new tt();
    if (this.usingCheckDigit) {
      for (var C2 = this.decodeRowResult.length - 1, m2 = 0, E2 = 0; E2 < C2; E2++)
        m2 += e2.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(E2));
      if (this.decodeRowResult.charAt(C2) !== e2.ALPHABET_STRING.charAt(m2 % 43))
        throw new R();
      this.decodeRowResult = this.decodeRowResult.substring(0, C2);
    }
    if (0 === this.decodeRowResult.length)
      throw new tt();
    w2 = this.extendedMode ? e2.decodeExtended(this.decodeRowResult) : this.decodeRowResult;
    var I2 = (h2[1] + h2[0]) / 2, S2 = f3 + v2 / 2;
    return new gt(w2, null, 0, [new Lt(I2, t3), new Lt(S2, t3)], wt.CODE_39, (/* @__PURE__ */ new Date()).getTime());
  }, e2.findAsteriskPattern = function(t3, r2) {
    for (var n2 = t3.getSize(), o2 = t3.getNextSet(0), i2 = 0, a2 = o2, s2 = false, u2 = r2.length, c2 = o2; c2 < n2; c2++)
      if (t3.get(c2) !== s2)
        r2[i2]++;
      else {
        if (i2 === u2 - 1) {
          if (this.toNarrowWidePattern(r2) === e2.ASTERISK_ENCODING && t3.isRange(Math.max(0, a2 - Math.floor((c2 - a2) / 2)), a2, false))
            return [a2, c2];
          a2 += r2[0] + r2[1], r2.copyWithin(0, 2, 2 + i2 - 1), r2[i2 - 1] = 0, r2[i2] = 0, i2--;
        } else
          i2++;
        r2[i2] = 1, s2 = !s2;
      }
    throw new tt();
  }, e2.toNarrowWidePattern = function(t3) {
    var e3, r2, n2, o2 = t3.length, i2 = 0;
    do {
      var a2 = 2147483647;
      try {
        for (var s2 = (e3 = void 0, $t(t3)), u2 = s2.next(); !u2.done; u2 = s2.next()) {
          (l2 = u2.value) < a2 && l2 > i2 && (a2 = l2);
        }
      } catch (t4) {
        e3 = { error: t4 };
      } finally {
        try {
          u2 && !u2.done && (r2 = s2.return) && r2.call(s2);
        } finally {
          if (e3)
            throw e3.error;
        }
      }
      i2 = a2, n2 = 0;
      for (var c2 = 0, f3 = 0, h2 = 0; h2 < o2; h2++) {
        (l2 = t3[h2]) > i2 && (f3 |= 1 << o2 - 1 - h2, n2++, c2 += l2);
      }
      if (3 === n2) {
        for (h2 = 0; h2 < o2 && n2 > 0; h2++) {
          var l2;
          if ((l2 = t3[h2]) > i2 && (n2--, 2 * l2 >= c2))
            return -1;
        }
        return f3;
      }
    } while (n2 > 3);
    return -1;
  }, e2.patternToChar = function(t3) {
    for (var r2 = 0; r2 < e2.CHARACTER_ENCODINGS.length; r2++)
      if (e2.CHARACTER_ENCODINGS[r2] === t3)
        return e2.ALPHABET_STRING.charAt(r2);
    if (t3 === e2.ASTERISK_ENCODING)
      return "*";
    throw new tt();
  }, e2.decodeExtended = function(t3) {
    for (var e3 = t3.length, r2 = "", n2 = 0; n2 < e3; n2++) {
      var o2 = t3.charAt(n2);
      if ("+" === o2 || "$" === o2 || "%" === o2 || "/" === o2) {
        var i2 = t3.charAt(n2 + 1), a2 = "\0";
        switch (o2) {
          case "+":
            if (!(i2 >= "A" && i2 <= "Z"))
              throw new G();
            a2 = String.fromCharCode(i2.charCodeAt(0) + 32);
            break;
          case "$":
            if (!(i2 >= "A" && i2 <= "Z"))
              throw new G();
            a2 = String.fromCharCode(i2.charCodeAt(0) - 64);
            break;
          case "%":
            if (i2 >= "A" && i2 <= "E")
              a2 = String.fromCharCode(i2.charCodeAt(0) - 38);
            else if (i2 >= "F" && i2 <= "J")
              a2 = String.fromCharCode(i2.charCodeAt(0) - 11);
            else if (i2 >= "K" && i2 <= "O")
              a2 = String.fromCharCode(i2.charCodeAt(0) + 16);
            else if (i2 >= "P" && i2 <= "T")
              a2 = String.fromCharCode(i2.charCodeAt(0) + 43);
            else if ("U" === i2)
              a2 = "\0";
            else if ("V" === i2)
              a2 = "@";
            else if ("W" === i2)
              a2 = "`";
            else {
              if ("X" !== i2 && "Y" !== i2 && "Z" !== i2)
                throw new G();
              a2 = "\x7F";
            }
            break;
          case "/":
            if (i2 >= "A" && i2 <= "O")
              a2 = String.fromCharCode(i2.charCodeAt(0) - 32);
            else {
              if ("Z" !== i2)
                throw new G();
              a2 = ":";
            }
        }
        r2 += a2, n2++;
      } else
        r2 += o2;
    }
    return r2;
  }, e2.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%", e2.CHARACTER_ENCODINGS = [52, 289, 97, 352, 49, 304, 112, 37, 292, 100, 265, 73, 328, 25, 280, 88, 13, 268, 76, 28, 259, 67, 322, 19, 274, 82, 7, 262, 70, 22, 385, 193, 448, 145, 400, 208, 133, 388, 196, 168, 162, 138, 42], e2.ASTERISK_ENCODING = 148, e2;
}(Kt);
var ee = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var re = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ne = function(t2) {
  function e2() {
    var e3 = t2.call(this) || this;
    return e3.decodeRowResult = "", e3.counters = new Int32Array(6), e3;
  }
  return ee(e2, t2), e2.prototype.decodeRow = function(t3, r2, n2) {
    var o2, i2, a2, s2, u2, c2, f3 = this.findAsteriskPattern(r2), h2 = r2.getNextSet(f3[1]), l2 = r2.getSize(), d2 = this.counters;
    d2.fill(0), this.decodeRowResult = "";
    do {
      e2.recordPattern(r2, h2, d2);
      var p2 = this.toPattern(d2);
      if (p2 < 0)
        throw new tt();
      u2 = this.patternToChar(p2), this.decodeRowResult += u2, c2 = h2;
      try {
        for (var g2 = (o2 = void 0, re(d2)), y2 = g2.next(); !y2.done; y2 = g2.next()) {
          h2 += y2.value;
        }
      } catch (t4) {
        o2 = { error: t4 };
      } finally {
        try {
          y2 && !y2.done && (i2 = g2.return) && i2.call(g2);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
      h2 = r2.getNextSet(h2);
    } while ("*" !== u2);
    this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
    var w2 = 0;
    try {
      for (var v2 = re(d2), _2 = v2.next(); !_2.done; _2 = v2.next()) {
        w2 += _2.value;
      }
    } catch (t4) {
      a2 = { error: t4 };
    } finally {
      try {
        _2 && !_2.done && (s2 = v2.return) && s2.call(v2);
      } finally {
        if (a2)
          throw a2.error;
      }
    }
    if (h2 === l2 || !r2.get(h2))
      throw new tt();
    if (this.decodeRowResult.length < 2)
      throw new tt();
    this.checkChecksums(this.decodeRowResult), this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 2);
    var A2 = this.decodeExtended(this.decodeRowResult), C2 = (f3[1] + f3[0]) / 2, m2 = c2 + w2 / 2;
    return new gt(A2, null, 0, [new Lt(C2, t3), new Lt(m2, t3)], wt.CODE_93, (/* @__PURE__ */ new Date()).getTime());
  }, e2.prototype.findAsteriskPattern = function(t3) {
    var r2 = t3.getSize(), n2 = t3.getNextSet(0);
    this.counters.fill(0);
    for (var o2 = this.counters, i2 = n2, a2 = false, s2 = o2.length, u2 = 0, c2 = n2; c2 < r2; c2++)
      if (t3.get(c2) !== a2)
        o2[u2]++;
      else {
        if (u2 === s2 - 1) {
          if (this.toPattern(o2) === e2.ASTERISK_ENCODING)
            return new Int32Array([i2, c2]);
          i2 += o2[0] + o2[1], o2.copyWithin(0, 2, 2 + u2 - 1), o2[u2 - 1] = 0, o2[u2] = 0, u2--;
        } else
          u2++;
        o2[u2] = 1, a2 = !a2;
      }
    throw new tt();
  }, e2.prototype.toPattern = function(t3) {
    var e3, r2, n2 = 0;
    try {
      for (var o2 = re(t3), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        n2 += i2.value;
      }
    } catch (t4) {
      e3 = { error: t4 };
    } finally {
      try {
        i2 && !i2.done && (r2 = o2.return) && r2.call(o2);
      } finally {
        if (e3)
          throw e3.error;
      }
    }
    for (var a2 = 0, s2 = t3.length, u2 = 0; u2 < s2; u2++) {
      var c2 = Math.round(9 * t3[u2] / n2);
      if (c2 < 1 || c2 > 4)
        return -1;
      if (0 == (1 & u2))
        for (var f3 = 0; f3 < c2; f3++)
          a2 = a2 << 1 | 1;
      else
        a2 <<= c2;
    }
    return a2;
  }, e2.prototype.patternToChar = function(t3) {
    for (var r2 = 0; r2 < e2.CHARACTER_ENCODINGS.length; r2++)
      if (e2.CHARACTER_ENCODINGS[r2] === t3)
        return e2.ALPHABET_STRING.charAt(r2);
    throw new tt();
  }, e2.prototype.decodeExtended = function(t3) {
    for (var e3 = t3.length, r2 = "", n2 = 0; n2 < e3; n2++) {
      var o2 = t3.charAt(n2);
      if (o2 >= "a" && o2 <= "d") {
        if (n2 >= e3 - 1)
          throw new G();
        var i2 = t3.charAt(n2 + 1), a2 = "\0";
        switch (o2) {
          case "d":
            if (!(i2 >= "A" && i2 <= "Z"))
              throw new G();
            a2 = String.fromCharCode(i2.charCodeAt(0) + 32);
            break;
          case "a":
            if (!(i2 >= "A" && i2 <= "Z"))
              throw new G();
            a2 = String.fromCharCode(i2.charCodeAt(0) - 64);
            break;
          case "b":
            if (i2 >= "A" && i2 <= "E")
              a2 = String.fromCharCode(i2.charCodeAt(0) - 38);
            else if (i2 >= "F" && i2 <= "J")
              a2 = String.fromCharCode(i2.charCodeAt(0) - 11);
            else if (i2 >= "K" && i2 <= "O")
              a2 = String.fromCharCode(i2.charCodeAt(0) + 16);
            else if (i2 >= "P" && i2 <= "T")
              a2 = String.fromCharCode(i2.charCodeAt(0) + 43);
            else if ("U" === i2)
              a2 = "\0";
            else if ("V" === i2)
              a2 = "@";
            else if ("W" === i2)
              a2 = "`";
            else {
              if (!(i2 >= "X" && i2 <= "Z"))
                throw new G();
              a2 = String.fromCharCode(127);
            }
            break;
          case "c":
            if (i2 >= "A" && i2 <= "O")
              a2 = String.fromCharCode(i2.charCodeAt(0) - 32);
            else {
              if ("Z" !== i2)
                throw new G();
              a2 = ":";
            }
        }
        r2 += a2, n2++;
      } else
        r2 += o2;
    }
    return r2;
  }, e2.prototype.checkChecksums = function(t3) {
    var e3 = t3.length;
    this.checkOneChecksum(t3, e3 - 2, 20), this.checkOneChecksum(t3, e3 - 1, 15);
  }, e2.prototype.checkOneChecksum = function(t3, r2, n2) {
    for (var o2 = 1, i2 = 0, a2 = r2 - 1; a2 >= 0; a2--)
      i2 += o2 * e2.ALPHABET_STRING.indexOf(t3.charAt(a2)), ++o2 > n2 && (o2 = 1);
    if (t3.charAt(r2) !== e2.ALPHABET_STRING[i2 % 47])
      throw new R();
  }, e2.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*", e2.CHARACTER_ENCODINGS = [276, 328, 324, 322, 296, 292, 290, 336, 274, 266, 424, 420, 418, 404, 402, 394, 360, 356, 354, 308, 282, 344, 332, 326, 300, 278, 436, 434, 428, 422, 406, 410, 364, 358, 310, 314, 302, 468, 466, 458, 366, 374, 430, 294, 474, 470, 306, 350], e2.ASTERISK_ENCODING = e2.CHARACTER_ENCODINGS[47], e2;
}(Kt);
var oe = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ie = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ae = function(t2) {
  function e2() {
    var e3 = null !== t2 && t2.apply(this, arguments) || this;
    return e3.narrowLineWidth = -1, e3;
  }
  return oe(e2, t2), e2.prototype.decodeRow = function(t3, r2, n2) {
    var o2, i2, a2 = this.decodeStart(r2), s2 = this.decodeEnd(r2), u2 = new Q();
    e2.decodeMiddle(r2, a2[1], s2[0], u2);
    var c2 = u2.toString(), f3 = null;
    null != n2 && (f3 = n2.get(U.ALLOWED_LENGTHS)), null == f3 && (f3 = e2.DEFAULT_ALLOWED_LENGTHS);
    var h2 = c2.length, l2 = false, d2 = 0;
    try {
      for (var p2 = ie(f3), g2 = p2.next(); !g2.done; g2 = p2.next()) {
        var y2 = g2.value;
        if (h2 === y2) {
          l2 = true;
          break;
        }
        y2 > d2 && (d2 = y2);
      }
    } catch (t4) {
      o2 = { error: t4 };
    } finally {
      try {
        g2 && !g2.done && (i2 = p2.return) && i2.call(p2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    if (!l2 && h2 > d2 && (l2 = true), !l2)
      throw new G();
    var w2 = [new Lt(a2[1], t3), new Lt(s2[0], t3)];
    return new gt(c2, null, 0, w2, wt.ITF, (/* @__PURE__ */ new Date()).getTime());
  }, e2.decodeMiddle = function(t3, r2, n2, o2) {
    var i2 = new Int32Array(10), a2 = new Int32Array(5), s2 = new Int32Array(5);
    for (i2.fill(0), a2.fill(0), s2.fill(0); r2 < n2; ) {
      Kt.recordPattern(t3, r2, i2);
      for (var u2 = 0; u2 < 5; u2++) {
        var c2 = 2 * u2;
        a2[u2] = i2[c2], s2[u2] = i2[c2 + 1];
      }
      var f3 = e2.decodeDigit(a2);
      o2.append(f3.toString()), f3 = this.decodeDigit(s2), o2.append(f3.toString()), i2.forEach(function(t4) {
        r2 += t4;
      });
    }
  }, e2.prototype.decodeStart = function(t3) {
    var r2 = e2.skipWhiteSpace(t3), n2 = e2.findGuardPattern(t3, r2, e2.START_PATTERN);
    return this.narrowLineWidth = (n2[1] - n2[0]) / 4, this.validateQuietZone(t3, n2[0]), n2;
  }, e2.prototype.validateQuietZone = function(t3, e3) {
    var r2 = 10 * this.narrowLineWidth;
    r2 = r2 < e3 ? r2 : e3;
    for (var n2 = e3 - 1; r2 > 0 && n2 >= 0 && !t3.get(n2); n2--)
      r2--;
    if (0 !== r2)
      throw new tt();
  }, e2.skipWhiteSpace = function(t3) {
    var e3 = t3.getSize(), r2 = t3.getNextSet(0);
    if (r2 === e3)
      throw new tt();
    return r2;
  }, e2.prototype.decodeEnd = function(t3) {
    t3.reverse();
    try {
      var r2 = e2.skipWhiteSpace(t3), n2 = void 0;
      try {
        n2 = e2.findGuardPattern(t3, r2, e2.END_PATTERN_REVERSED[0]);
      } catch (o3) {
        o3 instanceof tt && (n2 = e2.findGuardPattern(t3, r2, e2.END_PATTERN_REVERSED[1]));
      }
      this.validateQuietZone(t3, n2[0]);
      var o2 = n2[0];
      return n2[0] = t3.getSize() - n2[1], n2[1] = t3.getSize() - o2, n2;
    } finally {
      t3.reverse();
    }
  }, e2.findGuardPattern = function(t3, r2, n2) {
    var o2 = n2.length, i2 = new Int32Array(o2), a2 = t3.getSize(), s2 = false, u2 = 0, c2 = r2;
    i2.fill(0);
    for (var f3 = r2; f3 < a2; f3++)
      if (t3.get(f3) !== s2)
        i2[u2]++;
      else {
        if (u2 === o2 - 1) {
          if (Kt.patternMatchVariance(i2, n2, e2.MAX_INDIVIDUAL_VARIANCE) < e2.MAX_AVG_VARIANCE)
            return [c2, f3];
          c2 += i2[0] + i2[1], D.arraycopy(i2, 2, i2, 0, u2 - 1), i2[u2 - 1] = 0, i2[u2] = 0, u2--;
        } else
          u2++;
        i2[u2] = 1, s2 = !s2;
      }
    throw new tt();
  }, e2.decodeDigit = function(t3) {
    for (var r2 = e2.MAX_AVG_VARIANCE, n2 = -1, o2 = e2.PATTERNS.length, i2 = 0; i2 < o2; i2++) {
      var a2 = e2.PATTERNS[i2], s2 = Kt.patternMatchVariance(t3, a2, e2.MAX_INDIVIDUAL_VARIANCE);
      s2 < r2 ? (r2 = s2, n2 = i2) : s2 === r2 && (n2 = -1);
    }
    if (n2 >= 0)
      return n2 % 10;
    throw new tt();
  }, e2.PATTERNS = [Int32Array.from([1, 1, 2, 2, 1]), Int32Array.from([2, 1, 1, 1, 2]), Int32Array.from([1, 2, 1, 1, 2]), Int32Array.from([2, 2, 1, 1, 1]), Int32Array.from([1, 1, 2, 1, 2]), Int32Array.from([2, 1, 2, 1, 1]), Int32Array.from([1, 2, 2, 1, 1]), Int32Array.from([1, 1, 1, 2, 2]), Int32Array.from([2, 1, 1, 2, 1]), Int32Array.from([1, 2, 1, 2, 1]), Int32Array.from([1, 1, 3, 3, 1]), Int32Array.from([3, 1, 1, 1, 3]), Int32Array.from([1, 3, 1, 1, 3]), Int32Array.from([3, 3, 1, 1, 1]), Int32Array.from([1, 1, 3, 1, 3]), Int32Array.from([3, 1, 3, 1, 1]), Int32Array.from([1, 3, 3, 1, 1]), Int32Array.from([1, 1, 1, 3, 3]), Int32Array.from([3, 1, 1, 3, 1]), Int32Array.from([1, 3, 1, 3, 1])], e2.MAX_AVG_VARIANCE = 0.38, e2.MAX_INDIVIDUAL_VARIANCE = 0.5, e2.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14], e2.START_PATTERN = Int32Array.from([1, 1, 1, 1]), e2.END_PATTERN_REVERSED = [Int32Array.from([1, 1, 2]), Int32Array.from([1, 1, 3])], e2;
}(Kt);
var se = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ue = function(t2) {
  function e2() {
    var e3 = null !== t2 && t2.apply(this, arguments) || this;
    return e3.decodeRowStringBuffer = "", e3;
  }
  return se(e2, t2), e2.findStartGuardPattern = function(t3) {
    for (var r2, n2 = false, o2 = 0, i2 = Int32Array.from([0, 0, 0]); !n2; ) {
      i2 = Int32Array.from([0, 0, 0]);
      var a2 = (r2 = e2.findGuardPattern(t3, o2, false, this.START_END_PATTERN, i2))[0], s2 = a2 - ((o2 = r2[1]) - a2);
      s2 >= 0 && (n2 = t3.isRange(s2, a2, false));
    }
    return r2;
  }, e2.checkChecksum = function(t3) {
    return e2.checkStandardUPCEANChecksum(t3);
  }, e2.checkStandardUPCEANChecksum = function(t3) {
    var r2 = t3.length;
    if (0 === r2)
      return false;
    var n2 = parseInt(t3.charAt(r2 - 1), 10);
    return e2.getStandardUPCEANChecksum(t3.substring(0, r2 - 1)) === n2;
  }, e2.getStandardUPCEANChecksum = function(t3) {
    for (var e3 = t3.length, r2 = 0, n2 = e3 - 1; n2 >= 0; n2 -= 2) {
      if ((o2 = t3.charAt(n2).charCodeAt(0) - "0".charCodeAt(0)) < 0 || o2 > 9)
        throw new G();
      r2 += o2;
    }
    r2 *= 3;
    for (n2 = e3 - 2; n2 >= 0; n2 -= 2) {
      var o2;
      if ((o2 = t3.charAt(n2).charCodeAt(0) - "0".charCodeAt(0)) < 0 || o2 > 9)
        throw new G();
      r2 += o2;
    }
    return (1e3 - r2) % 10;
  }, e2.decodeEnd = function(t3, r2) {
    return e2.findGuardPattern(t3, r2, false, e2.START_END_PATTERN, new Int32Array(e2.START_END_PATTERN.length).fill(0));
  }, e2.findGuardPatternWithoutCounters = function(t3, e3, r2, n2) {
    return this.findGuardPattern(t3, e3, r2, n2, new Int32Array(n2.length));
  }, e2.findGuardPattern = function(t3, r2, n2, o2, i2) {
    for (var a2 = t3.getSize(), s2 = 0, u2 = r2 = n2 ? t3.getNextUnset(r2) : t3.getNextSet(r2), c2 = o2.length, f3 = n2, h2 = r2; h2 < a2; h2++)
      if (t3.get(h2) !== f3)
        i2[s2]++;
      else {
        if (s2 === c2 - 1) {
          if (Kt.patternMatchVariance(i2, o2, e2.MAX_INDIVIDUAL_VARIANCE) < e2.MAX_AVG_VARIANCE)
            return Int32Array.from([u2, h2]);
          u2 += i2[0] + i2[1];
          for (var l2 = i2.slice(2, i2.length), d2 = 0; d2 < s2 - 1; d2++)
            i2[d2] = l2[d2];
          i2[s2 - 1] = 0, i2[s2] = 0, s2--;
        } else
          s2++;
        i2[s2] = 1, f3 = !f3;
      }
    throw new tt();
  }, e2.decodeDigit = function(t3, r2, n2, o2) {
    this.recordPattern(t3, n2, r2);
    for (var i2 = this.MAX_AVG_VARIANCE, a2 = -1, s2 = o2.length, u2 = 0; u2 < s2; u2++) {
      var c2 = o2[u2], f3 = Kt.patternMatchVariance(r2, c2, e2.MAX_INDIVIDUAL_VARIANCE);
      f3 < i2 && (i2 = f3, a2 = u2);
    }
    if (a2 >= 0)
      return a2;
    throw new tt();
  }, e2.MAX_AVG_VARIANCE = 0.48, e2.MAX_INDIVIDUAL_VARIANCE = 0.7, e2.START_END_PATTERN = Int32Array.from([1, 1, 1]), e2.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]), e2.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]), e2.L_PATTERNS = [Int32Array.from([3, 2, 1, 1]), Int32Array.from([2, 2, 2, 1]), Int32Array.from([2, 1, 2, 2]), Int32Array.from([1, 4, 1, 1]), Int32Array.from([1, 1, 3, 2]), Int32Array.from([1, 2, 3, 1]), Int32Array.from([1, 1, 1, 4]), Int32Array.from([1, 3, 1, 2]), Int32Array.from([1, 2, 1, 3]), Int32Array.from([3, 1, 1, 2])], e2;
}(Kt);
var ce = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var fe = function() {
  function t2() {
    this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5], this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]), this.decodeRowStringBuffer = "";
  }
  return t2.prototype.decodeRow = function(e2, r2, n2) {
    var o2 = this.decodeRowStringBuffer, i2 = this.decodeMiddle(r2, n2, o2), a2 = o2.toString(), s2 = t2.parseExtensionString(a2), u2 = [new Lt((n2[0] + n2[1]) / 2, e2), new Lt(i2, e2)], c2 = new gt(a2, null, 0, u2, wt.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
    return null != s2 && c2.putAllMetadata(s2), c2;
  }, t2.prototype.decodeMiddle = function(e2, r2, n2) {
    var o2, i2, a2 = this.decodeMiddleCounters;
    a2[0] = 0, a2[1] = 0, a2[2] = 0, a2[3] = 0;
    for (var s2 = e2.getSize(), u2 = r2[1], c2 = 0, f3 = 0; f3 < 5 && u2 < s2; f3++) {
      var h2 = ue.decodeDigit(e2, a2, u2, ue.L_AND_G_PATTERNS);
      n2 += String.fromCharCode("0".charCodeAt(0) + h2 % 10);
      try {
        for (var l2 = (o2 = void 0, ce(a2)), d2 = l2.next(); !d2.done; d2 = l2.next()) {
          u2 += d2.value;
        }
      } catch (t3) {
        o2 = { error: t3 };
      } finally {
        try {
          d2 && !d2.done && (i2 = l2.return) && i2.call(l2);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
      h2 >= 10 && (c2 |= 1 << 4 - f3), 4 !== f3 && (u2 = e2.getNextSet(u2), u2 = e2.getNextUnset(u2));
    }
    if (5 !== n2.length)
      throw new tt();
    var p2 = this.determineCheckDigit(c2);
    if (t2.extensionChecksum(n2.toString()) !== p2)
      throw new tt();
    return u2;
  }, t2.extensionChecksum = function(t3) {
    for (var e2 = t3.length, r2 = 0, n2 = e2 - 2; n2 >= 0; n2 -= 2)
      r2 += t3.charAt(n2).charCodeAt(0) - "0".charCodeAt(0);
    r2 *= 3;
    for (n2 = e2 - 1; n2 >= 0; n2 -= 2)
      r2 += t3.charAt(n2).charCodeAt(0) - "0".charCodeAt(0);
    return (r2 *= 3) % 10;
  }, t2.prototype.determineCheckDigit = function(t3) {
    for (var e2 = 0; e2 < 10; e2++)
      if (t3 === this.CHECK_DIGIT_ENCODINGS[e2])
        return e2;
    throw new tt();
  }, t2.parseExtensionString = function(e2) {
    if (5 !== e2.length)
      return null;
    var r2 = t2.parseExtension5String(e2);
    return null == r2 ? null : /* @__PURE__ */ new Map([[_t.SUGGESTED_PRICE, r2]]);
  }, t2.parseExtension5String = function(t3) {
    var e2;
    switch (t3.charAt(0)) {
      case "0":
        e2 = "\xA3";
        break;
      case "5":
        e2 = "$";
        break;
      case "9":
        switch (t3) {
          case "90000":
            return null;
          case "99991":
            return "0.00";
          case "99990":
            return "Used";
        }
        e2 = "";
        break;
      default:
        e2 = "";
    }
    var r2 = parseInt(t3.substring(1)), n2 = r2 % 100;
    return e2 + (r2 / 100).toString() + "." + (n2 < 10 ? "0" + n2 : n2.toString());
  }, t2;
}();
var he = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var le = function() {
  function t2() {
    this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]), this.decodeRowStringBuffer = "";
  }
  return t2.prototype.decodeRow = function(e2, r2, n2) {
    var o2 = this.decodeRowStringBuffer, i2 = this.decodeMiddle(r2, n2, o2), a2 = o2.toString(), s2 = t2.parseExtensionString(a2), u2 = [new Lt((n2[0] + n2[1]) / 2, e2), new Lt(i2, e2)], c2 = new gt(a2, null, 0, u2, wt.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
    return null != s2 && c2.putAllMetadata(s2), c2;
  }, t2.prototype.decodeMiddle = function(t3, e2, r2) {
    var n2, o2, i2 = this.decodeMiddleCounters;
    i2[0] = 0, i2[1] = 0, i2[2] = 0, i2[3] = 0;
    for (var a2 = t3.getSize(), s2 = e2[1], u2 = 0, c2 = 0; c2 < 2 && s2 < a2; c2++) {
      var f3 = ue.decodeDigit(t3, i2, s2, ue.L_AND_G_PATTERNS);
      r2 += String.fromCharCode("0".charCodeAt(0) + f3 % 10);
      try {
        for (var h2 = (n2 = void 0, he(i2)), l2 = h2.next(); !l2.done; l2 = h2.next()) {
          s2 += l2.value;
        }
      } catch (t4) {
        n2 = { error: t4 };
      } finally {
        try {
          l2 && !l2.done && (o2 = h2.return) && o2.call(h2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      f3 >= 10 && (u2 |= 1 << 1 - c2), 1 !== c2 && (s2 = t3.getNextSet(s2), s2 = t3.getNextUnset(s2));
    }
    if (2 !== r2.length)
      throw new tt();
    if (parseInt(r2.toString()) % 4 !== u2)
      throw new tt();
    return s2;
  }, t2.parseExtensionString = function(t3) {
    return 2 !== t3.length ? null : /* @__PURE__ */ new Map([[_t.ISSUE_NUMBER, parseInt(t3)]]);
  }, t2;
}();
var de = function() {
  function t2() {
  }
  return t2.decodeRow = function(t3, e2, r2) {
    var n2 = ue.findGuardPattern(e2, r2, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));
    try {
      return new fe().decodeRow(t3, e2, n2);
    } catch (r3) {
      return new le().decodeRow(t3, e2, n2);
    }
  }, t2.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]), t2;
}();
var pe = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ge = function(t2) {
  function e2() {
    var r2 = t2.call(this) || this;
    r2.decodeRowStringBuffer = "", e2.L_AND_G_PATTERNS = e2.L_PATTERNS.map(function(t3) {
      return Int32Array.from(t3);
    });
    for (var n2 = 10; n2 < 20; n2++) {
      for (var o2 = e2.L_PATTERNS[n2 - 10], i2 = new Int32Array(o2.length), a2 = 0; a2 < o2.length; a2++)
        i2[a2] = o2[o2.length - a2 - 1];
      e2.L_AND_G_PATTERNS[n2] = i2;
    }
    return r2;
  }
  return pe(e2, t2), e2.prototype.decodeRow = function(t3, r2, n2) {
    var o2 = e2.findStartGuardPattern(r2), i2 = null == n2 ? null : n2.get(U.NEED_RESULT_POINT_CALLBACK);
    if (null != i2) {
      var a2 = new Lt((o2[0] + o2[1]) / 2, t3);
      i2.foundPossibleResultPoint(a2);
    }
    var s2 = this.decodeMiddle(r2, o2, this.decodeRowStringBuffer), u2 = s2.rowOffset, c2 = s2.resultString;
    if (null != i2) {
      var f3 = new Lt(u2, t3);
      i2.foundPossibleResultPoint(f3);
    }
    var h2 = e2.decodeEnd(r2, u2);
    if (null != i2) {
      var l2 = new Lt((h2[0] + h2[1]) / 2, t3);
      i2.foundPossibleResultPoint(l2);
    }
    var d2 = h2[1], p2 = d2 + (d2 - h2[0]);
    if (p2 >= r2.getSize() || !r2.isRange(d2, p2, false))
      throw new tt();
    var g2 = c2.toString();
    if (g2.length < 8)
      throw new G();
    if (!e2.checkChecksum(g2))
      throw new R();
    var y2 = (o2[1] + o2[0]) / 2, w2 = (h2[1] + h2[0]) / 2, v2 = this.getBarcodeFormat(), _2 = [new Lt(y2, t3), new Lt(w2, t3)], A2 = new gt(g2, null, 0, _2, v2, (/* @__PURE__ */ new Date()).getTime()), C2 = 0;
    try {
      var m2 = de.decodeRow(t3, r2, h2[1]);
      A2.putMetadata(_t.UPC_EAN_EXTENSION, m2.getText()), A2.putAllMetadata(m2.getResultMetadata()), A2.addResultPoints(m2.getResultPoints()), C2 = m2.getText().length;
    } catch (t4) {
    }
    var E2 = null == n2 ? null : n2.get(U.ALLOWED_EAN_EXTENSIONS);
    if (null != E2) {
      var I2 = false;
      for (var S2 in E2)
        if (C2.toString() === S2) {
          I2 = true;
          break;
        }
      if (!I2)
        throw new tt();
    }
    return v2 === wt.EAN_13 || wt.UPC_A, A2;
  }, e2.checkChecksum = function(t3) {
    return e2.checkStandardUPCEANChecksum(t3);
  }, e2.checkStandardUPCEANChecksum = function(t3) {
    var r2 = t3.length;
    if (0 === r2)
      return false;
    var n2 = parseInt(t3.charAt(r2 - 1), 10);
    return e2.getStandardUPCEANChecksum(t3.substring(0, r2 - 1)) === n2;
  }, e2.getStandardUPCEANChecksum = function(t3) {
    for (var e3 = t3.length, r2 = 0, n2 = e3 - 1; n2 >= 0; n2 -= 2) {
      if ((o2 = t3.charAt(n2).charCodeAt(0) - "0".charCodeAt(0)) < 0 || o2 > 9)
        throw new G();
      r2 += o2;
    }
    r2 *= 3;
    for (n2 = e3 - 2; n2 >= 0; n2 -= 2) {
      var o2;
      if ((o2 = t3.charAt(n2).charCodeAt(0) - "0".charCodeAt(0)) < 0 || o2 > 9)
        throw new G();
      r2 += o2;
    }
    return (1e3 - r2) % 10;
  }, e2.decodeEnd = function(t3, r2) {
    return e2.findGuardPattern(t3, r2, false, e2.START_END_PATTERN, new Int32Array(e2.START_END_PATTERN.length).fill(0));
  }, e2;
}(ue);
var ye = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var we = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ve = function(t2) {
  function e2() {
    var e3 = t2.call(this) || this;
    return e3.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]), e3;
  }
  return ye(e2, t2), e2.prototype.decodeMiddle = function(t3, r2, n2) {
    var o2, i2, a2, s2, u2 = this.decodeMiddleCounters;
    u2[0] = 0, u2[1] = 0, u2[2] = 0, u2[3] = 0;
    for (var c2 = t3.getSize(), f3 = r2[1], h2 = 0, l2 = 0; l2 < 6 && f3 < c2; l2++) {
      var d2 = ge.decodeDigit(t3, u2, f3, ge.L_AND_G_PATTERNS);
      n2 += String.fromCharCode("0".charCodeAt(0) + d2 % 10);
      try {
        for (var p2 = (o2 = void 0, we(u2)), g2 = p2.next(); !g2.done; g2 = p2.next()) {
          f3 += g2.value;
        }
      } catch (t4) {
        o2 = { error: t4 };
      } finally {
        try {
          g2 && !g2.done && (i2 = p2.return) && i2.call(p2);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
      d2 >= 10 && (h2 |= 1 << 5 - l2);
    }
    n2 = e2.determineFirstDigit(n2, h2), f3 = ge.findGuardPattern(t3, f3, true, ge.MIDDLE_PATTERN, new Int32Array(ge.MIDDLE_PATTERN.length).fill(0))[1];
    for (l2 = 0; l2 < 6 && f3 < c2; l2++) {
      d2 = ge.decodeDigit(t3, u2, f3, ge.L_PATTERNS);
      n2 += String.fromCharCode("0".charCodeAt(0) + d2);
      try {
        for (var y2 = (a2 = void 0, we(u2)), w2 = y2.next(); !w2.done; w2 = y2.next()) {
          f3 += w2.value;
        }
      } catch (t4) {
        a2 = { error: t4 };
      } finally {
        try {
          w2 && !w2.done && (s2 = y2.return) && s2.call(y2);
        } finally {
          if (a2)
            throw a2.error;
        }
      }
    }
    return { rowOffset: f3, resultString: n2 };
  }, e2.prototype.getBarcodeFormat = function() {
    return wt.EAN_13;
  }, e2.determineFirstDigit = function(t3, e3) {
    for (var r2 = 0; r2 < 10; r2++)
      if (e3 === this.FIRST_DIGIT_ENCODINGS[r2])
        return t3 = String.fromCharCode("0".charCodeAt(0) + r2) + t3;
    throw new tt();
  }, e2.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26], e2;
}(ge);
var _e = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Ae = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Ce = function(t2) {
  function e2() {
    var e3 = t2.call(this) || this;
    return e3.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]), e3;
  }
  return _e(e2, t2), e2.prototype.decodeMiddle = function(t3, e3, r2) {
    var n2, o2, i2, a2, s2 = this.decodeMiddleCounters;
    s2[0] = 0, s2[1] = 0, s2[2] = 0, s2[3] = 0;
    for (var u2 = t3.getSize(), c2 = e3[1], f3 = 0; f3 < 4 && c2 < u2; f3++) {
      var h2 = ge.decodeDigit(t3, s2, c2, ge.L_PATTERNS);
      r2 += String.fromCharCode("0".charCodeAt(0) + h2);
      try {
        for (var l2 = (n2 = void 0, Ae(s2)), d2 = l2.next(); !d2.done; d2 = l2.next()) {
          c2 += d2.value;
        }
      } catch (t4) {
        n2 = { error: t4 };
      } finally {
        try {
          d2 && !d2.done && (o2 = l2.return) && o2.call(l2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
    }
    c2 = ge.findGuardPattern(t3, c2, true, ge.MIDDLE_PATTERN, new Int32Array(ge.MIDDLE_PATTERN.length).fill(0))[1];
    for (f3 = 0; f3 < 4 && c2 < u2; f3++) {
      h2 = ge.decodeDigit(t3, s2, c2, ge.L_PATTERNS);
      r2 += String.fromCharCode("0".charCodeAt(0) + h2);
      try {
        for (var p2 = (i2 = void 0, Ae(s2)), g2 = p2.next(); !g2.done; g2 = p2.next()) {
          c2 += g2.value;
        }
      } catch (t4) {
        i2 = { error: t4 };
      } finally {
        try {
          g2 && !g2.done && (a2 = p2.return) && a2.call(p2);
        } finally {
          if (i2)
            throw i2.error;
        }
      }
    }
    return { rowOffset: c2, resultString: r2 };
  }, e2.prototype.getBarcodeFormat = function() {
    return wt.EAN_8;
  }, e2;
}(ge);
var me = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Ee = function(t2) {
  function e2() {
    var e3 = null !== t2 && t2.apply(this, arguments) || this;
    return e3.ean13Reader = new ve(), e3;
  }
  return me(e2, t2), e2.prototype.getBarcodeFormat = function() {
    return wt.UPC_A;
  }, e2.prototype.decode = function(t3, e3) {
    return this.maybeReturnResult(this.ean13Reader.decode(t3));
  }, e2.prototype.decodeRow = function(t3, e3, r2) {
    return this.maybeReturnResult(this.ean13Reader.decodeRow(t3, e3, r2));
  }, e2.prototype.decodeMiddle = function(t3, e3, r2) {
    return this.ean13Reader.decodeMiddle(t3, e3, r2);
  }, e2.prototype.maybeReturnResult = function(t3) {
    var e3 = t3.getText();
    if ("0" === e3.charAt(0)) {
      var r2 = new gt(e3.substring(1), null, null, t3.getResultPoints(), wt.UPC_A);
      return null != t3.getResultMetadata() && r2.putAllMetadata(t3.getResultMetadata()), r2;
    }
    throw new tt();
  }, e2.prototype.reset = function() {
    this.ean13Reader.reset();
  }, e2;
}(ge);
var Ie = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Se = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Te = function(t2) {
  function e2() {
    var e3 = t2.call(this) || this;
    return e3.decodeMiddleCounters = new Int32Array(4), e3;
  }
  return Ie(e2, t2), e2.prototype.decodeMiddle = function(t3, r2, n2) {
    var o2, i2, a2 = this.decodeMiddleCounters.map(function(t4) {
      return t4;
    });
    a2[0] = 0, a2[1] = 0, a2[2] = 0, a2[3] = 0;
    for (var s2 = t3.getSize(), u2 = r2[1], c2 = 0, f3 = 0; f3 < 6 && u2 < s2; f3++) {
      var h2 = e2.decodeDigit(t3, a2, u2, e2.L_AND_G_PATTERNS);
      n2 += String.fromCharCode("0".charCodeAt(0) + h2 % 10);
      try {
        for (var l2 = (o2 = void 0, Se(a2)), d2 = l2.next(); !d2.done; d2 = l2.next()) {
          u2 += d2.value;
        }
      } catch (t4) {
        o2 = { error: t4 };
      } finally {
        try {
          d2 && !d2.done && (i2 = l2.return) && i2.call(l2);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
      h2 >= 10 && (c2 |= 1 << 5 - f3);
    }
    return e2.determineNumSysAndCheckDigit(new Q(n2), c2), u2;
  }, e2.prototype.decodeEnd = function(t3, r2) {
    return e2.findGuardPatternWithoutCounters(t3, r2, true, e2.MIDDLE_END_PATTERN);
  }, e2.prototype.checkChecksum = function(t3) {
    return ge.checkChecksum(e2.convertUPCEtoUPCA(t3));
  }, e2.determineNumSysAndCheckDigit = function(t3, e3) {
    for (var r2 = 0; r2 <= 1; r2++)
      for (var n2 = 0; n2 < 10; n2++)
        if (e3 === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[r2][n2])
          return t3.insert(0, "0" + r2), void t3.append("0" + n2);
    throw tt.getNotFoundInstance();
  }, e2.prototype.getBarcodeFormat = function() {
    return wt.UPC_E;
  }, e2.convertUPCEtoUPCA = function(t3) {
    var e3 = t3.slice(1, 7).split("").map(function(t4) {
      return t4.charCodeAt(0);
    }), r2 = new Q();
    r2.append(t3.charAt(0));
    var n2 = e3[5];
    switch (n2) {
      case 0:
      case 1:
      case 2:
        r2.appendChars(e3, 0, 2), r2.append(n2), r2.append("0000"), r2.appendChars(e3, 2, 3);
        break;
      case 3:
        r2.appendChars(e3, 0, 3), r2.append("00000"), r2.appendChars(e3, 3, 2);
        break;
      case 4:
        r2.appendChars(e3, 0, 4), r2.append("00000"), r2.append(e3[4]);
        break;
      default:
        r2.appendChars(e3, 0, 5), r2.append("0000"), r2.append(n2);
    }
    return t3.length >= 8 && r2.append(t3.charAt(7)), r2.toString();
  }, e2.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]), e2.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]), Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 1])], e2;
}(ge);
var Oe = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var be = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Re = function(t2) {
  function e2(e3) {
    var r2 = t2.call(this) || this, n2 = null == e3 ? null : e3.get(U.POSSIBLE_FORMATS), o2 = [];
    return null != n2 && (n2.indexOf(wt.EAN_13) > -1 && o2.push(new ve()), n2.indexOf(wt.UPC_A) > -1 && o2.push(new Ee()), n2.indexOf(wt.EAN_8) > -1 && o2.push(new Ce()), n2.indexOf(wt.UPC_E) > -1 && o2.push(new Te())), 0 === o2.length && (o2.push(new ve()), o2.push(new Ee()), o2.push(new Ce()), o2.push(new Te())), r2.readers = o2, r2;
  }
  return Oe(e2, t2), e2.prototype.decodeRow = function(t3, e3, r2) {
    var n2, o2;
    try {
      for (var i2 = be(this.readers), a2 = i2.next(); !a2.done; a2 = i2.next()) {
        var s2 = a2.value;
        try {
          var u2 = s2.decodeRow(t3, e3, r2), c2 = u2.getBarcodeFormat() === wt.EAN_13 && "0" === u2.getText().charAt(0), f3 = null == r2 ? null : r2.get(U.POSSIBLE_FORMATS), h2 = null == f3 || f3.includes(wt.UPC_A);
          if (c2 && h2) {
            var l2 = u2.getRawBytes(), d2 = new gt(u2.getText().substring(1), l2, l2 ? l2.length : null, u2.getResultPoints(), wt.UPC_A);
            return d2.putAllMetadata(u2.getResultMetadata()), d2;
          }
          return u2;
        } catch (t4) {
        }
      }
    } catch (t4) {
      n2 = { error: t4 };
    } finally {
      try {
        a2 && !a2.done && (o2 = i2.return) && o2.call(i2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    throw new tt();
  }, e2.prototype.reset = function() {
    var t3, e3;
    try {
      for (var r2 = be(this.readers), n2 = r2.next(); !n2.done; n2 = r2.next()) {
        n2.value.reset();
      }
    } catch (e4) {
      t3 = { error: e4 };
    } finally {
      try {
        n2 && !n2.done && (e3 = r2.return) && e3.call(r2);
      } finally {
        if (t3)
          throw t3.error;
      }
    }
  }, e2;
}(Kt);
var Ne = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var De = function(t2) {
  function e2() {
    var e3 = null !== t2 && t2.apply(this, arguments) || this;
    return e3.CODA_BAR_CHAR_SET = { nnnnnww: "0", nnnnwwn: "1", nnnwnnw: "2", wwnnnnn: "3", nnwnnwn: "4", wnnnnwn: "5", nwnnnnw: "6", nwnnwnn: "7", nwwnnnn: "8", wnnwnnn: "9", nnnwwnn: "-", nnwwnnn: "$", wnnnwnw: ":", wnwnnnw: "/", wnwnwnn: ".", nnwwwww: "+", nnwwnwn: "A", nwnwnnw: "B", nnnwnww: "C", nnnwwwn: "D" }, e3;
  }
  return Ne(e2, t2), e2.prototype.decodeRow = function(t3, e3, r2) {
    var n2 = this.getValidRowData(e3);
    if (!n2)
      throw new tt();
    var o2 = this.codaBarDecodeRow(n2.row);
    if (!o2)
      throw new tt();
    return new gt(o2, null, 0, [new Lt(n2.left, t3), new Lt(n2.right, t3)], wt.CODABAR, (/* @__PURE__ */ new Date()).getTime());
  }, e2.prototype.getValidRowData = function(t3) {
    var e3 = t3.toArray(), r2 = e3.indexOf(true);
    if (-1 === r2)
      return null;
    var n2 = e3.lastIndexOf(true);
    if (n2 <= r2)
      return null;
    for (var o2 = [], i2 = (e3 = e3.slice(r2, n2 + 1))[0], a2 = 1, s2 = 1; s2 < e3.length; s2++)
      e3[s2] === i2 ? a2++ : (i2 = e3[s2], o2.push(a2), a2 = 1);
    return o2.push(a2), o2.length < 23 && (o2.length + 1) % 8 != 0 ? null : { row: o2, left: r2, right: n2 };
  }, e2.prototype.codaBarDecodeRow = function(t3) {
    for (var e3 = [], r2 = Math.ceil(t3.reduce(function(t4, e4) {
      return (t4 + e4) / 2;
    }, 0)); t3.length > 0; ) {
      var n2 = t3.splice(0, 8).splice(0, 7).map(function(t4) {
        return t4 < r2 ? "n" : "w";
      }).join("");
      if (void 0 === this.CODA_BAR_CHAR_SET[n2])
        return null;
      e3.push(this.CODA_BAR_CHAR_SET[n2]);
    }
    var o2 = e3.join("");
    return this.validCodaBarString(o2) ? o2 : null;
  }, e2.prototype.validCodaBarString = function(t3) {
    return /^[A-D].{1,}[A-D]$/.test(t3);
  }, e2;
}(Kt);
var Me = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Pe = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Be = function(t2) {
  function e2() {
    var e3 = t2.call(this) || this;
    return e3.decodeFinderCounters = new Int32Array(4), e3.dataCharacterCounters = new Int32Array(8), e3.oddRoundingErrors = new Array(4), e3.evenRoundingErrors = new Array(4), e3.oddCounts = new Array(e3.dataCharacterCounters.length / 2), e3.evenCounts = new Array(e3.dataCharacterCounters.length / 2), e3;
  }
  return Me(e2, t2), e2.prototype.getDecodeFinderCounters = function() {
    return this.decodeFinderCounters;
  }, e2.prototype.getDataCharacterCounters = function() {
    return this.dataCharacterCounters;
  }, e2.prototype.getOddRoundingErrors = function() {
    return this.oddRoundingErrors;
  }, e2.prototype.getEvenRoundingErrors = function() {
    return this.evenRoundingErrors;
  }, e2.prototype.getOddCounts = function() {
    return this.oddCounts;
  }, e2.prototype.getEvenCounts = function() {
    return this.evenCounts;
  }, e2.prototype.parseFinderValue = function(t3, r2) {
    for (var n2 = 0; n2 < r2.length; n2++)
      if (Kt.patternMatchVariance(t3, r2[n2], e2.MAX_INDIVIDUAL_VARIANCE) < e2.MAX_AVG_VARIANCE)
        return n2;
    throw new tt();
  }, e2.count = function(t3) {
    return Pt.sum(new Int32Array(t3));
  }, e2.increment = function(t3, e3) {
    for (var r2 = 0, n2 = e3[0], o2 = 1; o2 < t3.length; o2++)
      e3[o2] > n2 && (n2 = e3[o2], r2 = o2);
    t3[r2]++;
  }, e2.decrement = function(t3, e3) {
    for (var r2 = 0, n2 = e3[0], o2 = 1; o2 < t3.length; o2++)
      e3[o2] < n2 && (n2 = e3[o2], r2 = o2);
    t3[r2]--;
  }, e2.isFinderPattern = function(t3) {
    var r2, n2, o2 = t3[0] + t3[1], i2 = o2 / (o2 + t3[2] + t3[3]);
    if (i2 >= e2.MIN_FINDER_PATTERN_RATIO && i2 <= e2.MAX_FINDER_PATTERN_RATIO) {
      var a2 = Number.MAX_SAFE_INTEGER, s2 = Number.MIN_SAFE_INTEGER;
      try {
        for (var u2 = Pe(t3), c2 = u2.next(); !c2.done; c2 = u2.next()) {
          var f3 = c2.value;
          f3 > s2 && (s2 = f3), f3 < a2 && (a2 = f3);
        }
      } catch (t4) {
        r2 = { error: t4 };
      } finally {
        try {
          c2 && !c2.done && (n2 = u2.return) && n2.call(u2);
        } finally {
          if (r2)
            throw r2.error;
        }
      }
      return s2 < 10 * a2;
    }
    return false;
  }, e2.MAX_AVG_VARIANCE = 0.2, e2.MAX_INDIVIDUAL_VARIANCE = 0.45, e2.MIN_FINDER_PATTERN_RATIO = 9.5 / 12, e2.MAX_FINDER_PATTERN_RATIO = 12.5 / 14, e2;
}(Kt);
var Le = function() {
  function t2(t3, e2) {
    this.value = t3, this.checksumPortion = e2;
  }
  return t2.prototype.getValue = function() {
    return this.value;
  }, t2.prototype.getChecksumPortion = function() {
    return this.checksumPortion;
  }, t2.prototype.toString = function() {
    return this.value + "(" + this.checksumPortion + ")";
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.value === r2.value && this.checksumPortion === r2.checksumPortion;
  }, t2.prototype.hashCode = function() {
    return this.value ^ this.checksumPortion;
  }, t2;
}();
var Fe = function() {
  function t2(t3, e2, r2, n2, o2) {
    this.value = t3, this.startEnd = e2, this.value = t3, this.startEnd = e2, this.resultPoints = new Array(), this.resultPoints.push(new Lt(r2, o2)), this.resultPoints.push(new Lt(n2, o2));
  }
  return t2.prototype.getValue = function() {
    return this.value;
  }, t2.prototype.getStartEnd = function() {
    return this.startEnd;
  }, t2.prototype.getResultPoints = function() {
    return this.resultPoints;
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.value === r2.value;
  }, t2.prototype.hashCode = function() {
    return this.value;
  }, t2;
}();
var ke = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var xe = function() {
  function t2() {
  }
  return t2.getRSSvalue = function(e2, r2, n2) {
    var o2, i2, a2 = 0;
    try {
      for (var s2 = ke(e2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
        a2 += u2.value;
      }
    } catch (t3) {
      o2 = { error: t3 };
    } finally {
      try {
        u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    for (var c2 = 0, f3 = 0, h2 = e2.length, l2 = 0; l2 < h2 - 1; l2++) {
      var d2 = void 0;
      for (d2 = 1, f3 |= 1 << l2; d2 < e2[l2]; d2++, f3 &= ~(1 << l2)) {
        var p2 = t2.combins(a2 - d2 - 1, h2 - l2 - 2);
        if (n2 && 0 === f3 && a2 - d2 - (h2 - l2 - 1) >= h2 - l2 - 1 && (p2 -= t2.combins(a2 - d2 - (h2 - l2), h2 - l2 - 2)), h2 - l2 - 1 > 1) {
          for (var g2 = 0, y2 = a2 - d2 - (h2 - l2 - 2); y2 > r2; y2--)
            g2 += t2.combins(a2 - d2 - y2 - 1, h2 - l2 - 3);
          p2 -= g2 * (h2 - 1 - l2);
        } else
          a2 - d2 > r2 && p2--;
        c2 += p2;
      }
      a2 -= d2;
    }
    return c2;
  }, t2.combins = function(t3, e2) {
    var r2, n2;
    t3 - e2 > e2 ? (n2 = e2, r2 = t3 - e2) : (n2 = t3 - e2, r2 = e2);
    for (var o2 = 1, i2 = 1, a2 = t3; a2 > r2; a2--)
      o2 *= a2, i2 <= n2 && (o2 /= i2, i2++);
    for (; i2 <= n2; )
      o2 /= i2, i2++;
    return o2;
  }, t2;
}();
var Ve = function() {
  function t2() {
  }
  return t2.buildBitArray = function(t3) {
    var e2 = 2 * t3.length - 1;
    null == t3[t3.length - 1].getRightChar() && (e2 -= 1);
    for (var r2 = new V(12 * e2), n2 = 0, o2 = t3[0].getRightChar().getValue(), i2 = 11; i2 >= 0; --i2)
      0 != (o2 & 1 << i2) && r2.set(n2), n2++;
    for (i2 = 1; i2 < t3.length; ++i2) {
      for (var a2 = t3[i2], s2 = a2.getLeftChar().getValue(), u2 = 11; u2 >= 0; --u2)
        0 != (s2 & 1 << u2) && r2.set(n2), n2++;
      if (null !== a2.getRightChar()) {
        var c2 = a2.getRightChar().getValue();
        for (u2 = 11; u2 >= 0; --u2)
          0 != (c2 & 1 << u2) && r2.set(n2), n2++;
      }
    }
    return r2;
  }, t2;
}();
var He = function() {
  function t2(t3, e2) {
    e2 ? this.decodedInformation = null : (this.finished = t3, this.decodedInformation = e2);
  }
  return t2.prototype.getDecodedInformation = function() {
    return this.decodedInformation;
  }, t2.prototype.isFinished = function() {
    return this.finished;
  }, t2;
}();
var Ue = function() {
  function t2(t3) {
    this.newPosition = t3;
  }
  return t2.prototype.getNewPosition = function() {
    return this.newPosition;
  }, t2;
}();
var Xe = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Ge = function(t2) {
  function e2(e3, r2) {
    var n2 = t2.call(this, e3) || this;
    return n2.value = r2, n2;
  }
  return Xe(e2, t2), e2.prototype.getValue = function() {
    return this.value;
  }, e2.prototype.isFNC1 = function() {
    return this.value === e2.FNC1;
  }, e2.FNC1 = "$", e2;
}(Ue);
var We = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ze = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this, e3) || this;
    return n2 ? (o2.remaining = true, o2.remainingValue = o2.remainingValue) : (o2.remaining = false, o2.remainingValue = 0), o2.newString = r2, o2;
  }
  return We(e2, t2), e2.prototype.getNewString = function() {
    return this.newString;
  }, e2.prototype.isRemaining = function() {
    return this.remaining;
  }, e2.prototype.getRemainingValue = function() {
    return this.remainingValue;
  }, e2;
}(Ue);
var je = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Ye = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this, e3) || this;
    if (r2 < 0 || r2 > 10 || n2 < 0 || n2 > 10)
      throw new G();
    return o2.firstDigit = r2, o2.secondDigit = n2, o2;
  }
  return je(e2, t2), e2.prototype.getFirstDigit = function() {
    return this.firstDigit;
  }, e2.prototype.getSecondDigit = function() {
    return this.secondDigit;
  }, e2.prototype.getValue = function() {
    return 10 * this.firstDigit + this.secondDigit;
  }, e2.prototype.isFirstDigitFNC1 = function() {
    return this.firstDigit === e2.FNC1;
  }, e2.prototype.isSecondDigitFNC1 = function() {
    return this.secondDigit === e2.FNC1;
  }, e2.prototype.isAnyFNC1 = function() {
    return this.firstDigit === e2.FNC1 || this.secondDigit === e2.FNC1;
  }, e2.FNC1 = 10, e2;
}(Ue);
var Ze = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Ke = function() {
  function t2() {
  }
  return t2.parseFieldsInGeneralPurpose = function(e2) {
    var r2, n2, o2, i2, a2, s2, u2, c2;
    if (!e2)
      return null;
    if (e2.length < 2)
      throw new tt();
    var f3 = e2.substring(0, 2);
    try {
      for (var h2 = Ze(t2.TWO_DIGIT_DATA_LENGTH), l2 = h2.next(); !l2.done; l2 = h2.next()) {
        if ((C2 = l2.value)[0] === f3)
          return C2[1] === t2.VARIABLE_LENGTH ? t2.processVariableAI(2, C2[2], e2) : t2.processFixedAI(2, C2[1], e2);
      }
    } catch (t3) {
      r2 = { error: t3 };
    } finally {
      try {
        l2 && !l2.done && (n2 = h2.return) && n2.call(h2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    if (e2.length < 3)
      throw new tt();
    var d2 = e2.substring(0, 3);
    try {
      for (var p2 = Ze(t2.THREE_DIGIT_DATA_LENGTH), g2 = p2.next(); !g2.done; g2 = p2.next()) {
        if ((C2 = g2.value)[0] === d2)
          return C2[1] === t2.VARIABLE_LENGTH ? t2.processVariableAI(3, C2[2], e2) : t2.processFixedAI(3, C2[1], e2);
      }
    } catch (t3) {
      o2 = { error: t3 };
    } finally {
      try {
        g2 && !g2.done && (i2 = p2.return) && i2.call(p2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    try {
      for (var y2 = Ze(t2.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH), w2 = y2.next(); !w2.done; w2 = y2.next()) {
        if ((C2 = w2.value)[0] === d2)
          return C2[1] === t2.VARIABLE_LENGTH ? t2.processVariableAI(4, C2[2], e2) : t2.processFixedAI(4, C2[1], e2);
      }
    } catch (t3) {
      a2 = { error: t3 };
    } finally {
      try {
        w2 && !w2.done && (s2 = y2.return) && s2.call(y2);
      } finally {
        if (a2)
          throw a2.error;
      }
    }
    if (e2.length < 4)
      throw new tt();
    var v2 = e2.substring(0, 4);
    try {
      for (var _2 = Ze(t2.FOUR_DIGIT_DATA_LENGTH), A2 = _2.next(); !A2.done; A2 = _2.next()) {
        var C2;
        if ((C2 = A2.value)[0] === v2)
          return C2[1] === t2.VARIABLE_LENGTH ? t2.processVariableAI(4, C2[2], e2) : t2.processFixedAI(4, C2[1], e2);
      }
    } catch (t3) {
      u2 = { error: t3 };
    } finally {
      try {
        A2 && !A2.done && (c2 = _2.return) && c2.call(_2);
      } finally {
        if (u2)
          throw u2.error;
      }
    }
    throw new tt();
  }, t2.processFixedAI = function(e2, r2, n2) {
    if (n2.length < e2)
      throw new tt();
    var o2 = n2.substring(0, e2);
    if (n2.length < e2 + r2)
      throw new tt();
    var i2 = n2.substring(e2, e2 + r2), a2 = n2.substring(e2 + r2), s2 = "(" + o2 + ")" + i2, u2 = t2.parseFieldsInGeneralPurpose(a2);
    return null == u2 ? s2 : s2 + u2;
  }, t2.processVariableAI = function(e2, r2, n2) {
    var o2, i2 = n2.substring(0, e2);
    o2 = n2.length < e2 + r2 ? n2.length : e2 + r2;
    var a2 = n2.substring(e2, o2), s2 = n2.substring(o2), u2 = "(" + i2 + ")" + a2, c2 = t2.parseFieldsInGeneralPurpose(s2);
    return null == c2 ? u2 : u2 + c2;
  }, t2.VARIABLE_LENGTH = [], t2.TWO_DIGIT_DATA_LENGTH = [["00", 18], ["01", 14], ["02", 14], ["10", t2.VARIABLE_LENGTH, 20], ["11", 6], ["12", 6], ["13", 6], ["15", 6], ["17", 6], ["20", 2], ["21", t2.VARIABLE_LENGTH, 20], ["22", t2.VARIABLE_LENGTH, 29], ["30", t2.VARIABLE_LENGTH, 8], ["37", t2.VARIABLE_LENGTH, 8], ["90", t2.VARIABLE_LENGTH, 30], ["91", t2.VARIABLE_LENGTH, 30], ["92", t2.VARIABLE_LENGTH, 30], ["93", t2.VARIABLE_LENGTH, 30], ["94", t2.VARIABLE_LENGTH, 30], ["95", t2.VARIABLE_LENGTH, 30], ["96", t2.VARIABLE_LENGTH, 30], ["97", t2.VARIABLE_LENGTH, 3], ["98", t2.VARIABLE_LENGTH, 30], ["99", t2.VARIABLE_LENGTH, 30]], t2.THREE_DIGIT_DATA_LENGTH = [["240", t2.VARIABLE_LENGTH, 30], ["241", t2.VARIABLE_LENGTH, 30], ["242", t2.VARIABLE_LENGTH, 6], ["250", t2.VARIABLE_LENGTH, 30], ["251", t2.VARIABLE_LENGTH, 30], ["253", t2.VARIABLE_LENGTH, 17], ["254", t2.VARIABLE_LENGTH, 20], ["400", t2.VARIABLE_LENGTH, 30], ["401", t2.VARIABLE_LENGTH, 30], ["402", 17], ["403", t2.VARIABLE_LENGTH, 30], ["410", 13], ["411", 13], ["412", 13], ["413", 13], ["414", 13], ["420", t2.VARIABLE_LENGTH, 20], ["421", t2.VARIABLE_LENGTH, 15], ["422", 3], ["423", t2.VARIABLE_LENGTH, 15], ["424", 3], ["425", 3], ["426", 3]], t2.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [["310", 6], ["311", 6], ["312", 6], ["313", 6], ["314", 6], ["315", 6], ["316", 6], ["320", 6], ["321", 6], ["322", 6], ["323", 6], ["324", 6], ["325", 6], ["326", 6], ["327", 6], ["328", 6], ["329", 6], ["330", 6], ["331", 6], ["332", 6], ["333", 6], ["334", 6], ["335", 6], ["336", 6], ["340", 6], ["341", 6], ["342", 6], ["343", 6], ["344", 6], ["345", 6], ["346", 6], ["347", 6], ["348", 6], ["349", 6], ["350", 6], ["351", 6], ["352", 6], ["353", 6], ["354", 6], ["355", 6], ["356", 6], ["357", 6], ["360", 6], ["361", 6], ["362", 6], ["363", 6], ["364", 6], ["365", 6], ["366", 6], ["367", 6], ["368", 6], ["369", 6], ["390", t2.VARIABLE_LENGTH, 15], ["391", t2.VARIABLE_LENGTH, 18], ["392", t2.VARIABLE_LENGTH, 15], ["393", t2.VARIABLE_LENGTH, 18], ["703", t2.VARIABLE_LENGTH, 30]], t2.FOUR_DIGIT_DATA_LENGTH = [["7001", 13], ["7002", t2.VARIABLE_LENGTH, 30], ["7003", 10], ["8001", 14], ["8002", t2.VARIABLE_LENGTH, 20], ["8003", t2.VARIABLE_LENGTH, 30], ["8004", t2.VARIABLE_LENGTH, 30], ["8005", 6], ["8006", 18], ["8007", t2.VARIABLE_LENGTH, 30], ["8008", t2.VARIABLE_LENGTH, 12], ["8018", 18], ["8020", t2.VARIABLE_LENGTH, 25], ["8100", 6], ["8101", 10], ["8102", 2], ["8110", t2.VARIABLE_LENGTH, 70], ["8200", t2.VARIABLE_LENGTH, 70]], t2;
}();
var qe = function() {
  function t2(t3) {
    this.buffer = new Q(), this.information = t3;
  }
  return t2.prototype.decodeAllCodes = function(t3, e2) {
    for (var r2 = e2, n2 = null; ; ) {
      var o2 = this.decodeGeneralPurposeField(r2, n2), i2 = Ke.parseFieldsInGeneralPurpose(o2.getNewString());
      if (null != i2 && t3.append(i2), n2 = o2.isRemaining() ? "" + o2.getRemainingValue() : null, r2 === o2.getNewPosition())
        break;
      r2 = o2.getNewPosition();
    }
    return t3.toString();
  }, t2.prototype.isStillNumeric = function(t3) {
    if (t3 + 7 > this.information.getSize())
      return t3 + 4 <= this.information.getSize();
    for (var e2 = t3; e2 < t3 + 3; ++e2)
      if (this.information.get(e2))
        return true;
    return this.information.get(t3 + 3);
  }, t2.prototype.decodeNumeric = function(t3) {
    if (t3 + 7 > this.information.getSize()) {
      var e2 = this.extractNumericValueFromBitArray(t3, 4);
      return new Ye(this.information.getSize(), 0 === e2 ? Ye.FNC1 : e2 - 1, Ye.FNC1);
    }
    var r2 = this.extractNumericValueFromBitArray(t3, 7);
    return new Ye(t3 + 7, (r2 - 8) / 11, (r2 - 8) % 11);
  }, t2.prototype.extractNumericValueFromBitArray = function(e2, r2) {
    return t2.extractNumericValueFromBitArray(this.information, e2, r2);
  }, t2.extractNumericValueFromBitArray = function(t3, e2, r2) {
    for (var n2 = 0, o2 = 0; o2 < r2; ++o2)
      t3.get(e2 + o2) && (n2 |= 1 << r2 - o2 - 1);
    return n2;
  }, t2.prototype.decodeGeneralPurposeField = function(t3, e2) {
    this.buffer.setLengthToZero(), null != e2 && this.buffer.append(e2), this.current.setPosition(t3);
    var r2 = this.parseBlocks();
    return null != r2 && r2.isRemaining() ? new ze(this.current.getPosition(), this.buffer.toString(), r2.getRemainingValue()) : new ze(this.current.getPosition(), this.buffer.toString());
  }, t2.prototype.parseBlocks = function() {
    var t3, e2;
    do {
      var r2 = this.current.getPosition();
      if (t3 = this.current.isAlpha() ? (e2 = this.parseAlphaBlock()).isFinished() : this.current.isIsoIec646() ? (e2 = this.parseIsoIec646Block()).isFinished() : (e2 = this.parseNumericBlock()).isFinished(), !(r2 !== this.current.getPosition()) && !t3)
        break;
    } while (!t3);
    return e2.getDecodedInformation();
  }, t2.prototype.parseNumericBlock = function() {
    for (; this.isStillNumeric(this.current.getPosition()); ) {
      var t3 = this.decodeNumeric(this.current.getPosition());
      if (this.current.setPosition(t3.getNewPosition()), t3.isFirstDigitFNC1()) {
        var e2 = void 0;
        return e2 = t3.isSecondDigitFNC1() ? new ze(this.current.getPosition(), this.buffer.toString()) : new ze(this.current.getPosition(), this.buffer.toString(), t3.getSecondDigit()), new He(true, e2);
      }
      if (this.buffer.append(t3.getFirstDigit()), t3.isSecondDigitFNC1()) {
        e2 = new ze(this.current.getPosition(), this.buffer.toString());
        return new He(true, e2);
      }
      this.buffer.append(t3.getSecondDigit());
    }
    return this.isNumericToAlphaNumericLatch(this.current.getPosition()) && (this.current.setAlpha(), this.current.incrementPosition(4)), new He(false);
  }, t2.prototype.parseIsoIec646Block = function() {
    for (; this.isStillIsoIec646(this.current.getPosition()); ) {
      var t3 = this.decodeIsoIec646(this.current.getPosition());
      if (this.current.setPosition(t3.getNewPosition()), t3.isFNC1()) {
        var e2 = new ze(this.current.getPosition(), this.buffer.toString());
        return new He(true, e2);
      }
      this.buffer.append(t3.getValue());
    }
    return this.isAlphaOr646ToNumericLatch(this.current.getPosition()) ? (this.current.incrementPosition(3), this.current.setNumeric()) : this.isAlphaTo646ToAlphaLatch(this.current.getPosition()) && (this.current.getPosition() + 5 < this.information.getSize() ? this.current.incrementPosition(5) : this.current.setPosition(this.information.getSize()), this.current.setAlpha()), new He(false);
  }, t2.prototype.parseAlphaBlock = function() {
    for (; this.isStillAlpha(this.current.getPosition()); ) {
      var t3 = this.decodeAlphanumeric(this.current.getPosition());
      if (this.current.setPosition(t3.getNewPosition()), t3.isFNC1()) {
        var e2 = new ze(this.current.getPosition(), this.buffer.toString());
        return new He(true, e2);
      }
      this.buffer.append(t3.getValue());
    }
    return this.isAlphaOr646ToNumericLatch(this.current.getPosition()) ? (this.current.incrementPosition(3), this.current.setNumeric()) : this.isAlphaTo646ToAlphaLatch(this.current.getPosition()) && (this.current.getPosition() + 5 < this.information.getSize() ? this.current.incrementPosition(5) : this.current.setPosition(this.information.getSize()), this.current.setIsoIec646()), new He(false);
  }, t2.prototype.isStillIsoIec646 = function(t3) {
    if (t3 + 5 > this.information.getSize())
      return false;
    var e2 = this.extractNumericValueFromBitArray(t3, 5);
    if (e2 >= 5 && e2 < 16)
      return true;
    if (t3 + 7 > this.information.getSize())
      return false;
    var r2 = this.extractNumericValueFromBitArray(t3, 7);
    if (r2 >= 64 && r2 < 116)
      return true;
    if (t3 + 8 > this.information.getSize())
      return false;
    var n2 = this.extractNumericValueFromBitArray(t3, 8);
    return n2 >= 232 && n2 < 253;
  }, t2.prototype.decodeIsoIec646 = function(t3) {
    var e2 = this.extractNumericValueFromBitArray(t3, 5);
    if (15 === e2)
      return new Ge(t3 + 5, Ge.FNC1);
    if (e2 >= 5 && e2 < 15)
      return new Ge(t3 + 5, "0" + (e2 - 5));
    var r2, n2 = this.extractNumericValueFromBitArray(t3, 7);
    if (n2 >= 64 && n2 < 90)
      return new Ge(t3 + 7, "" + (n2 + 1));
    if (n2 >= 90 && n2 < 116)
      return new Ge(t3 + 7, "" + (n2 + 7));
    switch (this.extractNumericValueFromBitArray(t3, 8)) {
      case 232:
        r2 = "!";
        break;
      case 233:
        r2 = '"';
        break;
      case 234:
        r2 = "%";
        break;
      case 235:
        r2 = "&";
        break;
      case 236:
        r2 = "'";
        break;
      case 237:
        r2 = "(";
        break;
      case 238:
        r2 = ")";
        break;
      case 239:
        r2 = "*";
        break;
      case 240:
        r2 = "+";
        break;
      case 241:
        r2 = ",";
        break;
      case 242:
        r2 = "-";
        break;
      case 243:
        r2 = ".";
        break;
      case 244:
        r2 = "/";
        break;
      case 245:
        r2 = ":";
        break;
      case 246:
        r2 = ";";
        break;
      case 247:
        r2 = "<";
        break;
      case 248:
        r2 = "=";
        break;
      case 249:
        r2 = ">";
        break;
      case 250:
        r2 = "?";
        break;
      case 251:
        r2 = "_";
        break;
      case 252:
        r2 = " ";
        break;
      default:
        throw new G();
    }
    return new Ge(t3 + 8, r2);
  }, t2.prototype.isStillAlpha = function(t3) {
    if (t3 + 5 > this.information.getSize())
      return false;
    var e2 = this.extractNumericValueFromBitArray(t3, 5);
    if (e2 >= 5 && e2 < 16)
      return true;
    if (t3 + 6 > this.information.getSize())
      return false;
    var r2 = this.extractNumericValueFromBitArray(t3, 6);
    return r2 >= 16 && r2 < 63;
  }, t2.prototype.decodeAlphanumeric = function(t3) {
    var e2 = this.extractNumericValueFromBitArray(t3, 5);
    if (15 === e2)
      return new Ge(t3 + 5, Ge.FNC1);
    if (e2 >= 5 && e2 < 15)
      return new Ge(t3 + 5, "0" + (e2 - 5));
    var r2, n2 = this.extractNumericValueFromBitArray(t3, 6);
    if (n2 >= 32 && n2 < 58)
      return new Ge(t3 + 6, "" + (n2 + 33));
    switch (n2) {
      case 58:
        r2 = "*";
        break;
      case 59:
        r2 = ",";
        break;
      case 60:
        r2 = "-";
        break;
      case 61:
        r2 = ".";
        break;
      case 62:
        r2 = "/";
        break;
      default:
        throw new Nt("Decoding invalid alphanumeric value: " + n2);
    }
    return new Ge(t3 + 6, r2);
  }, t2.prototype.isAlphaTo646ToAlphaLatch = function(t3) {
    if (t3 + 1 > this.information.getSize())
      return false;
    for (var e2 = 0; e2 < 5 && e2 + t3 < this.information.getSize(); ++e2)
      if (2 === e2) {
        if (!this.information.get(t3 + 2))
          return false;
      } else if (this.information.get(t3 + e2))
        return false;
    return true;
  }, t2.prototype.isAlphaOr646ToNumericLatch = function(t3) {
    if (t3 + 3 > this.information.getSize())
      return false;
    for (var e2 = t3; e2 < t3 + 3; ++e2)
      if (this.information.get(e2))
        return false;
    return true;
  }, t2.prototype.isNumericToAlphaNumericLatch = function(t3) {
    if (t3 + 1 > this.information.getSize())
      return false;
    for (var e2 = 0; e2 < 4 && e2 + t3 < this.information.getSize(); ++e2)
      if (this.information.get(t3 + e2))
        return false;
    return true;
  }, t2;
}();
var Qe = function() {
  function t2(t3) {
    this.information = t3, this.generalDecoder = new qe(t3);
  }
  return t2.prototype.getInformation = function() {
    return this.information;
  }, t2.prototype.getGeneralDecoder = function() {
    return this.generalDecoder;
  }, t2;
}();
var Je = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var $e = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return Je(e2, t2), e2.prototype.encodeCompressedGtin = function(t3, e3) {
    t3.append("(01)");
    var r2 = t3.length();
    t3.append("9"), this.encodeCompressedGtinWithoutAI(t3, e3, r2);
  }, e2.prototype.encodeCompressedGtinWithoutAI = function(t3, r2, n2) {
    for (var o2 = 0; o2 < 4; ++o2) {
      var i2 = this.getGeneralDecoder().extractNumericValueFromBitArray(r2 + 10 * o2, 10);
      i2 / 100 == 0 && t3.append("0"), i2 / 10 == 0 && t3.append("0"), t3.append(i2);
    }
    e2.appendCheckDigit(t3, n2);
  }, e2.appendCheckDigit = function(t3, e3) {
    for (var r2 = 0, n2 = 0; n2 < 13; n2++) {
      var o2 = t3.charAt(n2 + e3).charCodeAt(0) - "0".charCodeAt(0);
      r2 += 0 == (1 & n2) ? 3 * o2 : o2;
    }
    10 === (r2 = 10 - r2 % 10) && (r2 = 0), t3.append(r2);
  }, e2.GTIN_SIZE = 40, e2;
}(Qe);
var tr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var er = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return tr(e2, t2), e2.prototype.parseInformation = function() {
    var t3 = new Q();
    t3.append("(01)");
    var r2 = t3.length(), n2 = this.getGeneralDecoder().extractNumericValueFromBitArray(e2.HEADER_SIZE, 4);
    return t3.append(n2), this.encodeCompressedGtinWithoutAI(t3, e2.HEADER_SIZE + 4, r2), this.getGeneralDecoder().decodeAllCodes(t3, e2.HEADER_SIZE + 44);
  }, e2.HEADER_SIZE = 4, e2;
}($e);
var rr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var nr = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return rr(e2, t2), e2.prototype.parseInformation = function() {
    var t3 = new Q();
    return this.getGeneralDecoder().decodeAllCodes(t3, e2.HEADER_SIZE);
  }, e2.HEADER_SIZE = 5, e2;
}(Qe);
var or = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ir = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return or(e2, t2), e2.prototype.encodeCompressedWeight = function(t3, e3, r2) {
    var n2 = this.getGeneralDecoder().extractNumericValueFromBitArray(e3, r2);
    this.addWeightCode(t3, n2);
    for (var o2 = this.checkWeight(n2), i2 = 1e5, a2 = 0; a2 < 5; ++a2)
      o2 / i2 == 0 && t3.append("0"), i2 /= 10;
    t3.append(o2);
  }, e2;
}($e);
var ar = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var sr = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return ar(e2, t2), e2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() !== e2.HEADER_SIZE + ir.GTIN_SIZE + e2.WEIGHT_SIZE)
      throw new tt();
    var t3 = new Q();
    return this.encodeCompressedGtin(t3, e2.HEADER_SIZE), this.encodeCompressedWeight(t3, e2.HEADER_SIZE + ir.GTIN_SIZE, e2.WEIGHT_SIZE), t3.toString();
  }, e2.HEADER_SIZE = 5, e2.WEIGHT_SIZE = 15, e2;
}(ir);
var ur = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var cr = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return ur(e2, t2), e2.prototype.addWeightCode = function(t3, e3) {
    t3.append("(3103)");
  }, e2.prototype.checkWeight = function(t3) {
    return t3;
  }, e2;
}(sr);
var fr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var hr = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return fr(e2, t2), e2.prototype.addWeightCode = function(t3, e3) {
    e3 < 1e4 ? t3.append("(3202)") : t3.append("(3203)");
  }, e2.prototype.checkWeight = function(t3) {
    return t3 < 1e4 ? t3 : t3 - 1e4;
  }, e2;
}(sr);
var lr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var dr = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return lr(e2, t2), e2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() < e2.HEADER_SIZE + $e.GTIN_SIZE)
      throw new tt();
    var t3 = new Q();
    this.encodeCompressedGtin(t3, e2.HEADER_SIZE);
    var r2 = this.getGeneralDecoder().extractNumericValueFromBitArray(e2.HEADER_SIZE + $e.GTIN_SIZE, e2.LAST_DIGIT_SIZE);
    t3.append("(392"), t3.append(r2), t3.append(")");
    var n2 = this.getGeneralDecoder().decodeGeneralPurposeField(e2.HEADER_SIZE + $e.GTIN_SIZE + e2.LAST_DIGIT_SIZE, null);
    return t3.append(n2.getNewString()), t3.toString();
  }, e2.HEADER_SIZE = 8, e2.LAST_DIGIT_SIZE = 2, e2;
}($e);
var pr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var gr = function(t2) {
  function e2(e3) {
    return t2.call(this, e3) || this;
  }
  return pr(e2, t2), e2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() < e2.HEADER_SIZE + $e.GTIN_SIZE)
      throw new tt();
    var t3 = new Q();
    this.encodeCompressedGtin(t3, e2.HEADER_SIZE);
    var r2 = this.getGeneralDecoder().extractNumericValueFromBitArray(e2.HEADER_SIZE + $e.GTIN_SIZE, e2.LAST_DIGIT_SIZE);
    t3.append("(393"), t3.append(r2), t3.append(")");
    var n2 = this.getGeneralDecoder().extractNumericValueFromBitArray(e2.HEADER_SIZE + $e.GTIN_SIZE + e2.LAST_DIGIT_SIZE, e2.FIRST_THREE_DIGITS_SIZE);
    n2 / 100 == 0 && t3.append("0"), n2 / 10 == 0 && t3.append("0"), t3.append(n2);
    var o2 = this.getGeneralDecoder().decodeGeneralPurposeField(e2.HEADER_SIZE + $e.GTIN_SIZE + e2.LAST_DIGIT_SIZE + e2.FIRST_THREE_DIGITS_SIZE, null);
    return t3.append(o2.getNewString()), t3.toString();
  }, e2.HEADER_SIZE = 8, e2.LAST_DIGIT_SIZE = 2, e2.FIRST_THREE_DIGITS_SIZE = 10, e2;
}($e);
var yr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var wr = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this, e3) || this;
    return o2.dateCode = n2, o2.firstAIdigits = r2, o2;
  }
  return yr(e2, t2), e2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() !== e2.HEADER_SIZE + e2.GTIN_SIZE + e2.WEIGHT_SIZE + e2.DATE_SIZE)
      throw new tt();
    var t3 = new Q();
    return this.encodeCompressedGtin(t3, e2.HEADER_SIZE), this.encodeCompressedWeight(t3, e2.HEADER_SIZE + e2.GTIN_SIZE, e2.WEIGHT_SIZE), this.encodeCompressedDate(t3, e2.HEADER_SIZE + e2.GTIN_SIZE + e2.WEIGHT_SIZE), t3.toString();
  }, e2.prototype.encodeCompressedDate = function(t3, r2) {
    var n2 = this.getGeneralDecoder().extractNumericValueFromBitArray(r2, e2.DATE_SIZE);
    if (38400 !== n2) {
      t3.append("("), t3.append(this.dateCode), t3.append(")");
      var o2 = n2 % 32, i2 = (n2 /= 32) % 12 + 1, a2 = n2 /= 12;
      a2 / 10 == 0 && t3.append("0"), t3.append(a2), i2 / 10 == 0 && t3.append("0"), t3.append(i2), o2 / 10 == 0 && t3.append("0"), t3.append(o2);
    }
  }, e2.prototype.addWeightCode = function(t3, e3) {
    t3.append("("), t3.append(this.firstAIdigits), t3.append(e3 / 1e5), t3.append(")");
  }, e2.prototype.checkWeight = function(t3) {
    return t3 % 1e5;
  }, e2.HEADER_SIZE = 8, e2.WEIGHT_SIZE = 20, e2.DATE_SIZE = 16, e2;
}(ir);
var vr = function() {
  function t2(t3, e2, r2, n2) {
    this.leftchar = t3, this.rightchar = e2, this.finderpattern = r2, this.maybeLast = n2;
  }
  return t2.prototype.mayBeLast = function() {
    return this.maybeLast;
  }, t2.prototype.getLeftChar = function() {
    return this.leftchar;
  }, t2.prototype.getRightChar = function() {
    return this.rightchar;
  }, t2.prototype.getFinderPattern = function() {
    return this.finderpattern;
  }, t2.prototype.mustBeLast = function() {
    return null == this.rightchar;
  }, t2.prototype.toString = function() {
    return "[ " + this.leftchar + ", " + this.rightchar + " : " + (null == this.finderpattern ? "null" : this.finderpattern.getValue()) + " ]";
  }, t2.equals = function(e2, r2) {
    return e2 instanceof t2 && (t2.equalsOrNull(e2.leftchar, r2.leftchar) && t2.equalsOrNull(e2.rightchar, r2.rightchar) && t2.equalsOrNull(e2.finderpattern, r2.finderpattern));
  }, t2.equalsOrNull = function(e2, r2) {
    return null === e2 ? null === r2 : t2.equals(e2, r2);
  }, t2.prototype.hashCode = function() {
    return this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
  }, t2;
}();
var _r = function() {
  function t2(t3, e2, r2) {
    this.pairs = t3, this.rowNumber = e2, this.wasReversed = r2;
  }
  return t2.prototype.getPairs = function() {
    return this.pairs;
  }, t2.prototype.getRowNumber = function() {
    return this.rowNumber;
  }, t2.prototype.isReversed = function() {
    return this.wasReversed;
  }, t2.prototype.isEquivalent = function(t3) {
    return this.checkEqualitity(this, t3);
  }, t2.prototype.toString = function() {
    return "{ " + this.pairs + " }";
  }, t2.prototype.equals = function(e2, r2) {
    return e2 instanceof t2 && (this.checkEqualitity(e2, r2) && e2.wasReversed === r2.wasReversed);
  }, t2.prototype.checkEqualitity = function(t3, e2) {
    var r2;
    if (t3 && e2)
      return t3.forEach(function(t4, n2) {
        e2.forEach(function(e3) {
          t4.getLeftChar().getValue() === e3.getLeftChar().getValue() && t4.getRightChar().getValue() === e3.getRightChar().getValue() && t4.getFinderPatter().getValue() === e3.getFinderPatter().getValue() && (r2 = true);
        });
      }), r2;
  }, t2;
}();
var Ar = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Cr = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var mr = function(t2) {
  function e2() {
    var r2 = null !== t2 && t2.apply(this, arguments) || this;
    return r2.pairs = new Array(e2.MAX_PAIRS), r2.rows = new Array(), r2.startEnd = [2], r2;
  }
  return Ar(e2, t2), e2.prototype.decodeRow = function(t3, r2, n2) {
    this.pairs.length = 0, this.startFromEven = false;
    try {
      return e2.constructResult(this.decodeRow2pairs(t3, r2));
    } catch (t4) {
    }
    return this.pairs.length = 0, this.startFromEven = true, e2.constructResult(this.decodeRow2pairs(t3, r2));
  }, e2.prototype.reset = function() {
    this.pairs.length = 0, this.rows.length = 0;
  }, e2.prototype.decodeRow2pairs = function(t3, e3) {
    for (var r2, n2 = false; !n2; )
      try {
        this.pairs.push(this.retrieveNextPair(e3, this.pairs, t3));
      } catch (t4) {
        if (t4 instanceof tt) {
          if (!this.pairs.length)
            throw new tt();
          n2 = true;
        }
      }
    if (this.checkChecksum())
      return this.pairs;
    if (r2 = !!this.rows.length, this.storeRow(t3, false), r2) {
      var o2 = this.checkRowsBoolean(false);
      if (null != o2)
        return o2;
      if (null != (o2 = this.checkRowsBoolean(true)))
        return o2;
    }
    throw new tt();
  }, e2.prototype.checkRowsBoolean = function(t3) {
    if (this.rows.length > 25)
      return this.rows.length = 0, null;
    this.pairs.length = 0, t3 && (this.rows = this.rows.reverse());
    var e3 = null;
    try {
      e3 = this.checkRows(new Array(), 0);
    } catch (t4) {
      console.log(t4);
    }
    return t3 && (this.rows = this.rows.reverse()), e3;
  }, e2.prototype.checkRows = function(t3, r2) {
    for (var n2, o2, i2 = r2; i2 < this.rows.length; i2++) {
      var a2 = this.rows[i2];
      this.pairs.length = 0;
      try {
        for (var s2 = (n2 = void 0, Cr(t3)), u2 = s2.next(); !u2.done; u2 = s2.next()) {
          var c2 = u2.value;
          this.pairs.push(c2.getPairs());
        }
      } catch (t4) {
        n2 = { error: t4 };
      } finally {
        try {
          u2 && !u2.done && (o2 = s2.return) && o2.call(s2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      if (this.pairs.push(a2.getPairs()), e2.isValidSequence(this.pairs)) {
        if (this.checkChecksum())
          return this.pairs;
        var f3 = new Array(t3);
        f3.push(a2);
        try {
          return this.checkRows(f3, i2 + 1);
        } catch (t4) {
          console.log(t4);
        }
      }
    }
    throw new tt();
  }, e2.isValidSequence = function(t3) {
    var r2, n2;
    try {
      for (var o2 = Cr(e2.FINDER_PATTERN_SEQUENCES), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        var a2 = i2.value;
        if (!(t3.length > a2.length)) {
          for (var s2 = true, u2 = 0; u2 < t3.length; u2++)
            if (t3[u2].getFinderPattern().getValue() !== a2[u2]) {
              s2 = false;
              break;
            }
          if (s2)
            return true;
        }
      }
    } catch (t4) {
      r2 = { error: t4 };
    } finally {
      try {
        i2 && !i2.done && (n2 = o2.return) && n2.call(o2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    return false;
  }, e2.prototype.storeRow = function(t3, r2) {
    for (var n2 = 0, o2 = false, i2 = false; n2 < this.rows.length; ) {
      var a2 = this.rows[n2];
      if (a2.getRowNumber() > t3) {
        i2 = a2.isEquivalent(this.pairs);
        break;
      }
      o2 = a2.isEquivalent(this.pairs), n2++;
    }
    i2 || o2 || e2.isPartialRow(this.pairs, this.rows) || (this.rows.push(n2, new _r(this.pairs, t3, r2)), this.removePartialRows(this.pairs, this.rows));
  }, e2.prototype.removePartialRows = function(t3, e3) {
    var r2, n2, o2, i2, a2, s2;
    try {
      for (var u2 = Cr(e3), c2 = u2.next(); !c2.done; c2 = u2.next()) {
        var f3 = c2.value;
        if (f3.getPairs().length !== t3.length) {
          try {
            for (var h2 = (o2 = void 0, Cr(f3.getPairs())), l2 = h2.next(); !l2.done; l2 = h2.next()) {
              var d2 = l2.value, p2 = false;
              try {
                for (var g2 = (a2 = void 0, Cr(t3)), y2 = g2.next(); !y2.done; y2 = g2.next()) {
                  var w2 = y2.value;
                  if (vr.equals(d2, w2)) {
                    p2 = true;
                    break;
                  }
                }
              } catch (t4) {
                a2 = { error: t4 };
              } finally {
                try {
                  y2 && !y2.done && (s2 = g2.return) && s2.call(g2);
                } finally {
                  if (a2)
                    throw a2.error;
                }
              }
              p2 || false;
            }
          } catch (t4) {
            o2 = { error: t4 };
          } finally {
            try {
              l2 && !l2.done && (i2 = h2.return) && i2.call(h2);
            } finally {
              if (o2)
                throw o2.error;
            }
          }
        }
      }
    } catch (t4) {
      r2 = { error: t4 };
    } finally {
      try {
        c2 && !c2.done && (n2 = u2.return) && n2.call(u2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
  }, e2.isPartialRow = function(t3, e3) {
    var r2, n2, o2, i2, a2, s2;
    try {
      for (var u2 = Cr(e3), c2 = u2.next(); !c2.done; c2 = u2.next()) {
        var f3 = c2.value, h2 = true;
        try {
          for (var l2 = (o2 = void 0, Cr(t3)), d2 = l2.next(); !d2.done; d2 = l2.next()) {
            var p2 = d2.value, g2 = false;
            try {
              for (var y2 = (a2 = void 0, Cr(f3.getPairs())), w2 = y2.next(); !w2.done; w2 = y2.next()) {
                var v2 = w2.value;
                if (p2.equals(v2)) {
                  g2 = true;
                  break;
                }
              }
            } catch (t4) {
              a2 = { error: t4 };
            } finally {
              try {
                w2 && !w2.done && (s2 = y2.return) && s2.call(y2);
              } finally {
                if (a2)
                  throw a2.error;
              }
            }
            if (!g2) {
              h2 = false;
              break;
            }
          }
        } catch (t4) {
          o2 = { error: t4 };
        } finally {
          try {
            d2 && !d2.done && (i2 = l2.return) && i2.call(l2);
          } finally {
            if (o2)
              throw o2.error;
          }
        }
        if (h2)
          return true;
      }
    } catch (t4) {
      r2 = { error: t4 };
    } finally {
      try {
        c2 && !c2.done && (n2 = u2.return) && n2.call(u2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    return false;
  }, e2.prototype.getRows = function() {
    return this.rows;
  }, e2.constructResult = function(t3) {
    var e3 = function(t4) {
      try {
        if (t4.get(1))
          return new er(t4);
        if (!t4.get(2))
          return new nr(t4);
        switch (qe.extractNumericValueFromBitArray(t4, 1, 4)) {
          case 4:
            return new cr(t4);
          case 5:
            return new hr(t4);
        }
        switch (qe.extractNumericValueFromBitArray(t4, 1, 5)) {
          case 12:
            return new dr(t4);
          case 13:
            return new gr(t4);
        }
        switch (qe.extractNumericValueFromBitArray(t4, 1, 7)) {
          case 56:
            return new wr(t4, "310", "11");
          case 57:
            return new wr(t4, "320", "11");
          case 58:
            return new wr(t4, "310", "13");
          case 59:
            return new wr(t4, "320", "13");
          case 60:
            return new wr(t4, "310", "15");
          case 61:
            return new wr(t4, "320", "15");
          case 62:
            return new wr(t4, "310", "17");
          case 63:
            return new wr(t4, "320", "17");
        }
      } catch (e4) {
        throw console.log(e4), new Nt("unknown decoder: " + t4);
      }
    }(Ve.buildBitArray(t3)).parseInformation(), r2 = t3[0].getFinderPattern().getResultPoints(), n2 = t3[t3.length - 1].getFinderPattern().getResultPoints(), o2 = [r2[0], r2[1], n2[0], n2[1]];
    return new gt(e3, null, null, o2, wt.RSS_EXPANDED, null);
  }, e2.prototype.checkChecksum = function() {
    var t3 = this.pairs.get(0), e3 = t3.getLeftChar(), r2 = t3.getRightChar();
    if (null === r2)
      return false;
    for (var n2 = r2.getChecksumPortion(), o2 = 2, i2 = 1; i2 < this.pairs.size(); ++i2) {
      var a2 = this.pairs.get(i2);
      n2 += a2.getLeftChar().getChecksumPortion(), o2++;
      var s2 = a2.getRightChar();
      null != s2 && (n2 += s2.getChecksumPortion(), o2++);
    }
    return 211 * (o2 - 4) + (n2 %= 211) === e3.getValue();
  }, e2.getNextSecondBar = function(t3, e3) {
    var r2;
    return t3.get(e3) ? (r2 = t3.getNextUnset(e3), r2 = t3.getNextSet(r2)) : (r2 = t3.getNextSet(e3), r2 = t3.getNextUnset(r2)), r2;
  }, e2.prototype.retrieveNextPair = function(t3, r2, n2) {
    var o2, i2 = r2.length % 2 == 0;
    this.startFromEven && (i2 = !i2);
    var a2 = true, s2 = -1;
    do {
      this.findNextPair(t3, r2, s2), null === (o2 = this.parseFoundFinderPattern(t3, n2, i2)) ? s2 = e2.getNextSecondBar(t3, this.startEnd[0]) : a2 = false;
    } while (a2);
    var u2, c2 = this.decodeDataCharacter(t3, o2, i2, true);
    if (!this.isEmptyPair(r2) && r2[r2.length - 1].mustBeLast())
      throw new tt();
    try {
      u2 = this.decodeDataCharacter(t3, o2, i2, false);
    } catch (t4) {
      u2 = null, console.log(t4);
    }
    return new vr(c2, u2, o2, true);
  }, e2.prototype.isEmptyPair = function(t3) {
    return 0 === t3.length;
  }, e2.prototype.findNextPair = function(t3, r2, n2) {
    var o2 = this.getDecodeFinderCounters();
    o2[0] = 0, o2[1] = 0, o2[2] = 0, o2[3] = 0;
    var i2, a2 = t3.getSize();
    if (n2 >= 0)
      i2 = n2;
    else if (this.isEmptyPair(r2))
      i2 = 0;
    else {
      i2 = r2[r2.length - 1].getFinderPattern().getStartEnd()[1];
    }
    var s2 = r2.length % 2 != 0;
    this.startFromEven && (s2 = !s2);
    for (var u2 = false; i2 < a2 && (u2 = !t3.get(i2)); )
      i2++;
    for (var c2 = 0, f3 = i2, h2 = i2; h2 < a2; h2++)
      if (t3.get(h2) !== u2)
        o2[c2]++;
      else {
        if (3 === c2) {
          if (s2 && e2.reverseCounters(o2), e2.isFinderPattern(o2))
            return this.startEnd[0] = f3, void (this.startEnd[1] = h2);
          s2 && e2.reverseCounters(o2), f3 += o2[0] + o2[1], o2[0] = o2[2], o2[1] = o2[3], o2[2] = 0, o2[3] = 0, c2--;
        } else
          c2++;
        o2[c2] = 1, u2 = !u2;
      }
    throw new tt();
  }, e2.reverseCounters = function(t3) {
    for (var e3 = t3.length, r2 = 0; r2 < e3 / 2; ++r2) {
      var n2 = t3[r2];
      t3[r2] = t3[e3 - r2 - 1], t3[e3 - r2 - 1] = n2;
    }
  }, e2.prototype.parseFoundFinderPattern = function(t3, r2, n2) {
    var o2, i2, a2;
    if (n2) {
      for (var s2 = this.startEnd[0] - 1; s2 >= 0 && !t3.get(s2); )
        s2--;
      s2++, o2 = this.startEnd[0] - s2, i2 = s2, a2 = this.startEnd[1];
    } else
      i2 = this.startEnd[0], o2 = (a2 = t3.getNextUnset(this.startEnd[1] + 1)) - this.startEnd[1];
    var u2, c2 = this.getDecodeFinderCounters();
    D.arraycopy(c2, 0, c2, 1, c2.length - 1), c2[0] = o2;
    try {
      u2 = this.parseFinderValue(c2, e2.FINDER_PATTERNS);
    } catch (t4) {
      return null;
    }
    return new Fe(u2, [i2, a2], i2, a2, r2);
  }, e2.prototype.decodeDataCharacter = function(t3, r2, n2, o2) {
    for (var i2 = this.getDataCharacterCounters(), a2 = 0; a2 < i2.length; a2++)
      i2[a2] = 0;
    if (o2)
      e2.recordPatternInReverse(t3, r2.getStartEnd()[0], i2);
    else {
      e2.recordPattern(t3, r2.getStartEnd()[1], i2);
      for (var s2 = 0, u2 = i2.length - 1; s2 < u2; s2++, u2--) {
        var c2 = i2[s2];
        i2[s2] = i2[u2], i2[u2] = c2;
      }
    }
    var f3 = Pt.sum(new Int32Array(i2)) / 17, h2 = (r2.getStartEnd()[1] - r2.getStartEnd()[0]) / 15;
    if (Math.abs(f3 - h2) / h2 > 0.3)
      throw new tt();
    var l2 = this.getOddCounts(), d2 = this.getEvenCounts(), p2 = this.getOddRoundingErrors(), g2 = this.getEvenRoundingErrors();
    for (s2 = 0; s2 < i2.length; s2++) {
      var y2 = 1 * i2[s2] / f3, w2 = y2 + 0.5;
      if (w2 < 1) {
        if (y2 < 0.3)
          throw new tt();
        w2 = 1;
      } else if (w2 > 8) {
        if (y2 > 8.7)
          throw new tt();
        w2 = 8;
      }
      var v2 = s2 / 2;
      0 == (1 & s2) ? (l2[v2] = w2, p2[v2] = y2 - w2) : (d2[v2] = w2, g2[v2] = y2 - w2);
    }
    this.adjustOddEvenCounts(17);
    var _2 = 4 * r2.getValue() + (n2 ? 0 : 2) + (o2 ? 0 : 1) - 1, A2 = 0, C2 = 0;
    for (s2 = l2.length - 1; s2 >= 0; s2--) {
      if (e2.isNotA1left(r2, n2, o2)) {
        var m2 = e2.WEIGHTS[_2][2 * s2];
        C2 += l2[s2] * m2;
      }
      A2 += l2[s2];
    }
    var E2 = 0;
    for (s2 = d2.length - 1; s2 >= 0; s2--)
      if (e2.isNotA1left(r2, n2, o2)) {
        m2 = e2.WEIGHTS[_2][2 * s2 + 1];
        E2 += d2[s2] * m2;
      }
    var I2 = C2 + E2;
    if (0 != (1 & A2) || A2 > 13 || A2 < 4)
      throw new tt();
    var S2 = (13 - A2) / 2, T2 = e2.SYMBOL_WIDEST[S2], O2 = 9 - T2, b2 = xe.getRSSvalue(l2, T2, true), R2 = xe.getRSSvalue(d2, O2, false), N10 = e2.EVEN_TOTAL_SUBSET[S2], D2 = e2.GSUM[S2];
    return new Le(b2 * N10 + R2 + D2, I2);
  }, e2.isNotA1left = function(t3, e3, r2) {
    return !(0 === t3.getValue() && e3 && r2);
  }, e2.prototype.adjustOddEvenCounts = function(t3) {
    var r2 = Pt.sum(new Int32Array(this.getOddCounts())), n2 = Pt.sum(new Int32Array(this.getEvenCounts())), o2 = false, i2 = false;
    r2 > 13 ? i2 = true : r2 < 4 && (o2 = true);
    var a2 = false, s2 = false;
    n2 > 13 ? s2 = true : n2 < 4 && (a2 = true);
    var u2 = r2 + n2 - t3, c2 = 1 == (1 & r2), f3 = 0 == (1 & n2);
    if (1 === u2)
      if (c2) {
        if (f3)
          throw new tt();
        i2 = true;
      } else {
        if (!f3)
          throw new tt();
        s2 = true;
      }
    else if (-1 === u2)
      if (c2) {
        if (f3)
          throw new tt();
        o2 = true;
      } else {
        if (!f3)
          throw new tt();
        a2 = true;
      }
    else {
      if (0 !== u2)
        throw new tt();
      if (c2) {
        if (!f3)
          throw new tt();
        r2 < n2 ? (o2 = true, s2 = true) : (i2 = true, a2 = true);
      } else if (f3)
        throw new tt();
    }
    if (o2) {
      if (i2)
        throw new tt();
      e2.increment(this.getOddCounts(), this.getOddRoundingErrors());
    }
    if (i2 && e2.decrement(this.getOddCounts(), this.getOddRoundingErrors()), a2) {
      if (s2)
        throw new tt();
      e2.increment(this.getEvenCounts(), this.getOddRoundingErrors());
    }
    s2 && e2.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
  }, e2.SYMBOL_WIDEST = [7, 5, 4, 3, 1], e2.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204], e2.GSUM = [0, 348, 1388, 2948, 3988], e2.FINDER_PATTERNS = [Int32Array.from([1, 8, 4, 1]), Int32Array.from([3, 6, 4, 1]), Int32Array.from([3, 4, 6, 1]), Int32Array.from([3, 2, 8, 1]), Int32Array.from([2, 6, 5, 1]), Int32Array.from([2, 2, 9, 1])], e2.WEIGHTS = [[1, 3, 9, 27, 81, 32, 96, 77], [20, 60, 180, 118, 143, 7, 21, 63], [189, 145, 13, 39, 117, 140, 209, 205], [193, 157, 49, 147, 19, 57, 171, 91], [62, 186, 136, 197, 169, 85, 44, 132], [185, 133, 188, 142, 4, 12, 36, 108], [113, 128, 173, 97, 80, 29, 87, 50], [150, 28, 84, 41, 123, 158, 52, 156], [46, 138, 203, 187, 139, 206, 196, 166], [76, 17, 51, 153, 37, 111, 122, 155], [43, 129, 176, 106, 107, 110, 119, 146], [16, 48, 144, 10, 30, 90, 59, 177], [109, 116, 137, 200, 178, 112, 125, 164], [70, 210, 208, 202, 184, 130, 179, 115], [134, 191, 151, 31, 93, 68, 204, 190], [148, 22, 66, 198, 172, 94, 71, 2], [6, 18, 54, 162, 64, 192, 154, 40], [120, 149, 25, 75, 14, 42, 126, 167], [79, 26, 78, 23, 69, 207, 199, 175], [103, 98, 83, 38, 114, 131, 182, 124], [161, 61, 183, 127, 170, 88, 53, 159], [55, 165, 73, 8, 24, 72, 5, 15], [45, 135, 194, 160, 58, 174, 100, 89]], e2.FINDER_PAT_A = 0, e2.FINDER_PAT_B = 1, e2.FINDER_PAT_C = 2, e2.FINDER_PAT_D = 3, e2.FINDER_PAT_E = 4, e2.FINDER_PAT_F = 5, e2.FINDER_PATTERN_SEQUENCES = [[e2.FINDER_PAT_A, e2.FINDER_PAT_A], [e2.FINDER_PAT_A, e2.FINDER_PAT_B, e2.FINDER_PAT_B], [e2.FINDER_PAT_A, e2.FINDER_PAT_C, e2.FINDER_PAT_B, e2.FINDER_PAT_D], [e2.FINDER_PAT_A, e2.FINDER_PAT_E, e2.FINDER_PAT_B, e2.FINDER_PAT_D, e2.FINDER_PAT_C], [e2.FINDER_PAT_A, e2.FINDER_PAT_E, e2.FINDER_PAT_B, e2.FINDER_PAT_D, e2.FINDER_PAT_D, e2.FINDER_PAT_F], [e2.FINDER_PAT_A, e2.FINDER_PAT_E, e2.FINDER_PAT_B, e2.FINDER_PAT_D, e2.FINDER_PAT_E, e2.FINDER_PAT_F, e2.FINDER_PAT_F], [e2.FINDER_PAT_A, e2.FINDER_PAT_A, e2.FINDER_PAT_B, e2.FINDER_PAT_B, e2.FINDER_PAT_C, e2.FINDER_PAT_C, e2.FINDER_PAT_D, e2.FINDER_PAT_D], [e2.FINDER_PAT_A, e2.FINDER_PAT_A, e2.FINDER_PAT_B, e2.FINDER_PAT_B, e2.FINDER_PAT_C, e2.FINDER_PAT_C, e2.FINDER_PAT_D, e2.FINDER_PAT_E, e2.FINDER_PAT_E], [e2.FINDER_PAT_A, e2.FINDER_PAT_A, e2.FINDER_PAT_B, e2.FINDER_PAT_B, e2.FINDER_PAT_C, e2.FINDER_PAT_C, e2.FINDER_PAT_D, e2.FINDER_PAT_E, e2.FINDER_PAT_F, e2.FINDER_PAT_F], [e2.FINDER_PAT_A, e2.FINDER_PAT_A, e2.FINDER_PAT_B, e2.FINDER_PAT_B, e2.FINDER_PAT_C, e2.FINDER_PAT_D, e2.FINDER_PAT_D, e2.FINDER_PAT_E, e2.FINDER_PAT_E, e2.FINDER_PAT_F, e2.FINDER_PAT_F]], e2.MAX_PAIRS = 11, e2;
}(Be);
var Er = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Ir = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this, e3, r2) || this;
    return o2.count = 0, o2.finderPattern = n2, o2;
  }
  return Er(e2, t2), e2.prototype.getFinderPattern = function() {
    return this.finderPattern;
  }, e2.prototype.getCount = function() {
    return this.count;
  }, e2.prototype.incrementCount = function() {
    this.count++;
  }, e2;
}(Le);
var Sr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Tr = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Or = function(t2) {
  function e2() {
    var e3 = null !== t2 && t2.apply(this, arguments) || this;
    return e3.possibleLeftPairs = [], e3.possibleRightPairs = [], e3;
  }
  return Sr(e2, t2), e2.prototype.decodeRow = function(t3, r2, n2) {
    var o2, i2, a2, s2, u2 = this.decodePair(r2, false, t3, n2);
    e2.addOrTally(this.possibleLeftPairs, u2), r2.reverse();
    var c2 = this.decodePair(r2, true, t3, n2);
    e2.addOrTally(this.possibleRightPairs, c2), r2.reverse();
    try {
      for (var f3 = Tr(this.possibleLeftPairs), h2 = f3.next(); !h2.done; h2 = f3.next()) {
        var l2 = h2.value;
        if (l2.getCount() > 1)
          try {
            for (var d2 = (a2 = void 0, Tr(this.possibleRightPairs)), p2 = d2.next(); !p2.done; p2 = d2.next()) {
              var g2 = p2.value;
              if (g2.getCount() > 1 && e2.checkChecksum(l2, g2))
                return e2.constructResult(l2, g2);
            }
          } catch (t4) {
            a2 = { error: t4 };
          } finally {
            try {
              p2 && !p2.done && (s2 = d2.return) && s2.call(d2);
            } finally {
              if (a2)
                throw a2.error;
            }
          }
      }
    } catch (t4) {
      o2 = { error: t4 };
    } finally {
      try {
        h2 && !h2.done && (i2 = f3.return) && i2.call(f3);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    throw new tt();
  }, e2.addOrTally = function(t3, e3) {
    var r2, n2;
    if (null != e3) {
      var o2 = false;
      try {
        for (var i2 = Tr(t3), a2 = i2.next(); !a2.done; a2 = i2.next()) {
          var s2 = a2.value;
          if (s2.getValue() === e3.getValue()) {
            s2.incrementCount(), o2 = true;
            break;
          }
        }
      } catch (t4) {
        r2 = { error: t4 };
      } finally {
        try {
          a2 && !a2.done && (n2 = i2.return) && n2.call(i2);
        } finally {
          if (r2)
            throw r2.error;
        }
      }
      o2 || t3.push(e3);
    }
  }, e2.prototype.reset = function() {
    this.possibleLeftPairs.length = 0, this.possibleRightPairs.length = 0;
  }, e2.constructResult = function(t3, e3) {
    for (var r2 = 4537077 * t3.getValue() + e3.getValue(), n2 = new String(r2).toString(), o2 = new Q(), i2 = 13 - n2.length; i2 > 0; i2--)
      o2.append("0");
    o2.append(n2);
    var a2 = 0;
    for (i2 = 0; i2 < 13; i2++) {
      var s2 = o2.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
      a2 += 0 == (1 & i2) ? 3 * s2 : s2;
    }
    10 === (a2 = 10 - a2 % 10) && (a2 = 0), o2.append(a2.toString());
    var u2 = t3.getFinderPattern().getResultPoints(), c2 = e3.getFinderPattern().getResultPoints();
    return new gt(o2.toString(), null, 0, [u2[0], u2[1], c2[0], c2[1]], wt.RSS_14, (/* @__PURE__ */ new Date()).getTime());
  }, e2.checkChecksum = function(t3, e3) {
    var r2 = (t3.getChecksumPortion() + 16 * e3.getChecksumPortion()) % 79, n2 = 9 * t3.getFinderPattern().getValue() + e3.getFinderPattern().getValue();
    return n2 > 72 && n2--, n2 > 8 && n2--, r2 === n2;
  }, e2.prototype.decodePair = function(t3, e3, r2, n2) {
    try {
      var o2 = this.findFinderPattern(t3, e3), i2 = this.parseFoundFinderPattern(t3, r2, e3, o2), a2 = null == n2 ? null : n2.get(U.NEED_RESULT_POINT_CALLBACK);
      if (null != a2) {
        var s2 = (o2[0] + o2[1]) / 2;
        e3 && (s2 = t3.getSize() - 1 - s2), a2.foundPossibleResultPoint(new Lt(s2, r2));
      }
      var u2 = this.decodeDataCharacter(t3, i2, true), c2 = this.decodeDataCharacter(t3, i2, false);
      return new Ir(1597 * u2.getValue() + c2.getValue(), u2.getChecksumPortion() + 4 * c2.getChecksumPortion(), i2);
    } catch (t4) {
      return null;
    }
  }, e2.prototype.decodeDataCharacter = function(t3, r2, n2) {
    for (var o2 = this.getDataCharacterCounters(), i2 = 0; i2 < o2.length; i2++)
      o2[i2] = 0;
    if (n2)
      Kt.recordPatternInReverse(t3, r2.getStartEnd()[0], o2);
    else {
      Kt.recordPattern(t3, r2.getStartEnd()[1] + 1, o2);
      for (var a2 = 0, s2 = o2.length - 1; a2 < s2; a2++, s2--) {
        var u2 = o2[a2];
        o2[a2] = o2[s2], o2[s2] = u2;
      }
    }
    var c2 = n2 ? 16 : 15, f3 = Pt.sum(new Int32Array(o2)) / c2, h2 = this.getOddCounts(), l2 = this.getEvenCounts(), d2 = this.getOddRoundingErrors(), p2 = this.getEvenRoundingErrors();
    for (a2 = 0; a2 < o2.length; a2++) {
      var g2 = o2[a2] / f3, y2 = Math.floor(g2 + 0.5);
      y2 < 1 ? y2 = 1 : y2 > 8 && (y2 = 8);
      var w2 = Math.floor(a2 / 2);
      0 == (1 & a2) ? (h2[w2] = y2, d2[w2] = g2 - y2) : (l2[w2] = y2, p2[w2] = g2 - y2);
    }
    this.adjustOddEvenCounts(n2, c2);
    var v2 = 0, _2 = 0;
    for (a2 = h2.length - 1; a2 >= 0; a2--)
      _2 *= 9, _2 += h2[a2], v2 += h2[a2];
    var A2 = 0, C2 = 0;
    for (a2 = l2.length - 1; a2 >= 0; a2--)
      A2 *= 9, A2 += l2[a2], C2 += l2[a2];
    var m2 = _2 + 3 * A2;
    if (n2) {
      if (0 != (1 & v2) || v2 > 12 || v2 < 4)
        throw new tt();
      var E2 = (12 - v2) / 2, I2 = 9 - (R2 = e2.OUTSIDE_ODD_WIDEST[E2]), S2 = xe.getRSSvalue(h2, R2, false), T2 = xe.getRSSvalue(l2, I2, true), O2 = e2.OUTSIDE_EVEN_TOTAL_SUBSET[E2], b2 = e2.OUTSIDE_GSUM[E2];
      return new Le(S2 * O2 + T2 + b2, m2);
    }
    if (0 != (1 & C2) || C2 > 10 || C2 < 4)
      throw new tt();
    E2 = (10 - C2) / 2, I2 = 9 - (R2 = e2.INSIDE_ODD_WIDEST[E2]), S2 = xe.getRSSvalue(h2, R2, true), T2 = xe.getRSSvalue(l2, I2, false);
    var R2, N10 = e2.INSIDE_ODD_TOTAL_SUBSET[E2];
    b2 = e2.INSIDE_GSUM[E2];
    return new Le(T2 * N10 + S2 + b2, m2);
  }, e2.prototype.findFinderPattern = function(t3, e3) {
    var r2 = this.getDecodeFinderCounters();
    r2[0] = 0, r2[1] = 0, r2[2] = 0, r2[3] = 0;
    for (var n2 = t3.getSize(), o2 = false, i2 = 0; i2 < n2 && e3 !== (o2 = !t3.get(i2)); )
      i2++;
    for (var a2 = 0, s2 = i2, u2 = i2; u2 < n2; u2++)
      if (t3.get(u2) !== o2)
        r2[a2]++;
      else {
        if (3 === a2) {
          if (Be.isFinderPattern(r2))
            return [s2, u2];
          s2 += r2[0] + r2[1], r2[0] = r2[2], r2[1] = r2[3], r2[2] = 0, r2[3] = 0, a2--;
        } else
          a2++;
        r2[a2] = 1, o2 = !o2;
      }
    throw new tt();
  }, e2.prototype.parseFoundFinderPattern = function(t3, r2, n2, o2) {
    for (var i2 = t3.get(o2[0]), a2 = o2[0] - 1; a2 >= 0 && i2 !== t3.get(a2); )
      a2--;
    a2++;
    var s2 = o2[0] - a2, u2 = this.getDecodeFinderCounters(), c2 = new Int32Array(u2.length);
    D.arraycopy(u2, 0, c2, 1, u2.length - 1), c2[0] = s2;
    var f3 = this.parseFinderValue(c2, e2.FINDER_PATTERNS), h2 = a2, l2 = o2[1];
    return n2 && (h2 = t3.getSize() - 1 - h2, l2 = t3.getSize() - 1 - l2), new Fe(f3, [a2, o2[1]], h2, l2, r2);
  }, e2.prototype.adjustOddEvenCounts = function(t3, e3) {
    var r2 = Pt.sum(new Int32Array(this.getOddCounts())), n2 = Pt.sum(new Int32Array(this.getEvenCounts())), o2 = false, i2 = false, a2 = false, s2 = false;
    t3 ? (r2 > 12 ? i2 = true : r2 < 4 && (o2 = true), n2 > 12 ? s2 = true : n2 < 4 && (a2 = true)) : (r2 > 11 ? i2 = true : r2 < 5 && (o2 = true), n2 > 10 ? s2 = true : n2 < 4 && (a2 = true));
    var u2 = r2 + n2 - e3, c2 = (1 & r2) == (t3 ? 1 : 0), f3 = 1 == (1 & n2);
    if (1 === u2)
      if (c2) {
        if (f3)
          throw new tt();
        i2 = true;
      } else {
        if (!f3)
          throw new tt();
        s2 = true;
      }
    else if (-1 === u2)
      if (c2) {
        if (f3)
          throw new tt();
        o2 = true;
      } else {
        if (!f3)
          throw new tt();
        a2 = true;
      }
    else {
      if (0 !== u2)
        throw new tt();
      if (c2) {
        if (!f3)
          throw new tt();
        r2 < n2 ? (o2 = true, s2 = true) : (i2 = true, a2 = true);
      } else if (f3)
        throw new tt();
    }
    if (o2) {
      if (i2)
        throw new tt();
      Be.increment(this.getOddCounts(), this.getOddRoundingErrors());
    }
    if (i2 && Be.decrement(this.getOddCounts(), this.getOddRoundingErrors()), a2) {
      if (s2)
        throw new tt();
      Be.increment(this.getEvenCounts(), this.getOddRoundingErrors());
    }
    s2 && Be.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
  }, e2.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126], e2.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81], e2.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715], e2.INSIDE_GSUM = [0, 336, 1036, 1516], e2.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1], e2.INSIDE_ODD_WIDEST = [2, 4, 6, 8], e2.FINDER_PATTERNS = [Int32Array.from([3, 8, 2, 1]), Int32Array.from([3, 5, 5, 1]), Int32Array.from([3, 3, 7, 1]), Int32Array.from([3, 1, 9, 1]), Int32Array.from([2, 7, 4, 1]), Int32Array.from([2, 5, 6, 1]), Int32Array.from([2, 3, 8, 1]), Int32Array.from([1, 5, 7, 1]), Int32Array.from([1, 3, 9, 1])], e2;
}(Be);
var br = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Rr = function(t2) {
  function e2(e3) {
    var r2 = t2.call(this) || this;
    r2.readers = [];
    var n2 = e3 ? e3.get(U.POSSIBLE_FORMATS) : null, o2 = e3 && void 0 !== e3.get(U.ASSUME_CODE_39_CHECK_DIGIT);
    return n2 && ((n2.includes(wt.EAN_13) || n2.includes(wt.UPC_A) || n2.includes(wt.EAN_8) || n2.includes(wt.UPC_E)) && r2.readers.push(new Re(e3)), n2.includes(wt.CODE_39) && r2.readers.push(new te(o2)), n2.includes(wt.CODE_93) && r2.readers.push(new ne()), n2.includes(wt.CODE_128) && r2.readers.push(new Qt()), n2.includes(wt.ITF) && r2.readers.push(new ae()), n2.includes(wt.CODABAR) && r2.readers.push(new De()), n2.includes(wt.RSS_14) && r2.readers.push(new Or()), n2.includes(wt.RSS_EXPANDED) && (console.warn("RSS Expanded reader IS NOT ready for production yet! use at your own risk."), r2.readers.push(new mr()))), 0 === r2.readers.length && (r2.readers.push(new Re(e3)), r2.readers.push(new te()), r2.readers.push(new ne()), r2.readers.push(new Re(e3)), r2.readers.push(new Qt()), r2.readers.push(new ae()), r2.readers.push(new Or())), r2;
  }
  return br(e2, t2), e2.prototype.decodeRow = function(t3, e3, r2) {
    for (var n2 = 0; n2 < this.readers.length; n2++)
      try {
        return this.readers[n2].decodeRow(t3, e3, r2);
      } catch (t4) {
      }
    throw new tt();
  }, e2.prototype.reset = function() {
    this.readers.forEach(function(t3) {
      return t3.reset();
    });
  }, e2;
}(Kt);
var Nr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  function e2(e3, r2) {
    return void 0 === e3 && (e3 = 500), t2.call(this, new Rr(r2), e3, r2) || this;
  }
  Nr(e2, t2);
}(pt);
var Dr;
var Mr = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Pr = function() {
  function t2(t3, e2, r2) {
    this.ecCodewords = t3, this.ecBlocks = [e2], r2 && this.ecBlocks.push(r2);
  }
  return t2.prototype.getECCodewords = function() {
    return this.ecCodewords;
  }, t2.prototype.getECBlocks = function() {
    return this.ecBlocks;
  }, t2;
}();
var Br = function() {
  function t2(t3, e2) {
    this.count = t3, this.dataCodewords = e2;
  }
  return t2.prototype.getCount = function() {
    return this.count;
  }, t2.prototype.getDataCodewords = function() {
    return this.dataCodewords;
  }, t2;
}();
var Lr = function() {
  function t2(t3, e2, r2, n2, o2, i2) {
    var a2, s2;
    this.versionNumber = t3, this.symbolSizeRows = e2, this.symbolSizeColumns = r2, this.dataRegionSizeRows = n2, this.dataRegionSizeColumns = o2, this.ecBlocks = i2;
    var u2 = 0, c2 = i2.getECCodewords(), f3 = i2.getECBlocks();
    try {
      for (var h2 = Mr(f3), l2 = h2.next(); !l2.done; l2 = h2.next()) {
        var d2 = l2.value;
        u2 += d2.getCount() * (d2.getDataCodewords() + c2);
      }
    } catch (t4) {
      a2 = { error: t4 };
    } finally {
      try {
        l2 && !l2.done && (s2 = h2.return) && s2.call(h2);
      } finally {
        if (a2)
          throw a2.error;
      }
    }
    this.totalCodewords = u2;
  }
  return t2.prototype.getVersionNumber = function() {
    return this.versionNumber;
  }, t2.prototype.getSymbolSizeRows = function() {
    return this.symbolSizeRows;
  }, t2.prototype.getSymbolSizeColumns = function() {
    return this.symbolSizeColumns;
  }, t2.prototype.getDataRegionSizeRows = function() {
    return this.dataRegionSizeRows;
  }, t2.prototype.getDataRegionSizeColumns = function() {
    return this.dataRegionSizeColumns;
  }, t2.prototype.getTotalCodewords = function() {
    return this.totalCodewords;
  }, t2.prototype.getECBlocks = function() {
    return this.ecBlocks;
  }, t2.getVersionForDimensions = function(e2, r2) {
    var n2, o2;
    if (0 != (1 & e2) || 0 != (1 & r2))
      throw new G();
    try {
      for (var i2 = Mr(t2.VERSIONS), a2 = i2.next(); !a2.done; a2 = i2.next()) {
        var s2 = a2.value;
        if (s2.symbolSizeRows === e2 && s2.symbolSizeColumns === r2)
          return s2;
      }
    } catch (t3) {
      n2 = { error: t3 };
    } finally {
      try {
        a2 && !a2.done && (o2 = i2.return) && o2.call(i2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    throw new G();
  }, t2.prototype.toString = function() {
    return "" + this.versionNumber;
  }, t2.buildVersions = function() {
    return [new t2(1, 10, 10, 8, 8, new Pr(5, new Br(1, 3))), new t2(2, 12, 12, 10, 10, new Pr(7, new Br(1, 5))), new t2(3, 14, 14, 12, 12, new Pr(10, new Br(1, 8))), new t2(4, 16, 16, 14, 14, new Pr(12, new Br(1, 12))), new t2(5, 18, 18, 16, 16, new Pr(14, new Br(1, 18))), new t2(6, 20, 20, 18, 18, new Pr(18, new Br(1, 22))), new t2(7, 22, 22, 20, 20, new Pr(20, new Br(1, 30))), new t2(8, 24, 24, 22, 22, new Pr(24, new Br(1, 36))), new t2(9, 26, 26, 24, 24, new Pr(28, new Br(1, 44))), new t2(10, 32, 32, 14, 14, new Pr(36, new Br(1, 62))), new t2(11, 36, 36, 16, 16, new Pr(42, new Br(1, 86))), new t2(12, 40, 40, 18, 18, new Pr(48, new Br(1, 114))), new t2(13, 44, 44, 20, 20, new Pr(56, new Br(1, 144))), new t2(14, 48, 48, 22, 22, new Pr(68, new Br(1, 174))), new t2(15, 52, 52, 24, 24, new Pr(42, new Br(2, 102))), new t2(16, 64, 64, 14, 14, new Pr(56, new Br(2, 140))), new t2(17, 72, 72, 16, 16, new Pr(36, new Br(4, 92))), new t2(18, 80, 80, 18, 18, new Pr(48, new Br(4, 114))), new t2(19, 88, 88, 20, 20, new Pr(56, new Br(4, 144))), new t2(20, 96, 96, 22, 22, new Pr(68, new Br(4, 174))), new t2(21, 104, 104, 24, 24, new Pr(56, new Br(6, 136))), new t2(22, 120, 120, 18, 18, new Pr(68, new Br(6, 175))), new t2(23, 132, 132, 20, 20, new Pr(62, new Br(8, 163))), new t2(24, 144, 144, 22, 22, new Pr(62, new Br(8, 156), new Br(2, 155))), new t2(25, 8, 18, 6, 16, new Pr(7, new Br(1, 5))), new t2(26, 8, 32, 6, 14, new Pr(11, new Br(1, 10))), new t2(27, 12, 26, 10, 24, new Pr(14, new Br(1, 16))), new t2(28, 12, 36, 10, 16, new Pr(18, new Br(1, 22))), new t2(29, 16, 36, 14, 16, new Pr(24, new Br(1, 32))), new t2(30, 16, 48, 14, 22, new Pr(28, new Br(1, 49)))];
  }, t2.VERSIONS = t2.buildVersions(), t2;
}();
var Fr = function() {
  function t2(e2) {
    var r2 = e2.getHeight();
    if (r2 < 8 || r2 > 144 || 0 != (1 & r2))
      throw new G();
    this.version = t2.readVersion(e2), this.mappingBitMatrix = this.extractDataRegion(e2), this.readMappingMatrix = new J(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
  }
  return t2.prototype.getVersion = function() {
    return this.version;
  }, t2.readVersion = function(t3) {
    var e2 = t3.getHeight(), r2 = t3.getWidth();
    return Lr.getVersionForDimensions(e2, r2);
  }, t2.prototype.readCodewords = function() {
    var t3 = new Int8Array(this.version.getTotalCodewords()), e2 = 0, r2 = 4, n2 = 0, o2 = this.mappingBitMatrix.getHeight(), i2 = this.mappingBitMatrix.getWidth(), a2 = false, s2 = false, u2 = false, c2 = false;
    do {
      if (r2 !== o2 || 0 !== n2 || a2)
        if (r2 !== o2 - 2 || 0 !== n2 || 0 == (3 & i2) || s2)
          if (r2 !== o2 + 4 || 2 !== n2 || 0 != (7 & i2) || u2)
            if (r2 !== o2 - 2 || 0 !== n2 || 4 != (7 & i2) || c2) {
              do {
                r2 < o2 && n2 >= 0 && !this.readMappingMatrix.get(n2, r2) && (t3[e2++] = 255 & this.readUtah(r2, n2, o2, i2)), r2 -= 2, n2 += 2;
              } while (r2 >= 0 && n2 < i2);
              r2 += 1, n2 += 3;
              do {
                r2 >= 0 && n2 < i2 && !this.readMappingMatrix.get(n2, r2) && (t3[e2++] = 255 & this.readUtah(r2, n2, o2, i2)), r2 += 2, n2 -= 2;
              } while (r2 < o2 && n2 >= 0);
              r2 += 3, n2 += 1;
            } else
              t3[e2++] = 255 & this.readCorner4(o2, i2), r2 -= 2, n2 += 2, c2 = true;
          else
            t3[e2++] = 255 & this.readCorner3(o2, i2), r2 -= 2, n2 += 2, u2 = true;
        else
          t3[e2++] = 255 & this.readCorner2(o2, i2), r2 -= 2, n2 += 2, s2 = true;
      else
        t3[e2++] = 255 & this.readCorner1(o2, i2), r2 -= 2, n2 += 2, a2 = true;
    } while (r2 < o2 || n2 < i2);
    if (e2 !== this.version.getTotalCodewords())
      throw new G();
    return t3;
  }, t2.prototype.readModule = function(t3, e2, r2, n2) {
    return t3 < 0 && (t3 += r2, e2 += 4 - (r2 + 4 & 7)), e2 < 0 && (e2 += n2, t3 += 4 - (n2 + 4 & 7)), this.readMappingMatrix.set(e2, t3), this.mappingBitMatrix.get(e2, t3);
  }, t2.prototype.readUtah = function(t3, e2, r2, n2) {
    var o2 = 0;
    return this.readModule(t3 - 2, e2 - 2, r2, n2) && (o2 |= 1), o2 <<= 1, this.readModule(t3 - 2, e2 - 1, r2, n2) && (o2 |= 1), o2 <<= 1, this.readModule(t3 - 1, e2 - 2, r2, n2) && (o2 |= 1), o2 <<= 1, this.readModule(t3 - 1, e2 - 1, r2, n2) && (o2 |= 1), o2 <<= 1, this.readModule(t3 - 1, e2, r2, n2) && (o2 |= 1), o2 <<= 1, this.readModule(t3, e2 - 2, r2, n2) && (o2 |= 1), o2 <<= 1, this.readModule(t3, e2 - 1, r2, n2) && (o2 |= 1), o2 <<= 1, this.readModule(t3, e2, r2, n2) && (o2 |= 1), o2;
  }, t2.prototype.readCorner1 = function(t3, e2) {
    var r2 = 0;
    return this.readModule(t3 - 1, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(t3 - 1, 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(t3 - 1, 2, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 2, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(1, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(2, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(3, e2 - 1, t3, e2) && (r2 |= 1), r2;
  }, t2.prototype.readCorner2 = function(t3, e2) {
    var r2 = 0;
    return this.readModule(t3 - 3, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(t3 - 2, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(t3 - 1, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 4, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 3, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 2, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(1, e2 - 1, t3, e2) && (r2 |= 1), r2;
  }, t2.prototype.readCorner3 = function(t3, e2) {
    var r2 = 0;
    return this.readModule(t3 - 1, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(t3 - 1, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 3, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 2, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(1, e2 - 3, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(1, e2 - 2, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(1, e2 - 1, t3, e2) && (r2 |= 1), r2;
  }, t2.prototype.readCorner4 = function(t3, e2) {
    var r2 = 0;
    return this.readModule(t3 - 3, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(t3 - 2, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(t3 - 1, 0, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 2, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(0, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(1, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(2, e2 - 1, t3, e2) && (r2 |= 1), r2 <<= 1, this.readModule(3, e2 - 1, t3, e2) && (r2 |= 1), r2;
  }, t2.prototype.extractDataRegion = function(t3) {
    var e2 = this.version.getSymbolSizeRows(), r2 = this.version.getSymbolSizeColumns();
    if (t3.getHeight() !== e2)
      throw new T("Dimension of bitMatrix must match the version size");
    for (var n2 = this.version.getDataRegionSizeRows(), o2 = this.version.getDataRegionSizeColumns(), i2 = e2 / n2 | 0, a2 = r2 / o2 | 0, s2 = new J(a2 * o2, i2 * n2), u2 = 0; u2 < i2; ++u2)
      for (var c2 = u2 * n2, f3 = 0; f3 < a2; ++f3)
        for (var h2 = f3 * o2, l2 = 0; l2 < n2; ++l2)
          for (var d2 = u2 * (n2 + 2) + 1 + l2, p2 = c2 + l2, g2 = 0; g2 < o2; ++g2) {
            var y2 = f3 * (o2 + 2) + 1 + g2;
            if (t3.get(y2, d2)) {
              var w2 = h2 + g2;
              s2.set(w2, p2);
            }
          }
    return s2;
  }, t2;
}();
var kr = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var xr = function() {
  function t2(t3, e2) {
    this.numDataCodewords = t3, this.codewords = e2;
  }
  return t2.getDataBlocks = function(e2, r2) {
    var n2, o2, i2, a2, s2 = r2.getECBlocks(), u2 = 0, c2 = s2.getECBlocks();
    try {
      for (var f3 = kr(c2), h2 = f3.next(); !h2.done; h2 = f3.next()) {
        u2 += (y2 = h2.value).getCount();
      }
    } catch (t3) {
      n2 = { error: t3 };
    } finally {
      try {
        h2 && !h2.done && (o2 = f3.return) && o2.call(f3);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    var l2 = new Array(u2), d2 = 0;
    try {
      for (var p2 = kr(c2), g2 = p2.next(); !g2.done; g2 = p2.next())
        for (var y2 = g2.value, w2 = 0; w2 < y2.getCount(); w2++) {
          var v2 = y2.getDataCodewords(), _2 = s2.getECCodewords() + v2;
          l2[d2++] = new t2(v2, new Uint8Array(_2));
        }
    } catch (t3) {
      i2 = { error: t3 };
    } finally {
      try {
        g2 && !g2.done && (a2 = p2.return) && a2.call(p2);
      } finally {
        if (i2)
          throw i2.error;
      }
    }
    var A2 = l2[0].codewords.length - s2.getECCodewords(), C2 = A2 - 1, m2 = 0;
    for (w2 = 0; w2 < C2; w2++)
      for (var E2 = 0; E2 < d2; E2++)
        l2[E2].codewords[w2] = e2[m2++];
    var I2 = 24 === r2.getVersionNumber(), S2 = I2 ? 8 : d2;
    for (E2 = 0; E2 < S2; E2++)
      l2[E2].codewords[A2 - 1] = e2[m2++];
    var O2 = l2[0].codewords.length;
    for (w2 = A2; w2 < O2; w2++)
      for (E2 = 0; E2 < d2; E2++) {
        var b2 = I2 ? (E2 + 8) % d2 : E2, R2 = I2 && b2 > 7 ? w2 - 1 : w2;
        l2[b2].codewords[R2] = e2[m2++];
      }
    if (m2 !== e2.length)
      throw new T();
    return l2;
  }, t2.prototype.getNumDataCodewords = function() {
    return this.numDataCodewords;
  }, t2.prototype.getCodewords = function() {
    return this.codewords;
  }, t2;
}();
var Vr = function() {
  function t2(t3) {
    this.bytes = t3, this.byteOffset = 0, this.bitOffset = 0;
  }
  return t2.prototype.getBitOffset = function() {
    return this.bitOffset;
  }, t2.prototype.getByteOffset = function() {
    return this.byteOffset;
  }, t2.prototype.readBits = function(t3) {
    if (t3 < 1 || t3 > 32 || t3 > this.available())
      throw new T("" + t3);
    var e2 = 0, r2 = this.bitOffset, n2 = this.byteOffset, o2 = this.bytes;
    if (r2 > 0) {
      var i2 = 8 - r2, a2 = t3 < i2 ? t3 : i2, s2 = 255 >> 8 - a2 << (u2 = i2 - a2);
      e2 = (o2[n2] & s2) >> u2, t3 -= a2, 8 === (r2 += a2) && (r2 = 0, n2++);
    }
    if (t3 > 0) {
      for (; t3 >= 8; )
        e2 = e2 << 8 | 255 & o2[n2], n2++, t3 -= 8;
      if (t3 > 0) {
        var u2;
        s2 = 255 >> (u2 = 8 - t3) << u2;
        e2 = e2 << t3 | (o2[n2] & s2) >> u2, r2 += t3;
      }
    }
    return this.bitOffset = r2, this.byteOffset = n2, e2;
  }, t2.prototype.available = function() {
    return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
  }, t2;
}();
!function(t2) {
  t2[t2.PAD_ENCODE = 0] = "PAD_ENCODE", t2[t2.ASCII_ENCODE = 1] = "ASCII_ENCODE", t2[t2.C40_ENCODE = 2] = "C40_ENCODE", t2[t2.TEXT_ENCODE = 3] = "TEXT_ENCODE", t2[t2.ANSIX12_ENCODE = 4] = "ANSIX12_ENCODE", t2[t2.EDIFACT_ENCODE = 5] = "EDIFACT_ENCODE", t2[t2.BASE256_ENCODE = 6] = "BASE256_ENCODE";
}(Dr || (Dr = {}));
var Hr;
var Ur = function() {
  function t2() {
  }
  return t2.decode = function(t3) {
    var e2 = new Vr(t3), r2 = new Q(), n2 = new Q(), o2 = new Array(), i2 = Dr.ASCII_ENCODE;
    do {
      if (i2 === Dr.ASCII_ENCODE)
        i2 = this.decodeAsciiSegment(e2, r2, n2);
      else {
        switch (i2) {
          case Dr.C40_ENCODE:
            this.decodeC40Segment(e2, r2);
            break;
          case Dr.TEXT_ENCODE:
            this.decodeTextSegment(e2, r2);
            break;
          case Dr.ANSIX12_ENCODE:
            this.decodeAnsiX12Segment(e2, r2);
            break;
          case Dr.EDIFACT_ENCODE:
            this.decodeEdifactSegment(e2, r2);
            break;
          case Dr.BASE256_ENCODE:
            this.decodeBase256Segment(e2, r2, o2);
            break;
          default:
            throw new G();
        }
        i2 = Dr.ASCII_ENCODE;
      }
    } while (i2 !== Dr.PAD_ENCODE && e2.available() > 0);
    return n2.length() > 0 && r2.append(n2.toString()), new At(t3, r2.toString(), 0 === o2.length ? null : o2, null);
  }, t2.decodeAsciiSegment = function(t3, e2, r2) {
    var n2 = false;
    do {
      var o2 = t3.readBits(8);
      if (0 === o2)
        throw new G();
      if (o2 <= 128)
        return n2 && (o2 += 128), e2.append(String.fromCharCode(o2 - 1)), Dr.ASCII_ENCODE;
      if (129 === o2)
        return Dr.PAD_ENCODE;
      if (o2 <= 229) {
        var i2 = o2 - 130;
        i2 < 10 && e2.append("0"), e2.append("" + i2);
      } else
        switch (o2) {
          case 230:
            return Dr.C40_ENCODE;
          case 231:
            return Dr.BASE256_ENCODE;
          case 232:
            e2.append(String.fromCharCode(29));
            break;
          case 233:
          case 234:
          case 241:
            break;
          case 235:
            n2 = true;
            break;
          case 236:
            e2.append("[)>05"), r2.insert(0, "");
            break;
          case 237:
            e2.append("[)>06"), r2.insert(0, "");
            break;
          case 238:
            return Dr.ANSIX12_ENCODE;
          case 239:
            return Dr.TEXT_ENCODE;
          case 240:
            return Dr.EDIFACT_ENCODE;
          default:
            if (254 !== o2 || 0 !== t3.available())
              throw new G();
        }
    } while (t3.available() > 0);
    return Dr.ASCII_ENCODE;
  }, t2.decodeC40Segment = function(t3, e2) {
    var r2 = false, n2 = [], o2 = 0;
    do {
      if (8 === t3.available())
        return;
      var i2 = t3.readBits(8);
      if (254 === i2)
        return;
      this.parseTwoBytes(i2, t3.readBits(8), n2);
      for (var a2 = 0; a2 < 3; a2++) {
        var s2 = n2[a2];
        switch (o2) {
          case 0:
            if (s2 < 3)
              o2 = s2 + 1;
            else {
              if (!(s2 < this.C40_BASIC_SET_CHARS.length))
                throw new G();
              var u2 = this.C40_BASIC_SET_CHARS[s2];
              r2 ? (e2.append(String.fromCharCode(u2.charCodeAt(0) + 128)), r2 = false) : e2.append(u2);
            }
            break;
          case 1:
            r2 ? (e2.append(String.fromCharCode(s2 + 128)), r2 = false) : e2.append(String.fromCharCode(s2)), o2 = 0;
            break;
          case 2:
            if (s2 < this.C40_SHIFT2_SET_CHARS.length) {
              u2 = this.C40_SHIFT2_SET_CHARS[s2];
              r2 ? (e2.append(String.fromCharCode(u2.charCodeAt(0) + 128)), r2 = false) : e2.append(u2);
            } else
              switch (s2) {
                case 27:
                  e2.append(String.fromCharCode(29));
                  break;
                case 30:
                  r2 = true;
                  break;
                default:
                  throw new G();
              }
            o2 = 0;
            break;
          case 3:
            r2 ? (e2.append(String.fromCharCode(s2 + 224)), r2 = false) : e2.append(String.fromCharCode(s2 + 96)), o2 = 0;
            break;
          default:
            throw new G();
        }
      }
    } while (t3.available() > 0);
  }, t2.decodeTextSegment = function(t3, e2) {
    var r2 = false, n2 = [], o2 = 0;
    do {
      if (8 === t3.available())
        return;
      var i2 = t3.readBits(8);
      if (254 === i2)
        return;
      this.parseTwoBytes(i2, t3.readBits(8), n2);
      for (var a2 = 0; a2 < 3; a2++) {
        var s2 = n2[a2];
        switch (o2) {
          case 0:
            if (s2 < 3)
              o2 = s2 + 1;
            else {
              if (!(s2 < this.TEXT_BASIC_SET_CHARS.length))
                throw new G();
              var u2 = this.TEXT_BASIC_SET_CHARS[s2];
              r2 ? (e2.append(String.fromCharCode(u2.charCodeAt(0) + 128)), r2 = false) : e2.append(u2);
            }
            break;
          case 1:
            r2 ? (e2.append(String.fromCharCode(s2 + 128)), r2 = false) : e2.append(String.fromCharCode(s2)), o2 = 0;
            break;
          case 2:
            if (s2 < this.TEXT_SHIFT2_SET_CHARS.length) {
              u2 = this.TEXT_SHIFT2_SET_CHARS[s2];
              r2 ? (e2.append(String.fromCharCode(u2.charCodeAt(0) + 128)), r2 = false) : e2.append(u2);
            } else
              switch (s2) {
                case 27:
                  e2.append(String.fromCharCode(29));
                  break;
                case 30:
                  r2 = true;
                  break;
                default:
                  throw new G();
              }
            o2 = 0;
            break;
          case 3:
            if (!(s2 < this.TEXT_SHIFT3_SET_CHARS.length))
              throw new G();
            u2 = this.TEXT_SHIFT3_SET_CHARS[s2];
            r2 ? (e2.append(String.fromCharCode(u2.charCodeAt(0) + 128)), r2 = false) : e2.append(u2), o2 = 0;
            break;
          default:
            throw new G();
        }
      }
    } while (t3.available() > 0);
  }, t2.decodeAnsiX12Segment = function(t3, e2) {
    var r2 = [];
    do {
      if (8 === t3.available())
        return;
      var n2 = t3.readBits(8);
      if (254 === n2)
        return;
      this.parseTwoBytes(n2, t3.readBits(8), r2);
      for (var o2 = 0; o2 < 3; o2++) {
        var i2 = r2[o2];
        switch (i2) {
          case 0:
            e2.append("\r");
            break;
          case 1:
            e2.append("*");
            break;
          case 2:
            e2.append(">");
            break;
          case 3:
            e2.append(" ");
            break;
          default:
            if (i2 < 14)
              e2.append(String.fromCharCode(i2 + 44));
            else {
              if (!(i2 < 40))
                throw new G();
              e2.append(String.fromCharCode(i2 + 51));
            }
        }
      }
    } while (t3.available() > 0);
  }, t2.parseTwoBytes = function(t3, e2, r2) {
    var n2 = (t3 << 8) + e2 - 1, o2 = Math.floor(n2 / 1600);
    r2[0] = o2, n2 -= 1600 * o2, o2 = Math.floor(n2 / 40), r2[1] = o2, r2[2] = n2 - 40 * o2;
  }, t2.decodeEdifactSegment = function(t3, e2) {
    do {
      if (t3.available() <= 16)
        return;
      for (var r2 = 0; r2 < 4; r2++) {
        var n2 = t3.readBits(6);
        if (31 === n2) {
          var o2 = 8 - t3.getBitOffset();
          return void (8 !== o2 && t3.readBits(o2));
        }
        0 == (32 & n2) && (n2 |= 64), e2.append(String.fromCharCode(n2));
      }
    } while (t3.available() > 0);
  }, t2.decodeBase256Segment = function(t3, e2, r2) {
    var n2, o2 = 1 + t3.getByteOffset(), i2 = this.unrandomize255State(t3.readBits(8), o2++);
    if ((n2 = 0 === i2 ? t3.available() / 8 | 0 : i2 < 250 ? i2 : 250 * (i2 - 249) + this.unrandomize255State(t3.readBits(8), o2++)) < 0)
      throw new G();
    for (var a2 = new Uint8Array(n2), s2 = 0; s2 < n2; s2++) {
      if (t3.available() < 8)
        throw new G();
      a2[s2] = this.unrandomize255State(t3.readBits(8), o2++);
    }
    r2.push(a2);
    try {
      e2.append(K.decode(a2, q.ISO88591));
    } catch (t4) {
      throw new Nt("Platform does not support required encoding: " + t4.message);
    }
  }, t2.unrandomize255State = function(t3, e2) {
    var r2 = t3 - (149 * e2 % 255 + 1);
    return r2 >= 0 ? r2 : r2 + 256;
  }, t2.C40_BASIC_SET_CHARS = ["*", "*", "*", " ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], t2.C40_SHIFT2_SET_CHARS = ["!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_"], t2.TEXT_BASIC_SET_CHARS = ["*", "*", "*", " ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], t2.TEXT_SHIFT2_SET_CHARS = t2.C40_SHIFT2_SET_CHARS, t2.TEXT_SHIFT3_SET_CHARS = ["`", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "{", "|", "}", "~", String.fromCharCode(127)], t2;
}();
var Xr = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Gr = function() {
  function t2() {
    this.rsDecoder = new Dt(Tt.DATA_MATRIX_FIELD_256);
  }
  return t2.prototype.decode = function(t3) {
    var e2, r2, n2 = new Fr(t3), o2 = n2.getVersion(), i2 = n2.readCodewords(), a2 = xr.getDataBlocks(i2, o2), s2 = 0;
    try {
      for (var u2 = Xr(a2), c2 = u2.next(); !c2.done; c2 = u2.next()) {
        s2 += c2.value.getNumDataCodewords();
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        c2 && !c2.done && (r2 = u2.return) && r2.call(u2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    for (var f3 = new Uint8Array(s2), h2 = a2.length, l2 = 0; l2 < h2; l2++) {
      var d2 = a2[l2], p2 = d2.getCodewords(), g2 = d2.getNumDataCodewords();
      this.correctErrors(p2, g2);
      for (var y2 = 0; y2 < g2; y2++)
        f3[y2 * h2 + l2] = p2[y2];
    }
    return Ur.decode(f3);
  }, t2.prototype.correctErrors = function(t3, e2) {
    var r2 = new Int32Array(t3);
    try {
      this.rsDecoder.decode(r2, t3.length - e2);
    } catch (t4) {
      throw new R();
    }
    for (var n2 = 0; n2 < e2; n2++)
      t3[n2] = r2[n2];
  }, t2;
}();
var Wr = function() {
  function t2(t3) {
    this.image = t3, this.rectangleDetector = new Vt(this.image);
  }
  return t2.prototype.detect = function() {
    var e2 = this.rectangleDetector.detect(), r2 = this.detectSolid1(e2);
    if ((r2 = this.detectSolid2(r2))[3] = this.correctTopRight(r2), !r2[3])
      throw new tt();
    var n2 = (r2 = this.shiftToModuleCenter(r2))[0], o2 = r2[1], i2 = r2[2], a2 = r2[3], s2 = this.transitionsBetween(n2, a2) + 1, u2 = this.transitionsBetween(i2, a2) + 1;
    1 == (1 & s2) && (s2 += 1), 1 == (1 & u2) && (u2 += 1), 4 * s2 < 7 * u2 && 4 * u2 < 7 * s2 && (s2 = u2 = Math.max(s2, u2));
    var c2 = t2.sampleGrid(this.image, n2, o2, i2, a2, s2, u2);
    return new Ft(c2, [n2, o2, i2, a2]);
  }, t2.shiftPoint = function(t3, e2, r2) {
    var n2 = (e2.getX() - t3.getX()) / (r2 + 1), o2 = (e2.getY() - t3.getY()) / (r2 + 1);
    return new Lt(t3.getX() + n2, t3.getY() + o2);
  }, t2.moveAway = function(t3, e2, r2) {
    var n2 = t3.getX(), o2 = t3.getY();
    return n2 < e2 ? n2 -= 1 : n2 += 1, o2 < r2 ? o2 -= 1 : o2 += 1, new Lt(n2, o2);
  }, t2.prototype.detectSolid1 = function(t3) {
    var e2 = t3[0], r2 = t3[1], n2 = t3[3], o2 = t3[2], i2 = this.transitionsBetween(e2, r2), a2 = this.transitionsBetween(r2, n2), s2 = this.transitionsBetween(n2, o2), u2 = this.transitionsBetween(o2, e2), c2 = i2, f3 = [o2, e2, r2, n2];
    return c2 > a2 && (c2 = a2, f3[0] = e2, f3[1] = r2, f3[2] = n2, f3[3] = o2), c2 > s2 && (c2 = s2, f3[0] = r2, f3[1] = n2, f3[2] = o2, f3[3] = e2), c2 > u2 && (f3[0] = n2, f3[1] = o2, f3[2] = e2, f3[3] = r2), f3;
  }, t2.prototype.detectSolid2 = function(e2) {
    var r2 = e2[0], n2 = e2[1], o2 = e2[2], i2 = e2[3], a2 = this.transitionsBetween(r2, i2), s2 = t2.shiftPoint(n2, o2, 4 * (a2 + 1)), u2 = t2.shiftPoint(o2, n2, 4 * (a2 + 1));
    return this.transitionsBetween(s2, r2) < this.transitionsBetween(u2, i2) ? (e2[0] = r2, e2[1] = n2, e2[2] = o2, e2[3] = i2) : (e2[0] = n2, e2[1] = o2, e2[2] = i2, e2[3] = r2), e2;
  }, t2.prototype.correctTopRight = function(e2) {
    var r2 = e2[0], n2 = e2[1], o2 = e2[2], i2 = e2[3], a2 = this.transitionsBetween(r2, i2), s2 = this.transitionsBetween(n2, i2), u2 = t2.shiftPoint(r2, n2, 4 * (s2 + 1)), c2 = t2.shiftPoint(o2, n2, 4 * (a2 + 1));
    a2 = this.transitionsBetween(u2, i2), s2 = this.transitionsBetween(c2, i2);
    var f3 = new Lt(i2.getX() + (o2.getX() - n2.getX()) / (a2 + 1), i2.getY() + (o2.getY() - n2.getY()) / (a2 + 1)), h2 = new Lt(i2.getX() + (r2.getX() - n2.getX()) / (s2 + 1), i2.getY() + (r2.getY() - n2.getY()) / (s2 + 1));
    return this.isValid(f3) ? this.isValid(h2) ? this.transitionsBetween(u2, f3) + this.transitionsBetween(c2, f3) > this.transitionsBetween(u2, h2) + this.transitionsBetween(c2, h2) ? f3 : h2 : f3 : this.isValid(h2) ? h2 : null;
  }, t2.prototype.shiftToModuleCenter = function(e2) {
    var r2 = e2[0], n2 = e2[1], o2 = e2[2], i2 = e2[3], a2 = this.transitionsBetween(r2, i2) + 1, s2 = this.transitionsBetween(o2, i2) + 1, u2 = t2.shiftPoint(r2, n2, 4 * s2), c2 = t2.shiftPoint(o2, n2, 4 * a2);
    1 == (1 & (a2 = this.transitionsBetween(u2, i2) + 1)) && (a2 += 1), 1 == (1 & (s2 = this.transitionsBetween(c2, i2) + 1)) && (s2 += 1);
    var f3, h2, l2 = (r2.getX() + n2.getX() + o2.getX() + i2.getX()) / 4, d2 = (r2.getY() + n2.getY() + o2.getY() + i2.getY()) / 4;
    return r2 = t2.moveAway(r2, l2, d2), n2 = t2.moveAway(n2, l2, d2), o2 = t2.moveAway(o2, l2, d2), i2 = t2.moveAway(i2, l2, d2), u2 = t2.shiftPoint(r2, n2, 4 * s2), u2 = t2.shiftPoint(u2, i2, 4 * a2), f3 = t2.shiftPoint(n2, r2, 4 * s2), f3 = t2.shiftPoint(f3, o2, 4 * a2), c2 = t2.shiftPoint(o2, i2, 4 * s2), c2 = t2.shiftPoint(c2, n2, 4 * a2), h2 = t2.shiftPoint(i2, o2, 4 * s2), [u2, f3, c2, h2 = t2.shiftPoint(h2, r2, 4 * a2)];
  }, t2.prototype.isValid = function(t3) {
    return t3.getX() >= 0 && t3.getX() < this.image.getWidth() && t3.getY() > 0 && t3.getY() < this.image.getHeight();
  }, t2.sampleGrid = function(t3, e2, r2, n2, o2, i2, a2) {
    return Wt.getInstance().sampleGrid(t3, i2, a2, 0.5, 0.5, i2 - 0.5, 0.5, i2 - 0.5, a2 - 0.5, 0.5, a2 - 0.5, e2.getX(), e2.getY(), o2.getX(), o2.getY(), n2.getX(), n2.getY(), r2.getX(), r2.getY());
  }, t2.prototype.transitionsBetween = function(t3, e2) {
    var r2 = Math.trunc(t3.getX()), n2 = Math.trunc(t3.getY()), o2 = Math.trunc(e2.getX()), i2 = Math.trunc(e2.getY()), a2 = Math.abs(i2 - n2) > Math.abs(o2 - r2);
    if (a2) {
      var s2 = r2;
      r2 = n2, n2 = s2, s2 = o2, o2 = i2, i2 = s2;
    }
    for (var u2 = Math.abs(o2 - r2), c2 = Math.abs(i2 - n2), f3 = -u2 / 2, h2 = n2 < i2 ? 1 : -1, l2 = r2 < o2 ? 1 : -1, d2 = 0, p2 = this.image.get(a2 ? n2 : r2, a2 ? r2 : n2), g2 = r2, y2 = n2; g2 !== o2; g2 += l2) {
      var w2 = this.image.get(a2 ? y2 : g2, a2 ? g2 : y2);
      if (w2 !== p2 && (d2++, p2 = w2), (f3 += c2) > 0) {
        if (y2 === i2)
          break;
        y2 += h2, f3 -= u2;
      }
    }
    return d2;
  }, t2;
}();
var zr = function() {
  function t2() {
    this.decoder = new Gr();
  }
  return t2.prototype.decode = function(e2, r2) {
    var n2, o2;
    if (void 0 === r2 && (r2 = null), null != r2 && r2.has(U.PURE_BARCODE)) {
      var i2 = t2.extractPureBits(e2.getBlackMatrix());
      n2 = this.decoder.decode(i2), o2 = t2.NO_POINTS;
    } else {
      var a2 = new Wr(e2.getBlackMatrix()).detect();
      n2 = this.decoder.decode(a2.getBits()), o2 = a2.getPoints();
    }
    var s2 = n2.getRawBytes(), u2 = new gt(n2.getText(), s2, 8 * s2.length, o2, wt.DATA_MATRIX, D.currentTimeMillis()), c2 = n2.getByteSegments();
    null != c2 && u2.putMetadata(_t.BYTE_SEGMENTS, c2);
    var f3 = n2.getECLevel();
    return null != f3 && u2.putMetadata(_t.ERROR_CORRECTION_LEVEL, f3), u2;
  }, t2.prototype.reset = function() {
  }, t2.extractPureBits = function(t3) {
    var e2 = t3.getTopLeftOnBit(), r2 = t3.getBottomRightOnBit();
    if (null == e2 || null == r2)
      throw new tt();
    var n2 = this.moduleSize(e2, t3), o2 = e2[1], i2 = r2[1], a2 = e2[0], s2 = (r2[0] - a2 + 1) / n2, u2 = (i2 - o2 + 1) / n2;
    if (s2 <= 0 || u2 <= 0)
      throw new tt();
    var c2 = n2 / 2;
    o2 += c2, a2 += c2;
    for (var f3 = new J(s2, u2), h2 = 0; h2 < u2; h2++)
      for (var l2 = o2 + h2 * n2, d2 = 0; d2 < s2; d2++)
        t3.get(a2 + d2 * n2, l2) && f3.set(d2, h2);
    return f3;
  }, t2.moduleSize = function(t3, e2) {
    for (var r2 = e2.getWidth(), n2 = t3[0], o2 = t3[1]; n2 < r2 && e2.get(n2, o2); )
      n2++;
    if (n2 === r2)
      throw new tt();
    var i2 = n2 - t3[0];
    if (0 === i2)
      throw new tt();
    return i2;
  }, t2.NO_POINTS = [], t2;
}();
var jr = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  function e2(e3) {
    return void 0 === e3 && (e3 = 500), t2.call(this, new zr(), e3) || this;
  }
  jr(e2, t2);
}(pt), function(t2) {
  t2[t2.L = 0] = "L", t2[t2.M = 1] = "M", t2[t2.Q = 2] = "Q", t2[t2.H = 3] = "H";
}(Hr || (Hr = {}));
var Yr;
var Zr = function() {
  function t2(e2, r2, n2) {
    this.value = e2, this.stringValue = r2, this.bits = n2, t2.FOR_BITS.set(n2, this), t2.FOR_VALUE.set(e2, this);
  }
  return t2.prototype.getValue = function() {
    return this.value;
  }, t2.prototype.getBits = function() {
    return this.bits;
  }, t2.fromString = function(e2) {
    switch (e2) {
      case "L":
        return t2.L;
      case "M":
        return t2.M;
      case "Q":
        return t2.Q;
      case "H":
        return t2.H;
      default:
        throw new I(e2 + "not available");
    }
  }, t2.prototype.toString = function() {
    return this.stringValue;
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.value === r2.value;
  }, t2.forBits = function(e2) {
    if (e2 < 0 || e2 >= t2.FOR_BITS.size)
      throw new T();
    return t2.FOR_BITS.get(e2);
  }, t2.FOR_BITS = /* @__PURE__ */ new Map(), t2.FOR_VALUE = /* @__PURE__ */ new Map(), t2.L = new t2(Hr.L, "L", 1), t2.M = new t2(Hr.M, "M", 0), t2.Q = new t2(Hr.Q, "Q", 3), t2.H = new t2(Hr.H, "H", 2), t2;
}();
var Kr = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var qr = function() {
  function t2(t3) {
    this.errorCorrectionLevel = Zr.forBits(t3 >> 3 & 3), this.dataMask = 7 & t3;
  }
  return t2.numBitsDiffering = function(t3, e2) {
    return x.bitCount(t3 ^ e2);
  }, t2.decodeFormatInformation = function(e2, r2) {
    var n2 = t2.doDecodeFormatInformation(e2, r2);
    return null !== n2 ? n2 : t2.doDecodeFormatInformation(e2 ^ t2.FORMAT_INFO_MASK_QR, r2 ^ t2.FORMAT_INFO_MASK_QR);
  }, t2.doDecodeFormatInformation = function(e2, r2) {
    var n2, o2, i2 = Number.MAX_SAFE_INTEGER, a2 = 0;
    try {
      for (var s2 = Kr(t2.FORMAT_INFO_DECODE_LOOKUP), u2 = s2.next(); !u2.done; u2 = s2.next()) {
        var c2 = u2.value, f3 = c2[0];
        if (f3 === e2 || f3 === r2)
          return new t2(c2[1]);
        var h2 = t2.numBitsDiffering(e2, f3);
        h2 < i2 && (a2 = c2[1], i2 = h2), e2 !== r2 && (h2 = t2.numBitsDiffering(r2, f3)) < i2 && (a2 = c2[1], i2 = h2);
      }
    } catch (t3) {
      n2 = { error: t3 };
    } finally {
      try {
        u2 && !u2.done && (o2 = s2.return) && o2.call(s2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    return i2 <= 3 ? new t2(a2) : null;
  }, t2.prototype.getErrorCorrectionLevel = function() {
    return this.errorCorrectionLevel;
  }, t2.prototype.getDataMask = function() {
    return this.dataMask;
  }, t2.prototype.hashCode = function() {
    return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.errorCorrectionLevel === r2.errorCorrectionLevel && this.dataMask === r2.dataMask;
  }, t2.FORMAT_INFO_MASK_QR = 21522, t2.FORMAT_INFO_DECODE_LOOKUP = [Int32Array.from([21522, 0]), Int32Array.from([20773, 1]), Int32Array.from([24188, 2]), Int32Array.from([23371, 3]), Int32Array.from([17913, 4]), Int32Array.from([16590, 5]), Int32Array.from([20375, 6]), Int32Array.from([19104, 7]), Int32Array.from([30660, 8]), Int32Array.from([29427, 9]), Int32Array.from([32170, 10]), Int32Array.from([30877, 11]), Int32Array.from([26159, 12]), Int32Array.from([25368, 13]), Int32Array.from([27713, 14]), Int32Array.from([26998, 15]), Int32Array.from([5769, 16]), Int32Array.from([5054, 17]), Int32Array.from([7399, 18]), Int32Array.from([6608, 19]), Int32Array.from([1890, 20]), Int32Array.from([597, 21]), Int32Array.from([3340, 22]), Int32Array.from([2107, 23]), Int32Array.from([13663, 24]), Int32Array.from([12392, 25]), Int32Array.from([16177, 26]), Int32Array.from([14854, 27]), Int32Array.from([9396, 28]), Int32Array.from([8579, 29]), Int32Array.from([11994, 30]), Int32Array.from([11245, 31])], t2;
}();
var Qr = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Jr = function() {
  function t2(t3) {
    for (var e2 = [], r2 = 1; r2 < arguments.length; r2++)
      e2[r2 - 1] = arguments[r2];
    this.ecCodewordsPerBlock = t3, this.ecBlocks = e2;
  }
  return t2.prototype.getECCodewordsPerBlock = function() {
    return this.ecCodewordsPerBlock;
  }, t2.prototype.getNumBlocks = function() {
    var t3, e2, r2 = 0, n2 = this.ecBlocks;
    try {
      for (var o2 = Qr(n2), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        r2 += i2.value.getCount();
      }
    } catch (e3) {
      t3 = { error: e3 };
    } finally {
      try {
        i2 && !i2.done && (e2 = o2.return) && e2.call(o2);
      } finally {
        if (t3)
          throw t3.error;
      }
    }
    return r2;
  }, t2.prototype.getTotalECCodewords = function() {
    return this.ecCodewordsPerBlock * this.getNumBlocks();
  }, t2.prototype.getECBlocks = function() {
    return this.ecBlocks;
  }, t2;
}();
var $r = function() {
  function t2(t3, e2) {
    this.count = t3, this.dataCodewords = e2;
  }
  return t2.prototype.getCount = function() {
    return this.count;
  }, t2.prototype.getDataCodewords = function() {
    return this.dataCodewords;
  }, t2;
}();
var tn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var en = function() {
  function t2(t3, e2) {
    for (var r2, n2, o2 = [], i2 = 2; i2 < arguments.length; i2++)
      o2[i2 - 2] = arguments[i2];
    this.versionNumber = t3, this.alignmentPatternCenters = e2, this.ecBlocks = o2;
    var a2 = 0, s2 = o2[0].getECCodewordsPerBlock(), u2 = o2[0].getECBlocks();
    try {
      for (var c2 = tn(u2), f3 = c2.next(); !f3.done; f3 = c2.next()) {
        var h2 = f3.value;
        a2 += h2.getCount() * (h2.getDataCodewords() + s2);
      }
    } catch (t4) {
      r2 = { error: t4 };
    } finally {
      try {
        f3 && !f3.done && (n2 = c2.return) && n2.call(c2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    this.totalCodewords = a2;
  }
  return t2.prototype.getVersionNumber = function() {
    return this.versionNumber;
  }, t2.prototype.getAlignmentPatternCenters = function() {
    return this.alignmentPatternCenters;
  }, t2.prototype.getTotalCodewords = function() {
    return this.totalCodewords;
  }, t2.prototype.getDimensionForVersion = function() {
    return 17 + 4 * this.versionNumber;
  }, t2.prototype.getECBlocksForLevel = function(t3) {
    return this.ecBlocks[t3.getValue()];
  }, t2.getProvisionalVersionForDimension = function(t3) {
    if (t3 % 4 != 1)
      throw new G();
    try {
      return this.getVersionForNumber((t3 - 17) / 4);
    } catch (t4) {
      throw new G();
    }
  }, t2.getVersionForNumber = function(e2) {
    if (e2 < 1 || e2 > 40)
      throw new T();
    return t2.VERSIONS[e2 - 1];
  }, t2.decodeVersionInformation = function(e2) {
    for (var r2 = Number.MAX_SAFE_INTEGER, n2 = 0, o2 = 0; o2 < t2.VERSION_DECODE_INFO.length; o2++) {
      var i2 = t2.VERSION_DECODE_INFO[o2];
      if (i2 === e2)
        return t2.getVersionForNumber(o2 + 7);
      var a2 = qr.numBitsDiffering(e2, i2);
      a2 < r2 && (n2 = o2 + 7, r2 = a2);
    }
    return r2 <= 3 ? t2.getVersionForNumber(n2) : null;
  }, t2.prototype.buildFunctionPattern = function() {
    var t3 = this.getDimensionForVersion(), e2 = new J(t3);
    e2.setRegion(0, 0, 9, 9), e2.setRegion(t3 - 8, 0, 8, 9), e2.setRegion(0, t3 - 8, 9, 8);
    for (var r2 = this.alignmentPatternCenters.length, n2 = 0; n2 < r2; n2++)
      for (var o2 = this.alignmentPatternCenters[n2] - 2, i2 = 0; i2 < r2; i2++)
        0 === n2 && (0 === i2 || i2 === r2 - 1) || n2 === r2 - 1 && 0 === i2 || e2.setRegion(this.alignmentPatternCenters[i2] - 2, o2, 5, 5);
    return e2.setRegion(6, 9, 1, t3 - 17), e2.setRegion(9, 6, t3 - 17, 1), this.versionNumber > 6 && (e2.setRegion(t3 - 11, 0, 3, 6), e2.setRegion(0, t3 - 11, 6, 3)), e2;
  }, t2.prototype.toString = function() {
    return "" + this.versionNumber;
  }, t2.VERSION_DECODE_INFO = Int32Array.from([31892, 34236, 39577, 42195, 48118, 51042, 55367, 58893, 63784, 68472, 70749, 76311, 79154, 84390, 87683, 92361, 96236, 102084, 102881, 110507, 110734, 117786, 119615, 126325, 127568, 133589, 136944, 141498, 145311, 150283, 152622, 158308, 161089, 167017]), t2.VERSIONS = [new t2(1, new Int32Array(0), new Jr(7, new $r(1, 19)), new Jr(10, new $r(1, 16)), new Jr(13, new $r(1, 13)), new Jr(17, new $r(1, 9))), new t2(2, Int32Array.from([6, 18]), new Jr(10, new $r(1, 34)), new Jr(16, new $r(1, 28)), new Jr(22, new $r(1, 22)), new Jr(28, new $r(1, 16))), new t2(3, Int32Array.from([6, 22]), new Jr(15, new $r(1, 55)), new Jr(26, new $r(1, 44)), new Jr(18, new $r(2, 17)), new Jr(22, new $r(2, 13))), new t2(4, Int32Array.from([6, 26]), new Jr(20, new $r(1, 80)), new Jr(18, new $r(2, 32)), new Jr(26, new $r(2, 24)), new Jr(16, new $r(4, 9))), new t2(5, Int32Array.from([6, 30]), new Jr(26, new $r(1, 108)), new Jr(24, new $r(2, 43)), new Jr(18, new $r(2, 15), new $r(2, 16)), new Jr(22, new $r(2, 11), new $r(2, 12))), new t2(6, Int32Array.from([6, 34]), new Jr(18, new $r(2, 68)), new Jr(16, new $r(4, 27)), new Jr(24, new $r(4, 19)), new Jr(28, new $r(4, 15))), new t2(7, Int32Array.from([6, 22, 38]), new Jr(20, new $r(2, 78)), new Jr(18, new $r(4, 31)), new Jr(18, new $r(2, 14), new $r(4, 15)), new Jr(26, new $r(4, 13), new $r(1, 14))), new t2(8, Int32Array.from([6, 24, 42]), new Jr(24, new $r(2, 97)), new Jr(22, new $r(2, 38), new $r(2, 39)), new Jr(22, new $r(4, 18), new $r(2, 19)), new Jr(26, new $r(4, 14), new $r(2, 15))), new t2(9, Int32Array.from([6, 26, 46]), new Jr(30, new $r(2, 116)), new Jr(22, new $r(3, 36), new $r(2, 37)), new Jr(20, new $r(4, 16), new $r(4, 17)), new Jr(24, new $r(4, 12), new $r(4, 13))), new t2(10, Int32Array.from([6, 28, 50]), new Jr(18, new $r(2, 68), new $r(2, 69)), new Jr(26, new $r(4, 43), new $r(1, 44)), new Jr(24, new $r(6, 19), new $r(2, 20)), new Jr(28, new $r(6, 15), new $r(2, 16))), new t2(11, Int32Array.from([6, 30, 54]), new Jr(20, new $r(4, 81)), new Jr(30, new $r(1, 50), new $r(4, 51)), new Jr(28, new $r(4, 22), new $r(4, 23)), new Jr(24, new $r(3, 12), new $r(8, 13))), new t2(12, Int32Array.from([6, 32, 58]), new Jr(24, new $r(2, 92), new $r(2, 93)), new Jr(22, new $r(6, 36), new $r(2, 37)), new Jr(26, new $r(4, 20), new $r(6, 21)), new Jr(28, new $r(7, 14), new $r(4, 15))), new t2(13, Int32Array.from([6, 34, 62]), new Jr(26, new $r(4, 107)), new Jr(22, new $r(8, 37), new $r(1, 38)), new Jr(24, new $r(8, 20), new $r(4, 21)), new Jr(22, new $r(12, 11), new $r(4, 12))), new t2(14, Int32Array.from([6, 26, 46, 66]), new Jr(30, new $r(3, 115), new $r(1, 116)), new Jr(24, new $r(4, 40), new $r(5, 41)), new Jr(20, new $r(11, 16), new $r(5, 17)), new Jr(24, new $r(11, 12), new $r(5, 13))), new t2(15, Int32Array.from([6, 26, 48, 70]), new Jr(22, new $r(5, 87), new $r(1, 88)), new Jr(24, new $r(5, 41), new $r(5, 42)), new Jr(30, new $r(5, 24), new $r(7, 25)), new Jr(24, new $r(11, 12), new $r(7, 13))), new t2(16, Int32Array.from([6, 26, 50, 74]), new Jr(24, new $r(5, 98), new $r(1, 99)), new Jr(28, new $r(7, 45), new $r(3, 46)), new Jr(24, new $r(15, 19), new $r(2, 20)), new Jr(30, new $r(3, 15), new $r(13, 16))), new t2(17, Int32Array.from([6, 30, 54, 78]), new Jr(28, new $r(1, 107), new $r(5, 108)), new Jr(28, new $r(10, 46), new $r(1, 47)), new Jr(28, new $r(1, 22), new $r(15, 23)), new Jr(28, new $r(2, 14), new $r(17, 15))), new t2(18, Int32Array.from([6, 30, 56, 82]), new Jr(30, new $r(5, 120), new $r(1, 121)), new Jr(26, new $r(9, 43), new $r(4, 44)), new Jr(28, new $r(17, 22), new $r(1, 23)), new Jr(28, new $r(2, 14), new $r(19, 15))), new t2(19, Int32Array.from([6, 30, 58, 86]), new Jr(28, new $r(3, 113), new $r(4, 114)), new Jr(26, new $r(3, 44), new $r(11, 45)), new Jr(26, new $r(17, 21), new $r(4, 22)), new Jr(26, new $r(9, 13), new $r(16, 14))), new t2(20, Int32Array.from([6, 34, 62, 90]), new Jr(28, new $r(3, 107), new $r(5, 108)), new Jr(26, new $r(3, 41), new $r(13, 42)), new Jr(30, new $r(15, 24), new $r(5, 25)), new Jr(28, new $r(15, 15), new $r(10, 16))), new t2(21, Int32Array.from([6, 28, 50, 72, 94]), new Jr(28, new $r(4, 116), new $r(4, 117)), new Jr(26, new $r(17, 42)), new Jr(28, new $r(17, 22), new $r(6, 23)), new Jr(30, new $r(19, 16), new $r(6, 17))), new t2(22, Int32Array.from([6, 26, 50, 74, 98]), new Jr(28, new $r(2, 111), new $r(7, 112)), new Jr(28, new $r(17, 46)), new Jr(30, new $r(7, 24), new $r(16, 25)), new Jr(24, new $r(34, 13))), new t2(23, Int32Array.from([6, 30, 54, 78, 102]), new Jr(30, new $r(4, 121), new $r(5, 122)), new Jr(28, new $r(4, 47), new $r(14, 48)), new Jr(30, new $r(11, 24), new $r(14, 25)), new Jr(30, new $r(16, 15), new $r(14, 16))), new t2(24, Int32Array.from([6, 28, 54, 80, 106]), new Jr(30, new $r(6, 117), new $r(4, 118)), new Jr(28, new $r(6, 45), new $r(14, 46)), new Jr(30, new $r(11, 24), new $r(16, 25)), new Jr(30, new $r(30, 16), new $r(2, 17))), new t2(25, Int32Array.from([6, 32, 58, 84, 110]), new Jr(26, new $r(8, 106), new $r(4, 107)), new Jr(28, new $r(8, 47), new $r(13, 48)), new Jr(30, new $r(7, 24), new $r(22, 25)), new Jr(30, new $r(22, 15), new $r(13, 16))), new t2(26, Int32Array.from([6, 30, 58, 86, 114]), new Jr(28, new $r(10, 114), new $r(2, 115)), new Jr(28, new $r(19, 46), new $r(4, 47)), new Jr(28, new $r(28, 22), new $r(6, 23)), new Jr(30, new $r(33, 16), new $r(4, 17))), new t2(27, Int32Array.from([6, 34, 62, 90, 118]), new Jr(30, new $r(8, 122), new $r(4, 123)), new Jr(28, new $r(22, 45), new $r(3, 46)), new Jr(30, new $r(8, 23), new $r(26, 24)), new Jr(30, new $r(12, 15), new $r(28, 16))), new t2(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new Jr(30, new $r(3, 117), new $r(10, 118)), new Jr(28, new $r(3, 45), new $r(23, 46)), new Jr(30, new $r(4, 24), new $r(31, 25)), new Jr(30, new $r(11, 15), new $r(31, 16))), new t2(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new Jr(30, new $r(7, 116), new $r(7, 117)), new Jr(28, new $r(21, 45), new $r(7, 46)), new Jr(30, new $r(1, 23), new $r(37, 24)), new Jr(30, new $r(19, 15), new $r(26, 16))), new t2(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new Jr(30, new $r(5, 115), new $r(10, 116)), new Jr(28, new $r(19, 47), new $r(10, 48)), new Jr(30, new $r(15, 24), new $r(25, 25)), new Jr(30, new $r(23, 15), new $r(25, 16))), new t2(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new Jr(30, new $r(13, 115), new $r(3, 116)), new Jr(28, new $r(2, 46), new $r(29, 47)), new Jr(30, new $r(42, 24), new $r(1, 25)), new Jr(30, new $r(23, 15), new $r(28, 16))), new t2(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new Jr(30, new $r(17, 115)), new Jr(28, new $r(10, 46), new $r(23, 47)), new Jr(30, new $r(10, 24), new $r(35, 25)), new Jr(30, new $r(19, 15), new $r(35, 16))), new t2(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new Jr(30, new $r(17, 115), new $r(1, 116)), new Jr(28, new $r(14, 46), new $r(21, 47)), new Jr(30, new $r(29, 24), new $r(19, 25)), new Jr(30, new $r(11, 15), new $r(46, 16))), new t2(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new Jr(30, new $r(13, 115), new $r(6, 116)), new Jr(28, new $r(14, 46), new $r(23, 47)), new Jr(30, new $r(44, 24), new $r(7, 25)), new Jr(30, new $r(59, 16), new $r(1, 17))), new t2(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new Jr(30, new $r(12, 121), new $r(7, 122)), new Jr(28, new $r(12, 47), new $r(26, 48)), new Jr(30, new $r(39, 24), new $r(14, 25)), new Jr(30, new $r(22, 15), new $r(41, 16))), new t2(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new Jr(30, new $r(6, 121), new $r(14, 122)), new Jr(28, new $r(6, 47), new $r(34, 48)), new Jr(30, new $r(46, 24), new $r(10, 25)), new Jr(30, new $r(2, 15), new $r(64, 16))), new t2(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new Jr(30, new $r(17, 122), new $r(4, 123)), new Jr(28, new $r(29, 46), new $r(14, 47)), new Jr(30, new $r(49, 24), new $r(10, 25)), new Jr(30, new $r(24, 15), new $r(46, 16))), new t2(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new Jr(30, new $r(4, 122), new $r(18, 123)), new Jr(28, new $r(13, 46), new $r(32, 47)), new Jr(30, new $r(48, 24), new $r(14, 25)), new Jr(30, new $r(42, 15), new $r(32, 16))), new t2(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new Jr(30, new $r(20, 117), new $r(4, 118)), new Jr(28, new $r(40, 47), new $r(7, 48)), new Jr(30, new $r(43, 24), new $r(22, 25)), new Jr(30, new $r(10, 15), new $r(67, 16))), new t2(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new Jr(30, new $r(19, 118), new $r(6, 119)), new Jr(28, new $r(18, 47), new $r(31, 48)), new Jr(30, new $r(34, 24), new $r(34, 25)), new Jr(30, new $r(20, 15), new $r(61, 16)))], t2;
}();
!function(t2) {
  t2[t2.DATA_MASK_000 = 0] = "DATA_MASK_000", t2[t2.DATA_MASK_001 = 1] = "DATA_MASK_001", t2[t2.DATA_MASK_010 = 2] = "DATA_MASK_010", t2[t2.DATA_MASK_011 = 3] = "DATA_MASK_011", t2[t2.DATA_MASK_100 = 4] = "DATA_MASK_100", t2[t2.DATA_MASK_101 = 5] = "DATA_MASK_101", t2[t2.DATA_MASK_110 = 6] = "DATA_MASK_110", t2[t2.DATA_MASK_111 = 7] = "DATA_MASK_111";
}(Yr || (Yr = {}));
var rn;
var nn = function() {
  function t2(t3, e2) {
    this.value = t3, this.isMasked = e2;
  }
  return t2.prototype.unmaskBitMatrix = function(t3, e2) {
    for (var r2 = 0; r2 < e2; r2++)
      for (var n2 = 0; n2 < e2; n2++)
        this.isMasked(r2, n2) && t3.flip(n2, r2);
  }, t2.values = /* @__PURE__ */ new Map([[Yr.DATA_MASK_000, new t2(Yr.DATA_MASK_000, function(t3, e2) {
    return 0 == (t3 + e2 & 1);
  })], [Yr.DATA_MASK_001, new t2(Yr.DATA_MASK_001, function(t3, e2) {
    return 0 == (1 & t3);
  })], [Yr.DATA_MASK_010, new t2(Yr.DATA_MASK_010, function(t3, e2) {
    return e2 % 3 == 0;
  })], [Yr.DATA_MASK_011, new t2(Yr.DATA_MASK_011, function(t3, e2) {
    return (t3 + e2) % 3 == 0;
  })], [Yr.DATA_MASK_100, new t2(Yr.DATA_MASK_100, function(t3, e2) {
    return 0 == (Math.floor(t3 / 2) + Math.floor(e2 / 3) & 1);
  })], [Yr.DATA_MASK_101, new t2(Yr.DATA_MASK_101, function(t3, e2) {
    return t3 * e2 % 6 == 0;
  })], [Yr.DATA_MASK_110, new t2(Yr.DATA_MASK_110, function(t3, e2) {
    return t3 * e2 % 6 < 3;
  })], [Yr.DATA_MASK_111, new t2(Yr.DATA_MASK_111, function(t3, e2) {
    return 0 == (t3 + e2 + t3 * e2 % 3 & 1);
  })]]), t2;
}();
var on = function() {
  function t2(t3) {
    var e2 = t3.getHeight();
    if (e2 < 21 || 1 != (3 & e2))
      throw new G();
    this.bitMatrix = t3;
  }
  return t2.prototype.readFormatInformation = function() {
    if (null !== this.parsedFormatInfo && void 0 !== this.parsedFormatInfo)
      return this.parsedFormatInfo;
    for (var t3 = 0, e2 = 0; e2 < 6; e2++)
      t3 = this.copyBit(e2, 8, t3);
    t3 = this.copyBit(7, 8, t3), t3 = this.copyBit(8, 8, t3), t3 = this.copyBit(8, 7, t3);
    for (var r2 = 5; r2 >= 0; r2--)
      t3 = this.copyBit(8, r2, t3);
    var n2 = this.bitMatrix.getHeight(), o2 = 0, i2 = n2 - 7;
    for (r2 = n2 - 1; r2 >= i2; r2--)
      o2 = this.copyBit(8, r2, o2);
    for (e2 = n2 - 8; e2 < n2; e2++)
      o2 = this.copyBit(e2, 8, o2);
    if (this.parsedFormatInfo = qr.decodeFormatInformation(t3, o2), null !== this.parsedFormatInfo)
      return this.parsedFormatInfo;
    throw new G();
  }, t2.prototype.readVersion = function() {
    if (null !== this.parsedVersion && void 0 !== this.parsedVersion)
      return this.parsedVersion;
    var t3 = this.bitMatrix.getHeight(), e2 = Math.floor((t3 - 17) / 4);
    if (e2 <= 6)
      return en.getVersionForNumber(e2);
    for (var r2 = 0, n2 = t3 - 11, o2 = 5; o2 >= 0; o2--)
      for (var i2 = t3 - 9; i2 >= n2; i2--)
        r2 = this.copyBit(i2, o2, r2);
    var a2 = en.decodeVersionInformation(r2);
    if (null !== a2 && a2.getDimensionForVersion() === t3)
      return this.parsedVersion = a2, a2;
    r2 = 0;
    for (i2 = 5; i2 >= 0; i2--)
      for (o2 = t3 - 9; o2 >= n2; o2--)
        r2 = this.copyBit(i2, o2, r2);
    if (null !== (a2 = en.decodeVersionInformation(r2)) && a2.getDimensionForVersion() === t3)
      return this.parsedVersion = a2, a2;
    throw new G();
  }, t2.prototype.copyBit = function(t3, e2, r2) {
    return (this.isMirror ? this.bitMatrix.get(e2, t3) : this.bitMatrix.get(t3, e2)) ? r2 << 1 | 1 : r2 << 1;
  }, t2.prototype.readCodewords = function() {
    var t3 = this.readFormatInformation(), e2 = this.readVersion(), r2 = nn.values.get(t3.getDataMask()), n2 = this.bitMatrix.getHeight();
    r2.unmaskBitMatrix(this.bitMatrix, n2);
    for (var o2 = e2.buildFunctionPattern(), i2 = true, a2 = new Uint8Array(e2.getTotalCodewords()), s2 = 0, u2 = 0, c2 = 0, f3 = n2 - 1; f3 > 0; f3 -= 2) {
      6 === f3 && f3--;
      for (var h2 = 0; h2 < n2; h2++)
        for (var l2 = i2 ? n2 - 1 - h2 : h2, d2 = 0; d2 < 2; d2++)
          o2.get(f3 - d2, l2) || (c2++, u2 <<= 1, this.bitMatrix.get(f3 - d2, l2) && (u2 |= 1), 8 === c2 && (a2[s2++] = u2, c2 = 0, u2 = 0));
      i2 = !i2;
    }
    if (s2 !== e2.getTotalCodewords())
      throw new G();
    return a2;
  }, t2.prototype.remask = function() {
    if (null !== this.parsedFormatInfo) {
      var t3 = nn.values[this.parsedFormatInfo.getDataMask()], e2 = this.bitMatrix.getHeight();
      t3.unmaskBitMatrix(this.bitMatrix, e2);
    }
  }, t2.prototype.setMirror = function(t3) {
    this.parsedVersion = null, this.parsedFormatInfo = null, this.isMirror = t3;
  }, t2.prototype.mirror = function() {
    for (var t3 = this.bitMatrix, e2 = 0, r2 = t3.getWidth(); e2 < r2; e2++)
      for (var n2 = e2 + 1, o2 = t3.getHeight(); n2 < o2; n2++)
        t3.get(e2, n2) !== t3.get(n2, e2) && (t3.flip(n2, e2), t3.flip(e2, n2));
  }, t2;
}();
var an = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var sn = function() {
  function t2(t3, e2) {
    this.numDataCodewords = t3, this.codewords = e2;
  }
  return t2.getDataBlocks = function(e2, r2, n2) {
    var o2, i2, a2, s2;
    if (e2.length !== r2.getTotalCodewords())
      throw new T();
    var u2 = r2.getECBlocksForLevel(n2), c2 = 0, f3 = u2.getECBlocks();
    try {
      for (var h2 = an(f3), l2 = h2.next(); !l2.done; l2 = h2.next()) {
        c2 += (w2 = l2.value).getCount();
      }
    } catch (t3) {
      o2 = { error: t3 };
    } finally {
      try {
        l2 && !l2.done && (i2 = h2.return) && i2.call(h2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    var d2 = new Array(c2), p2 = 0;
    try {
      for (var g2 = an(f3), y2 = g2.next(); !y2.done; y2 = g2.next())
        for (var w2 = y2.value, v2 = 0; v2 < w2.getCount(); v2++) {
          var _2 = w2.getDataCodewords(), A2 = u2.getECCodewordsPerBlock() + _2;
          d2[p2++] = new t2(_2, new Uint8Array(A2));
        }
    } catch (t3) {
      a2 = { error: t3 };
    } finally {
      try {
        y2 && !y2.done && (s2 = g2.return) && s2.call(g2);
      } finally {
        if (a2)
          throw a2.error;
      }
    }
    for (var C2 = d2[0].codewords.length, m2 = d2.length - 1; m2 >= 0; ) {
      if (d2[m2].codewords.length === C2)
        break;
      m2--;
    }
    m2++;
    var E2 = C2 - u2.getECCodewordsPerBlock(), I2 = 0;
    for (v2 = 0; v2 < E2; v2++)
      for (var S2 = 0; S2 < p2; S2++)
        d2[S2].codewords[v2] = e2[I2++];
    for (S2 = m2; S2 < p2; S2++)
      d2[S2].codewords[E2] = e2[I2++];
    var O2 = d2[0].codewords.length;
    for (v2 = E2; v2 < O2; v2++)
      for (S2 = 0; S2 < p2; S2++) {
        var b2 = S2 < m2 ? v2 : v2 + 1;
        d2[S2].codewords[b2] = e2[I2++];
      }
    return d2;
  }, t2.prototype.getNumDataCodewords = function() {
    return this.numDataCodewords;
  }, t2.prototype.getCodewords = function() {
    return this.codewords;
  }, t2;
}();
!function(t2) {
  t2[t2.TERMINATOR = 0] = "TERMINATOR", t2[t2.NUMERIC = 1] = "NUMERIC", t2[t2.ALPHANUMERIC = 2] = "ALPHANUMERIC", t2[t2.STRUCTURED_APPEND = 3] = "STRUCTURED_APPEND", t2[t2.BYTE = 4] = "BYTE", t2[t2.ECI = 5] = "ECI", t2[t2.KANJI = 6] = "KANJI", t2[t2.FNC1_FIRST_POSITION = 7] = "FNC1_FIRST_POSITION", t2[t2.FNC1_SECOND_POSITION = 8] = "FNC1_SECOND_POSITION", t2[t2.HANZI = 9] = "HANZI";
}(rn || (rn = {}));
var un;
var cn;
var fn = function() {
  function t2(e2, r2, n2, o2) {
    this.value = e2, this.stringValue = r2, this.characterCountBitsForVersions = n2, this.bits = o2, t2.FOR_BITS.set(o2, this), t2.FOR_VALUE.set(e2, this);
  }
  return t2.forBits = function(e2) {
    var r2 = t2.FOR_BITS.get(e2);
    if (void 0 === r2)
      throw new T();
    return r2;
  }, t2.prototype.getCharacterCountBits = function(t3) {
    var e2, r2 = t3.getVersionNumber();
    return e2 = r2 <= 9 ? 0 : r2 <= 26 ? 1 : 2, this.characterCountBitsForVersions[e2];
  }, t2.prototype.getValue = function() {
    return this.value;
  }, t2.prototype.getBits = function() {
    return this.bits;
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    return this.value === r2.value;
  }, t2.prototype.toString = function() {
    return this.stringValue;
  }, t2.FOR_BITS = /* @__PURE__ */ new Map(), t2.FOR_VALUE = /* @__PURE__ */ new Map(), t2.TERMINATOR = new t2(rn.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0), t2.NUMERIC = new t2(rn.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1), t2.ALPHANUMERIC = new t2(rn.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2), t2.STRUCTURED_APPEND = new t2(rn.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3), t2.BYTE = new t2(rn.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4), t2.ECI = new t2(rn.ECI, "ECI", Int32Array.from([0, 0, 0]), 7), t2.KANJI = new t2(rn.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8), t2.FNC1_FIRST_POSITION = new t2(rn.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5), t2.FNC1_SECOND_POSITION = new t2(rn.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9), t2.HANZI = new t2(rn.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13), t2;
}();
var hn = function() {
  function t2() {
  }
  return t2.decode = function(e2, r2, n2, o2) {
    var i2 = new Vr(e2), a2 = new Q(), s2 = new Array(), u2 = -1, c2 = -1;
    try {
      var f3 = null, h2 = false, l2 = void 0;
      do {
        if (i2.available() < 4)
          l2 = fn.TERMINATOR;
        else {
          var d2 = i2.readBits(4);
          l2 = fn.forBits(d2);
        }
        switch (l2) {
          case fn.TERMINATOR:
            break;
          case fn.FNC1_FIRST_POSITION:
          case fn.FNC1_SECOND_POSITION:
            h2 = true;
            break;
          case fn.STRUCTURED_APPEND:
            if (i2.available() < 16)
              throw new G();
            u2 = i2.readBits(8), c2 = i2.readBits(8);
            break;
          case fn.ECI:
            var p2 = t2.parseECIValue(i2);
            if (null === (f3 = j.getCharacterSetECIByValue(p2)))
              throw new G();
            break;
          case fn.HANZI:
            var g2 = i2.readBits(4), y2 = i2.readBits(l2.getCharacterCountBits(r2));
            g2 === t2.GB2312_SUBSET && t2.decodeHanziSegment(i2, a2, y2);
            break;
          default:
            var w2 = i2.readBits(l2.getCharacterCountBits(r2));
            switch (l2) {
              case fn.NUMERIC:
                t2.decodeNumericSegment(i2, a2, w2);
                break;
              case fn.ALPHANUMERIC:
                t2.decodeAlphanumericSegment(i2, a2, w2, h2);
                break;
              case fn.BYTE:
                t2.decodeByteSegment(i2, a2, w2, f3, s2, o2);
                break;
              case fn.KANJI:
                t2.decodeKanjiSegment(i2, a2, w2);
                break;
              default:
                throw new G();
            }
        }
      } while (l2 !== fn.TERMINATOR);
    } catch (t3) {
      throw new G();
    }
    return new At(e2, a2.toString(), 0 === s2.length ? null : s2, null === n2 ? null : n2.toString(), u2, c2);
  }, t2.decodeHanziSegment = function(t3, e2, r2) {
    if (13 * r2 > t3.available())
      throw new G();
    for (var n2 = new Uint8Array(2 * r2), o2 = 0; r2 > 0; ) {
      var i2 = t3.readBits(13), a2 = i2 / 96 << 8 & 4294967295 | i2 % 96;
      a2 += a2 < 959 ? 41377 : 42657, n2[o2] = a2 >> 8 & 255, n2[o2 + 1] = 255 & a2, o2 += 2, r2--;
    }
    try {
      e2.append(K.decode(n2, q.GB2312));
    } catch (t4) {
      throw new G(t4);
    }
  }, t2.decodeKanjiSegment = function(t3, e2, r2) {
    if (13 * r2 > t3.available())
      throw new G();
    for (var n2 = new Uint8Array(2 * r2), o2 = 0; r2 > 0; ) {
      var i2 = t3.readBits(13), a2 = i2 / 192 << 8 & 4294967295 | i2 % 192;
      a2 += a2 < 7936 ? 33088 : 49472, n2[o2] = a2 >> 8, n2[o2 + 1] = a2, o2 += 2, r2--;
    }
    try {
      e2.append(K.decode(n2, q.SHIFT_JIS));
    } catch (t4) {
      throw new G(t4);
    }
  }, t2.decodeByteSegment = function(t3, e2, r2, n2, o2, i2) {
    if (8 * r2 > t3.available())
      throw new G();
    for (var a2, s2 = new Uint8Array(r2), u2 = 0; u2 < r2; u2++)
      s2[u2] = t3.readBits(8);
    a2 = null === n2 ? q.guessEncoding(s2, i2) : n2.getName();
    try {
      e2.append(K.decode(s2, a2));
    } catch (t4) {
      throw new G(t4);
    }
    o2.push(s2);
  }, t2.toAlphaNumericChar = function(e2) {
    if (e2 >= t2.ALPHANUMERIC_CHARS.length)
      throw new G();
    return t2.ALPHANUMERIC_CHARS[e2];
  }, t2.decodeAlphanumericSegment = function(e2, r2, n2, o2) {
    for (var i2 = r2.length(); n2 > 1; ) {
      if (e2.available() < 11)
        throw new G();
      var a2 = e2.readBits(11);
      r2.append(t2.toAlphaNumericChar(Math.floor(a2 / 45))), r2.append(t2.toAlphaNumericChar(a2 % 45)), n2 -= 2;
    }
    if (1 === n2) {
      if (e2.available() < 6)
        throw new G();
      r2.append(t2.toAlphaNumericChar(e2.readBits(6)));
    }
    if (o2)
      for (var s2 = i2; s2 < r2.length(); s2++)
        "%" === r2.charAt(s2) && (s2 < r2.length() - 1 && "%" === r2.charAt(s2 + 1) ? r2.deleteCharAt(s2 + 1) : r2.setCharAt(s2, String.fromCharCode(29)));
  }, t2.decodeNumericSegment = function(e2, r2, n2) {
    for (; n2 >= 3; ) {
      if (e2.available() < 10)
        throw new G();
      var o2 = e2.readBits(10);
      if (o2 >= 1e3)
        throw new G();
      r2.append(t2.toAlphaNumericChar(Math.floor(o2 / 100))), r2.append(t2.toAlphaNumericChar(Math.floor(o2 / 10) % 10)), r2.append(t2.toAlphaNumericChar(o2 % 10)), n2 -= 3;
    }
    if (2 === n2) {
      if (e2.available() < 7)
        throw new G();
      var i2 = e2.readBits(7);
      if (i2 >= 100)
        throw new G();
      r2.append(t2.toAlphaNumericChar(Math.floor(i2 / 10))), r2.append(t2.toAlphaNumericChar(i2 % 10));
    } else if (1 === n2) {
      if (e2.available() < 4)
        throw new G();
      var a2 = e2.readBits(4);
      if (a2 >= 10)
        throw new G();
      r2.append(t2.toAlphaNumericChar(a2));
    }
  }, t2.parseECIValue = function(t3) {
    var e2 = t3.readBits(8);
    if (0 == (128 & e2))
      return 127 & e2;
    if (128 == (192 & e2))
      return (63 & e2) << 8 & 4294967295 | t3.readBits(8);
    if (192 == (224 & e2))
      return (31 & e2) << 16 & 4294967295 | t3.readBits(16);
    throw new G();
  }, t2.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:", t2.GB2312_SUBSET = 1, t2;
}();
var ln = function() {
  function t2(t3) {
    this.mirrored = t3;
  }
  return t2.prototype.isMirrored = function() {
    return this.mirrored;
  }, t2.prototype.applyMirroredCorrection = function(t3) {
    if (this.mirrored && null !== t3 && !(t3.length < 3)) {
      var e2 = t3[0];
      t3[0] = t3[2], t3[2] = e2;
    }
  }, t2;
}();
var dn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var pn = function() {
  function t2() {
    this.rsDecoder = new Dt(Tt.QR_CODE_FIELD_256);
  }
  return t2.prototype.decodeBooleanArray = function(t3, e2) {
    return this.decodeBitMatrix(J.parseFromBooleanArray(t3), e2);
  }, t2.prototype.decodeBitMatrix = function(t3, e2) {
    var r2 = new on(t3), n2 = null;
    try {
      return this.decodeBitMatrixParser(r2, e2);
    } catch (t4) {
      n2 = t4;
    }
    try {
      r2.remask(), r2.setMirror(true), r2.readVersion(), r2.readFormatInformation(), r2.mirror();
      var o2 = this.decodeBitMatrixParser(r2, e2);
      return o2.setOther(new ln(true)), o2;
    } catch (t4) {
      if (null !== n2)
        throw n2;
      throw t4;
    }
  }, t2.prototype.decodeBitMatrixParser = function(t3, e2) {
    var r2, n2, o2, i2, a2 = t3.readVersion(), s2 = t3.readFormatInformation().getErrorCorrectionLevel(), u2 = t3.readCodewords(), c2 = sn.getDataBlocks(u2, a2, s2), f3 = 0;
    try {
      for (var h2 = dn(c2), l2 = h2.next(); !l2.done; l2 = h2.next()) {
        f3 += (w2 = l2.value).getNumDataCodewords();
      }
    } catch (t4) {
      r2 = { error: t4 };
    } finally {
      try {
        l2 && !l2.done && (n2 = h2.return) && n2.call(h2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    var d2 = new Uint8Array(f3), p2 = 0;
    try {
      for (var g2 = dn(c2), y2 = g2.next(); !y2.done; y2 = g2.next()) {
        var w2, v2 = (w2 = y2.value).getCodewords(), _2 = w2.getNumDataCodewords();
        this.correctErrors(v2, _2);
        for (var A2 = 0; A2 < _2; A2++)
          d2[p2++] = v2[A2];
      }
    } catch (t4) {
      o2 = { error: t4 };
    } finally {
      try {
        y2 && !y2.done && (i2 = g2.return) && i2.call(g2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    return hn.decode(d2, a2, s2, e2);
  }, t2.prototype.correctErrors = function(t3, e2) {
    var r2 = new Int32Array(t3);
    try {
      this.rsDecoder.decode(r2, t3.length - e2);
    } catch (t4) {
      throw new R();
    }
    for (var n2 = 0; n2 < e2; n2++)
      t3[n2] = r2[n2];
  }, t2;
}();
var gn = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var yn = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this, e3, r2) || this;
    return o2.estimatedModuleSize = n2, o2;
  }
  return gn(e2, t2), e2.prototype.aboutEquals = function(t3, e3, r2) {
    if (Math.abs(e3 - this.getY()) <= t3 && Math.abs(r2 - this.getX()) <= t3) {
      var n2 = Math.abs(t3 - this.estimatedModuleSize);
      return n2 <= 1 || n2 <= this.estimatedModuleSize;
    }
    return false;
  }, e2.prototype.combineEstimate = function(t3, r2, n2) {
    return new e2((this.getX() + r2) / 2, (this.getY() + t3) / 2, (this.estimatedModuleSize + n2) / 2);
  }, e2;
}(Lt);
var wn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var vn = function() {
  function t2(t3, e2, r2, n2, o2, i2, a2) {
    this.image = t3, this.startX = e2, this.startY = r2, this.width = n2, this.height = o2, this.moduleSize = i2, this.resultPointCallback = a2, this.possibleCenters = [], this.crossCheckStateCount = new Int32Array(3);
  }
  return t2.prototype.find = function() {
    for (var t3 = this.startX, e2 = this.height, r2 = t3 + this.width, n2 = this.startY + e2 / 2, o2 = new Int32Array(3), i2 = this.image, a2 = 0; a2 < e2; a2++) {
      var s2 = n2 + (0 == (1 & a2) ? Math.floor((a2 + 1) / 2) : -Math.floor((a2 + 1) / 2));
      o2[0] = 0, o2[1] = 0, o2[2] = 0;
      for (var u2 = t3; u2 < r2 && !i2.get(u2, s2); )
        u2++;
      for (var c2 = 0; u2 < r2; ) {
        if (i2.get(u2, s2))
          if (1 === c2)
            o2[1]++;
          else if (2 === c2) {
            var f3;
            if (this.foundPatternCross(o2)) {
              if (null !== (f3 = this.handlePossibleCenter(o2, s2, u2)))
                return f3;
            }
            o2[0] = o2[2], o2[1] = 1, o2[2] = 0, c2 = 1;
          } else
            o2[++c2]++;
        else
          1 === c2 && c2++, o2[c2]++;
        u2++;
      }
      if (this.foundPatternCross(o2)) {
        if (null !== (f3 = this.handlePossibleCenter(o2, s2, r2)))
          return f3;
      }
    }
    if (0 !== this.possibleCenters.length)
      return this.possibleCenters[0];
    throw new tt();
  }, t2.centerFromEnd = function(t3, e2) {
    return e2 - t3[2] - t3[1] / 2;
  }, t2.prototype.foundPatternCross = function(t3) {
    for (var e2 = this.moduleSize, r2 = e2 / 2, n2 = 0; n2 < 3; n2++)
      if (Math.abs(e2 - t3[n2]) >= r2)
        return false;
    return true;
  }, t2.prototype.crossCheckVertical = function(e2, r2, n2, o2) {
    var i2 = this.image, a2 = i2.getHeight(), s2 = this.crossCheckStateCount;
    s2[0] = 0, s2[1] = 0, s2[2] = 0;
    for (var u2 = e2; u2 >= 0 && i2.get(r2, u2) && s2[1] <= n2; )
      s2[1]++, u2--;
    if (u2 < 0 || s2[1] > n2)
      return NaN;
    for (; u2 >= 0 && !i2.get(r2, u2) && s2[0] <= n2; )
      s2[0]++, u2--;
    if (s2[0] > n2)
      return NaN;
    for (u2 = e2 + 1; u2 < a2 && i2.get(r2, u2) && s2[1] <= n2; )
      s2[1]++, u2++;
    if (u2 === a2 || s2[1] > n2)
      return NaN;
    for (; u2 < a2 && !i2.get(r2, u2) && s2[2] <= n2; )
      s2[2]++, u2++;
    if (s2[2] > n2)
      return NaN;
    var c2 = s2[0] + s2[1] + s2[2];
    return 5 * Math.abs(c2 - o2) >= 2 * o2 ? NaN : this.foundPatternCross(s2) ? t2.centerFromEnd(s2, u2) : NaN;
  }, t2.prototype.handlePossibleCenter = function(e2, r2, n2) {
    var o2, i2, a2 = e2[0] + e2[1] + e2[2], s2 = t2.centerFromEnd(e2, n2), u2 = this.crossCheckVertical(r2, s2, 2 * e2[1], a2);
    if (!isNaN(u2)) {
      var c2 = (e2[0] + e2[1] + e2[2]) / 3;
      try {
        for (var f3 = wn(this.possibleCenters), h2 = f3.next(); !h2.done; h2 = f3.next()) {
          var l2 = h2.value;
          if (l2.aboutEquals(c2, u2, s2))
            return l2.combineEstimate(u2, s2, c2);
        }
      } catch (t3) {
        o2 = { error: t3 };
      } finally {
        try {
          h2 && !h2.done && (i2 = f3.return) && i2.call(f3);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
      var d2 = new yn(s2, u2, c2);
      this.possibleCenters.push(d2), null !== this.resultPointCallback && void 0 !== this.resultPointCallback && this.resultPointCallback.foundPossibleResultPoint(d2);
    }
    return null;
  }, t2;
}();
var _n = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var An = function(t2) {
  function e2(e3, r2, n2, o2) {
    var i2 = t2.call(this, e3, r2) || this;
    return i2.estimatedModuleSize = n2, i2.count = o2, void 0 === o2 && (i2.count = 1), i2;
  }
  return _n(e2, t2), e2.prototype.getEstimatedModuleSize = function() {
    return this.estimatedModuleSize;
  }, e2.prototype.getCount = function() {
    return this.count;
  }, e2.prototype.aboutEquals = function(t3, e3, r2) {
    if (Math.abs(e3 - this.getY()) <= t3 && Math.abs(r2 - this.getX()) <= t3) {
      var n2 = Math.abs(t3 - this.estimatedModuleSize);
      return n2 <= 1 || n2 <= this.estimatedModuleSize;
    }
    return false;
  }, e2.prototype.combineEstimate = function(t3, r2, n2) {
    var o2 = this.count + 1;
    return new e2((this.count * this.getX() + r2) / o2, (this.count * this.getY() + t3) / o2, (this.count * this.estimatedModuleSize + n2) / o2, o2);
  }, e2;
}(Lt);
var Cn = function() {
  function t2(t3) {
    this.bottomLeft = t3[0], this.topLeft = t3[1], this.topRight = t3[2];
  }
  return t2.prototype.getBottomLeft = function() {
    return this.bottomLeft;
  }, t2.prototype.getTopLeft = function() {
    return this.topLeft;
  }, t2.prototype.getTopRight = function() {
    return this.topRight;
  }, t2;
}();
var mn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var En = function() {
  function t2(t3, e2) {
    this.image = t3, this.resultPointCallback = e2, this.possibleCenters = [], this.crossCheckStateCount = new Int32Array(5), this.resultPointCallback = e2;
  }
  return t2.prototype.getImage = function() {
    return this.image;
  }, t2.prototype.getPossibleCenters = function() {
    return this.possibleCenters;
  }, t2.prototype.find = function(e2) {
    var r2 = null != e2 && void 0 !== e2.get(U.TRY_HARDER), n2 = null != e2 && void 0 !== e2.get(U.PURE_BARCODE), o2 = this.image, i2 = o2.getHeight(), a2 = o2.getWidth(), s2 = Math.floor(3 * i2 / (4 * t2.MAX_MODULES));
    (s2 < t2.MIN_SKIP || r2) && (s2 = t2.MIN_SKIP);
    for (var u2 = false, c2 = new Int32Array(5), f3 = s2 - 1; f3 < i2 && !u2; f3 += s2) {
      c2[0] = 0, c2[1] = 0, c2[2] = 0, c2[3] = 0, c2[4] = 0;
      for (var h2 = 0, l2 = 0; l2 < a2; l2++)
        if (o2.get(l2, f3))
          1 == (1 & h2) && h2++, c2[h2]++;
        else if (0 == (1 & h2))
          if (4 === h2)
            if (t2.foundPatternCross(c2)) {
              if (true !== this.handlePossibleCenter(c2, f3, l2, n2)) {
                c2[0] = c2[2], c2[1] = c2[3], c2[2] = c2[4], c2[3] = 1, c2[4] = 0, h2 = 3;
                continue;
              }
              if (s2 = 2, true === this.hasSkipped)
                u2 = this.haveMultiplyConfirmedCenters();
              else {
                var d2 = this.findRowSkip();
                d2 > c2[2] && (f3 += d2 - c2[2] - s2, l2 = a2 - 1);
              }
              h2 = 0, c2[0] = 0, c2[1] = 0, c2[2] = 0, c2[3] = 0, c2[4] = 0;
            } else
              c2[0] = c2[2], c2[1] = c2[3], c2[2] = c2[4], c2[3] = 1, c2[4] = 0, h2 = 3;
          else
            c2[++h2]++;
        else
          c2[h2]++;
      if (t2.foundPatternCross(c2))
        true === this.handlePossibleCenter(c2, f3, a2, n2) && (s2 = c2[0], this.hasSkipped && (u2 = this.haveMultiplyConfirmedCenters()));
    }
    var p2 = this.selectBestPatterns();
    return Lt.orderBestPatterns(p2), new Cn(p2);
  }, t2.centerFromEnd = function(t3, e2) {
    return e2 - t3[4] - t3[3] - t3[2] / 2;
  }, t2.foundPatternCross = function(t3) {
    for (var e2 = 0, r2 = 0; r2 < 5; r2++) {
      var n2 = t3[r2];
      if (0 === n2)
        return false;
      e2 += n2;
    }
    if (e2 < 7)
      return false;
    var o2 = e2 / 7, i2 = o2 / 2;
    return Math.abs(o2 - t3[0]) < i2 && Math.abs(o2 - t3[1]) < i2 && Math.abs(3 * o2 - t3[2]) < 3 * i2 && Math.abs(o2 - t3[3]) < i2 && Math.abs(o2 - t3[4]) < i2;
  }, t2.prototype.getCrossCheckStateCount = function() {
    var t3 = this.crossCheckStateCount;
    return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3;
  }, t2.prototype.crossCheckDiagonal = function(e2, r2, n2, o2) {
    for (var i2 = this.getCrossCheckStateCount(), a2 = 0, s2 = this.image; e2 >= a2 && r2 >= a2 && s2.get(r2 - a2, e2 - a2); )
      i2[2]++, a2++;
    if (e2 < a2 || r2 < a2)
      return false;
    for (; e2 >= a2 && r2 >= a2 && !s2.get(r2 - a2, e2 - a2) && i2[1] <= n2; )
      i2[1]++, a2++;
    if (e2 < a2 || r2 < a2 || i2[1] > n2)
      return false;
    for (; e2 >= a2 && r2 >= a2 && s2.get(r2 - a2, e2 - a2) && i2[0] <= n2; )
      i2[0]++, a2++;
    if (i2[0] > n2)
      return false;
    var u2 = s2.getHeight(), c2 = s2.getWidth();
    for (a2 = 1; e2 + a2 < u2 && r2 + a2 < c2 && s2.get(r2 + a2, e2 + a2); )
      i2[2]++, a2++;
    if (e2 + a2 >= u2 || r2 + a2 >= c2)
      return false;
    for (; e2 + a2 < u2 && r2 + a2 < c2 && !s2.get(r2 + a2, e2 + a2) && i2[3] < n2; )
      i2[3]++, a2++;
    if (e2 + a2 >= u2 || r2 + a2 >= c2 || i2[3] >= n2)
      return false;
    for (; e2 + a2 < u2 && r2 + a2 < c2 && s2.get(r2 + a2, e2 + a2) && i2[4] < n2; )
      i2[4]++, a2++;
    if (i2[4] >= n2)
      return false;
    var f3 = i2[0] + i2[1] + i2[2] + i2[3] + i2[4];
    return Math.abs(f3 - o2) < 2 * o2 && t2.foundPatternCross(i2);
  }, t2.prototype.crossCheckVertical = function(e2, r2, n2, o2) {
    for (var i2 = this.image, a2 = i2.getHeight(), s2 = this.getCrossCheckStateCount(), u2 = e2; u2 >= 0 && i2.get(r2, u2); )
      s2[2]++, u2--;
    if (u2 < 0)
      return NaN;
    for (; u2 >= 0 && !i2.get(r2, u2) && s2[1] <= n2; )
      s2[1]++, u2--;
    if (u2 < 0 || s2[1] > n2)
      return NaN;
    for (; u2 >= 0 && i2.get(r2, u2) && s2[0] <= n2; )
      s2[0]++, u2--;
    if (s2[0] > n2)
      return NaN;
    for (u2 = e2 + 1; u2 < a2 && i2.get(r2, u2); )
      s2[2]++, u2++;
    if (u2 === a2)
      return NaN;
    for (; u2 < a2 && !i2.get(r2, u2) && s2[3] < n2; )
      s2[3]++, u2++;
    if (u2 === a2 || s2[3] >= n2)
      return NaN;
    for (; u2 < a2 && i2.get(r2, u2) && s2[4] < n2; )
      s2[4]++, u2++;
    if (s2[4] >= n2)
      return NaN;
    var c2 = s2[0] + s2[1] + s2[2] + s2[3] + s2[4];
    return 5 * Math.abs(c2 - o2) >= 2 * o2 ? NaN : t2.foundPatternCross(s2) ? t2.centerFromEnd(s2, u2) : NaN;
  }, t2.prototype.crossCheckHorizontal = function(e2, r2, n2, o2) {
    for (var i2 = this.image, a2 = i2.getWidth(), s2 = this.getCrossCheckStateCount(), u2 = e2; u2 >= 0 && i2.get(u2, r2); )
      s2[2]++, u2--;
    if (u2 < 0)
      return NaN;
    for (; u2 >= 0 && !i2.get(u2, r2) && s2[1] <= n2; )
      s2[1]++, u2--;
    if (u2 < 0 || s2[1] > n2)
      return NaN;
    for (; u2 >= 0 && i2.get(u2, r2) && s2[0] <= n2; )
      s2[0]++, u2--;
    if (s2[0] > n2)
      return NaN;
    for (u2 = e2 + 1; u2 < a2 && i2.get(u2, r2); )
      s2[2]++, u2++;
    if (u2 === a2)
      return NaN;
    for (; u2 < a2 && !i2.get(u2, r2) && s2[3] < n2; )
      s2[3]++, u2++;
    if (u2 === a2 || s2[3] >= n2)
      return NaN;
    for (; u2 < a2 && i2.get(u2, r2) && s2[4] < n2; )
      s2[4]++, u2++;
    if (s2[4] >= n2)
      return NaN;
    var c2 = s2[0] + s2[1] + s2[2] + s2[3] + s2[4];
    return 5 * Math.abs(c2 - o2) >= o2 ? NaN : t2.foundPatternCross(s2) ? t2.centerFromEnd(s2, u2) : NaN;
  }, t2.prototype.handlePossibleCenter = function(e2, r2, n2, o2) {
    var i2 = e2[0] + e2[1] + e2[2] + e2[3] + e2[4], a2 = t2.centerFromEnd(e2, n2), s2 = this.crossCheckVertical(r2, Math.floor(a2), e2[2], i2);
    if (!isNaN(s2) && (a2 = this.crossCheckHorizontal(Math.floor(a2), Math.floor(s2), e2[2], i2), !isNaN(a2) && (!o2 || this.crossCheckDiagonal(Math.floor(s2), Math.floor(a2), e2[2], i2)))) {
      for (var u2 = i2 / 7, c2 = false, f3 = this.possibleCenters, h2 = 0, l2 = f3.length; h2 < l2; h2++) {
        var d2 = f3[h2];
        if (d2.aboutEquals(u2, s2, a2)) {
          f3[h2] = d2.combineEstimate(s2, a2, u2), c2 = true;
          break;
        }
      }
      if (!c2) {
        var p2 = new An(a2, s2, u2);
        f3.push(p2), null !== this.resultPointCallback && void 0 !== this.resultPointCallback && this.resultPointCallback.foundPossibleResultPoint(p2);
      }
      return true;
    }
    return false;
  }, t2.prototype.findRowSkip = function() {
    var e2, r2;
    if (this.possibleCenters.length <= 1)
      return 0;
    var n2 = null;
    try {
      for (var o2 = mn(this.possibleCenters), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        var a2 = i2.value;
        if (a2.getCount() >= t2.CENTER_QUORUM) {
          if (null != n2)
            return this.hasSkipped = true, Math.floor((Math.abs(n2.getX() - a2.getX()) - Math.abs(n2.getY() - a2.getY())) / 2);
          n2 = a2;
        }
      }
    } catch (t3) {
      e2 = { error: t3 };
    } finally {
      try {
        i2 && !i2.done && (r2 = o2.return) && r2.call(o2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return 0;
  }, t2.prototype.haveMultiplyConfirmedCenters = function() {
    var e2, r2, n2, o2, i2 = 0, a2 = 0, s2 = this.possibleCenters.length;
    try {
      for (var u2 = mn(this.possibleCenters), c2 = u2.next(); !c2.done; c2 = u2.next()) {
        (p2 = c2.value).getCount() >= t2.CENTER_QUORUM && (i2++, a2 += p2.getEstimatedModuleSize());
      }
    } catch (t3) {
      e2 = { error: t3 };
    } finally {
      try {
        c2 && !c2.done && (r2 = u2.return) && r2.call(u2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    if (i2 < 3)
      return false;
    var f3 = a2 / s2, h2 = 0;
    try {
      for (var l2 = mn(this.possibleCenters), d2 = l2.next(); !d2.done; d2 = l2.next()) {
        var p2 = d2.value;
        h2 += Math.abs(p2.getEstimatedModuleSize() - f3);
      }
    } catch (t3) {
      n2 = { error: t3 };
    } finally {
      try {
        d2 && !d2.done && (o2 = l2.return) && o2.call(l2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    return h2 <= 0.05 * a2;
  }, t2.prototype.selectBestPatterns = function() {
    var t3, e2, r2, n2, o2 = this.possibleCenters.length;
    if (o2 < 3)
      throw new tt();
    var i2, a2 = this.possibleCenters;
    if (o2 > 3) {
      var s2 = 0, u2 = 0;
      try {
        for (var c2 = mn(this.possibleCenters), f3 = c2.next(); !f3.done; f3 = c2.next()) {
          var h2 = f3.value.getEstimatedModuleSize();
          s2 += h2, u2 += h2 * h2;
        }
      } catch (e3) {
        t3 = { error: e3 };
      } finally {
        try {
          f3 && !f3.done && (e2 = c2.return) && e2.call(c2);
        } finally {
          if (t3)
            throw t3.error;
        }
      }
      i2 = s2 / o2;
      var l2 = Math.sqrt(u2 / o2 - i2 * i2);
      a2.sort(function(t4, e3) {
        var r3 = Math.abs(e3.getEstimatedModuleSize() - i2), n3 = Math.abs(t4.getEstimatedModuleSize() - i2);
        return r3 < n3 ? -1 : r3 > n3 ? 1 : 0;
      });
      for (var d2 = Math.max(0.2 * i2, l2), p2 = 0; p2 < a2.length && a2.length > 3; p2++) {
        var g2 = a2[p2];
        Math.abs(g2.getEstimatedModuleSize() - i2) > d2 && (a2.splice(p2, 1), p2--);
      }
    }
    if (a2.length > 3) {
      s2 = 0;
      try {
        for (var y2 = mn(a2), w2 = y2.next(); !w2.done; w2 = y2.next()) {
          s2 += w2.value.getEstimatedModuleSize();
        }
      } catch (t4) {
        r2 = { error: t4 };
      } finally {
        try {
          w2 && !w2.done && (n2 = y2.return) && n2.call(y2);
        } finally {
          if (r2)
            throw r2.error;
        }
      }
      i2 = s2 / a2.length, a2.sort(function(t4, e3) {
        if (e3.getCount() === t4.getCount()) {
          var r3 = Math.abs(e3.getEstimatedModuleSize() - i2), n3 = Math.abs(t4.getEstimatedModuleSize() - i2);
          return r3 < n3 ? 1 : r3 > n3 ? -1 : 0;
        }
        return e3.getCount() - t4.getCount();
      }), a2.splice(3);
    }
    return [a2[0], a2[1], a2[2]];
  }, t2.CENTER_QUORUM = 2, t2.MIN_SKIP = 3, t2.MAX_MODULES = 57, t2;
}();
var In = function() {
  function t2(t3) {
    this.image = t3;
  }
  return t2.prototype.getImage = function() {
    return this.image;
  }, t2.prototype.getResultPointCallback = function() {
    return this.resultPointCallback;
  }, t2.prototype.detect = function(t3) {
    this.resultPointCallback = null == t3 ? null : t3.get(U.NEED_RESULT_POINT_CALLBACK);
    var e2 = new En(this.image, this.resultPointCallback).find(t3);
    return this.processFinderPatternInfo(e2);
  }, t2.prototype.processFinderPatternInfo = function(e2) {
    var r2 = e2.getTopLeft(), n2 = e2.getTopRight(), o2 = e2.getBottomLeft(), i2 = this.calculateModuleSize(r2, n2, o2);
    if (i2 < 1)
      throw new tt("No pattern found in proccess finder.");
    var a2 = t2.computeDimension(r2, n2, o2, i2), s2 = en.getProvisionalVersionForDimension(a2), u2 = s2.getDimensionForVersion() - 7, c2 = null;
    if (s2.getAlignmentPatternCenters().length > 0)
      for (var f3 = n2.getX() - r2.getX() + o2.getX(), h2 = n2.getY() - r2.getY() + o2.getY(), l2 = 1 - 3 / u2, d2 = Math.floor(r2.getX() + l2 * (f3 - r2.getX())), p2 = Math.floor(r2.getY() + l2 * (h2 - r2.getY())), g2 = 4; g2 <= 16; g2 <<= 1)
        try {
          c2 = this.findAlignmentInRegion(i2, d2, p2, g2);
          break;
        } catch (t3) {
          if (!(t3 instanceof tt))
            throw t3;
        }
    var y2 = t2.createTransform(r2, n2, o2, c2, a2), w2 = t2.sampleGrid(this.image, y2, a2);
    return new Ft(w2, null === c2 ? [o2, r2, n2] : [o2, r2, n2, c2]);
  }, t2.createTransform = function(t3, e2, r2, n2, o2) {
    var i2, a2, s2, u2, c2 = o2 - 3.5;
    return null !== n2 ? (i2 = n2.getX(), a2 = n2.getY(), u2 = s2 = c2 - 3) : (i2 = e2.getX() - t3.getX() + r2.getX(), a2 = e2.getY() - t3.getY() + r2.getY(), s2 = c2, u2 = c2), Ut.quadrilateralToQuadrilateral(3.5, 3.5, c2, 3.5, s2, u2, 3.5, c2, t3.getX(), t3.getY(), e2.getX(), e2.getY(), i2, a2, r2.getX(), r2.getY());
  }, t2.sampleGrid = function(t3, e2, r2) {
    return Wt.getInstance().sampleGridWithTransform(t3, r2, r2, e2);
  }, t2.computeDimension = function(t3, e2, r2, n2) {
    var o2 = Pt.round(Lt.distance(t3, e2) / n2), i2 = Pt.round(Lt.distance(t3, r2) / n2), a2 = Math.floor((o2 + i2) / 2) + 7;
    switch (3 & a2) {
      case 0:
        a2++;
        break;
      case 2:
        a2--;
        break;
      case 3:
        throw new tt("Dimensions could be not found.");
    }
    return a2;
  }, t2.prototype.calculateModuleSize = function(t3, e2, r2) {
    return (this.calculateModuleSizeOneWay(t3, e2) + this.calculateModuleSizeOneWay(t3, r2)) / 2;
  }, t2.prototype.calculateModuleSizeOneWay = function(t3, e2) {
    var r2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(t3.getX()), Math.floor(t3.getY()), Math.floor(e2.getX()), Math.floor(e2.getY())), n2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(e2.getX()), Math.floor(e2.getY()), Math.floor(t3.getX()), Math.floor(t3.getY()));
    return isNaN(r2) ? n2 / 7 : isNaN(n2) ? r2 / 7 : (r2 + n2) / 14;
  }, t2.prototype.sizeOfBlackWhiteBlackRunBothWays = function(t3, e2, r2, n2) {
    var o2 = this.sizeOfBlackWhiteBlackRun(t3, e2, r2, n2), i2 = 1, a2 = t3 - (r2 - t3);
    a2 < 0 ? (i2 = t3 / (t3 - a2), a2 = 0) : a2 >= this.image.getWidth() && (i2 = (this.image.getWidth() - 1 - t3) / (a2 - t3), a2 = this.image.getWidth() - 1);
    var s2 = Math.floor(e2 - (n2 - e2) * i2);
    return i2 = 1, s2 < 0 ? (i2 = e2 / (e2 - s2), s2 = 0) : s2 >= this.image.getHeight() && (i2 = (this.image.getHeight() - 1 - e2) / (s2 - e2), s2 = this.image.getHeight() - 1), a2 = Math.floor(t3 + (a2 - t3) * i2), (o2 += this.sizeOfBlackWhiteBlackRun(t3, e2, a2, s2)) - 1;
  }, t2.prototype.sizeOfBlackWhiteBlackRun = function(t3, e2, r2, n2) {
    var o2 = Math.abs(n2 - e2) > Math.abs(r2 - t3);
    if (o2) {
      var i2 = t3;
      t3 = e2, e2 = i2, i2 = r2, r2 = n2, n2 = i2;
    }
    for (var a2 = Math.abs(r2 - t3), s2 = Math.abs(n2 - e2), u2 = -a2 / 2, c2 = t3 < r2 ? 1 : -1, f3 = e2 < n2 ? 1 : -1, h2 = 0, l2 = r2 + c2, d2 = t3, p2 = e2; d2 !== l2; d2 += c2) {
      var g2 = o2 ? p2 : d2, y2 = o2 ? d2 : p2;
      if (1 === h2 === this.image.get(g2, y2)) {
        if (2 === h2)
          return Pt.distance(d2, p2, t3, e2);
        h2++;
      }
      if ((u2 += s2) > 0) {
        if (p2 === n2)
          break;
        p2 += f3, u2 -= a2;
      }
    }
    return 2 === h2 ? Pt.distance(r2 + c2, n2, t3, e2) : NaN;
  }, t2.prototype.findAlignmentInRegion = function(t3, e2, r2, n2) {
    var o2 = Math.floor(n2 * t3), i2 = Math.max(0, e2 - o2), a2 = Math.min(this.image.getWidth() - 1, e2 + o2);
    if (a2 - i2 < 3 * t3)
      throw new tt("Alignment top exceeds estimated module size.");
    var s2 = Math.max(0, r2 - o2), u2 = Math.min(this.image.getHeight() - 1, r2 + o2);
    if (u2 - s2 < 3 * t3)
      throw new tt("Alignment bottom exceeds estimated module size.");
    return new vn(this.image, i2, s2, a2 - i2, u2 - s2, t3, this.resultPointCallback).find();
  }, t2;
}();
var Sn = function() {
  function t2() {
    this.decoder = new pn();
  }
  return t2.prototype.getDecoder = function() {
    return this.decoder;
  }, t2.prototype.decode = function(e2, r2) {
    var n2, o2;
    if (null != r2 && void 0 !== r2.get(U.PURE_BARCODE)) {
      var i2 = t2.extractPureBits(e2.getBlackMatrix());
      n2 = this.decoder.decodeBitMatrix(i2, r2), o2 = t2.NO_POINTS;
    } else {
      var a2 = new In(e2.getBlackMatrix()).detect(r2);
      n2 = this.decoder.decodeBitMatrix(a2.getBits(), r2), o2 = a2.getPoints();
    }
    n2.getOther() instanceof ln && n2.getOther().applyMirroredCorrection(o2);
    var s2 = new gt(n2.getText(), n2.getRawBytes(), void 0, o2, wt.QR_CODE, void 0), u2 = n2.getByteSegments();
    null !== u2 && s2.putMetadata(_t.BYTE_SEGMENTS, u2);
    var c2 = n2.getECLevel();
    return null !== c2 && s2.putMetadata(_t.ERROR_CORRECTION_LEVEL, c2), n2.hasStructuredAppend() && (s2.putMetadata(_t.STRUCTURED_APPEND_SEQUENCE, n2.getStructuredAppendSequenceNumber()), s2.putMetadata(_t.STRUCTURED_APPEND_PARITY, n2.getStructuredAppendParity())), s2;
  }, t2.prototype.reset = function() {
  }, t2.extractPureBits = function(t3) {
    var e2 = t3.getTopLeftOnBit(), r2 = t3.getBottomRightOnBit();
    if (null === e2 || null === r2)
      throw new tt();
    var n2 = this.moduleSize(e2, t3), o2 = e2[1], i2 = r2[1], a2 = e2[0], s2 = r2[0];
    if (a2 >= s2 || o2 >= i2)
      throw new tt();
    if (i2 - o2 != s2 - a2 && (s2 = a2 + (i2 - o2)) >= t3.getWidth())
      throw new tt();
    var u2 = Math.round((s2 - a2 + 1) / n2), c2 = Math.round((i2 - o2 + 1) / n2);
    if (u2 <= 0 || c2 <= 0)
      throw new tt();
    if (c2 !== u2)
      throw new tt();
    var f3 = Math.floor(n2 / 2);
    o2 += f3;
    var h2 = (a2 += f3) + Math.floor((u2 - 1) * n2) - s2;
    if (h2 > 0) {
      if (h2 > f3)
        throw new tt();
      a2 -= h2;
    }
    var l2 = o2 + Math.floor((c2 - 1) * n2) - i2;
    if (l2 > 0) {
      if (l2 > f3)
        throw new tt();
      o2 -= l2;
    }
    for (var d2 = new J(u2, c2), p2 = 0; p2 < c2; p2++)
      for (var g2 = o2 + Math.floor(p2 * n2), y2 = 0; y2 < u2; y2++)
        t3.get(a2 + Math.floor(y2 * n2), g2) && d2.set(y2, p2);
    return d2;
  }, t2.moduleSize = function(t3, e2) {
    for (var r2 = e2.getHeight(), n2 = e2.getWidth(), o2 = t3[0], i2 = t3[1], a2 = true, s2 = 0; o2 < n2 && i2 < r2; ) {
      if (a2 !== e2.get(o2, i2)) {
        if (5 == ++s2)
          break;
        a2 = !a2;
      }
      o2++, i2++;
    }
    if (o2 === n2 || i2 === r2)
      throw new tt();
    return (o2 - t3[0]) / 7;
  }, t2.NO_POINTS = new Array(), t2;
}();
var Tn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var On = function() {
  function t2() {
  }
  return t2.prototype.PDF417Common = function() {
  }, t2.getBitCountSum = function(t3) {
    return Pt.sum(t3);
  }, t2.toIntArray = function(e2) {
    var r2, n2;
    if (null == e2 || !e2.length)
      return t2.EMPTY_INT_ARRAY;
    var o2 = new Int32Array(e2.length), i2 = 0;
    try {
      for (var a2 = Tn(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
        var u2 = s2.value;
        o2[i2++] = u2;
      }
    } catch (t3) {
      r2 = { error: t3 };
    } finally {
      try {
        s2 && !s2.done && (n2 = a2.return) && n2.call(a2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    return o2;
  }, t2.getCodeword = function(e2) {
    var r2 = k.binarySearch(t2.SYMBOL_TABLE, 262143 & e2);
    return r2 < 0 ? -1 : (t2.CODEWORD_TABLE[r2] - 1) % t2.NUMBER_OF_CODEWORDS;
  }, t2.NUMBER_OF_CODEWORDS = 929, t2.MAX_CODEWORDS_IN_BARCODE = t2.NUMBER_OF_CODEWORDS - 1, t2.MIN_ROWS_IN_BARCODE = 3, t2.MAX_ROWS_IN_BARCODE = 90, t2.MODULES_IN_CODEWORD = 17, t2.MODULES_IN_STOP_PATTERN = 18, t2.BARS_IN_MODULE = 8, t2.EMPTY_INT_ARRAY = new Int32Array([]), t2.SYMBOL_TABLE = Int32Array.from([66142, 66170, 66206, 66236, 66290, 66292, 66350, 66382, 66396, 66454, 66470, 66476, 66594, 66600, 66614, 66626, 66628, 66632, 66640, 66654, 66662, 66668, 66682, 66690, 66718, 66720, 66748, 66758, 66776, 66798, 66802, 66804, 66820, 66824, 66832, 66846, 66848, 66876, 66880, 66936, 66950, 66956, 66968, 66992, 67006, 67022, 67036, 67042, 67044, 67048, 67062, 67118, 67150, 67164, 67214, 67228, 67256, 67294, 67322, 67350, 67366, 67372, 67398, 67404, 67416, 67438, 67474, 67476, 67490, 67492, 67496, 67510, 67618, 67624, 67650, 67656, 67664, 67678, 67686, 67692, 67706, 67714, 67716, 67728, 67742, 67744, 67772, 67782, 67788, 67800, 67822, 67826, 67828, 67842, 67848, 67870, 67872, 67900, 67904, 67960, 67974, 67992, 68016, 68030, 68046, 68060, 68066, 68068, 68072, 68086, 68104, 68112, 68126, 68128, 68156, 68160, 68216, 68336, 68358, 68364, 68376, 68400, 68414, 68448, 68476, 68494, 68508, 68536, 68546, 68548, 68552, 68560, 68574, 68582, 68588, 68654, 68686, 68700, 68706, 68708, 68712, 68726, 68750, 68764, 68792, 68802, 68804, 68808, 68816, 68830, 68838, 68844, 68858, 68878, 68892, 68920, 68976, 68990, 68994, 68996, 69e3, 69008, 69022, 69024, 69052, 69062, 69068, 69080, 69102, 69106, 69108, 69142, 69158, 69164, 69190, 69208, 69230, 69254, 69260, 69272, 69296, 69310, 69326, 69340, 69386, 69394, 69396, 69410, 69416, 69430, 69442, 69444, 69448, 69456, 69470, 69478, 69484, 69554, 69556, 69666, 69672, 69698, 69704, 69712, 69726, 69754, 69762, 69764, 69776, 69790, 69792, 69820, 69830, 69836, 69848, 69870, 69874, 69876, 69890, 69918, 69920, 69948, 69952, 70008, 70022, 70040, 70064, 70078, 70094, 70108, 70114, 70116, 70120, 70134, 70152, 70174, 70176, 70264, 70384, 70412, 70448, 70462, 70496, 70524, 70542, 70556, 70584, 70594, 70600, 70608, 70622, 70630, 70636, 70664, 70672, 70686, 70688, 70716, 70720, 70776, 70896, 71136, 71180, 71192, 71216, 71230, 71264, 71292, 71360, 71416, 71452, 71480, 71536, 71550, 71554, 71556, 71560, 71568, 71582, 71584, 71612, 71622, 71628, 71640, 71662, 71726, 71732, 71758, 71772, 71778, 71780, 71784, 71798, 71822, 71836, 71864, 71874, 71880, 71888, 71902, 71910, 71916, 71930, 71950, 71964, 71992, 72048, 72062, 72066, 72068, 72080, 72094, 72096, 72124, 72134, 72140, 72152, 72174, 72178, 72180, 72206, 72220, 72248, 72304, 72318, 72416, 72444, 72456, 72464, 72478, 72480, 72508, 72512, 72568, 72588, 72600, 72624, 72638, 72654, 72668, 72674, 72676, 72680, 72694, 72726, 72742, 72748, 72774, 72780, 72792, 72814, 72838, 72856, 72880, 72894, 72910, 72924, 72930, 72932, 72936, 72950, 72966, 72972, 72984, 73008, 73022, 73056, 73084, 73102, 73116, 73144, 73156, 73160, 73168, 73182, 73190, 73196, 73210, 73226, 73234, 73236, 73250, 73252, 73256, 73270, 73282, 73284, 73296, 73310, 73318, 73324, 73346, 73348, 73352, 73360, 73374, 73376, 73404, 73414, 73420, 73432, 73454, 73498, 73518, 73522, 73524, 73550, 73564, 73570, 73572, 73576, 73590, 73800, 73822, 73858, 73860, 73872, 73886, 73888, 73916, 73944, 73970, 73972, 73992, 74014, 74016, 74044, 74048, 74104, 74118, 74136, 74160, 74174, 74210, 74212, 74216, 74230, 74244, 74256, 74270, 74272, 74360, 74480, 74502, 74508, 74544, 74558, 74592, 74620, 74638, 74652, 74680, 74690, 74696, 74704, 74726, 74732, 74782, 74784, 74812, 74992, 75232, 75288, 75326, 75360, 75388, 75456, 75512, 75576, 75632, 75646, 75650, 75652, 75664, 75678, 75680, 75708, 75718, 75724, 75736, 75758, 75808, 75836, 75840, 75896, 76016, 76256, 76736, 76824, 76848, 76862, 76896, 76924, 76992, 77048, 77296, 77340, 77368, 77424, 77438, 77536, 77564, 77572, 77576, 77584, 77600, 77628, 77632, 77688, 77702, 77708, 77720, 77744, 77758, 77774, 77788, 77870, 77902, 77916, 77922, 77928, 77966, 77980, 78008, 78018, 78024, 78032, 78046, 78060, 78074, 78094, 78136, 78192, 78206, 78210, 78212, 78224, 78238, 78240, 78268, 78278, 78284, 78296, 78322, 78324, 78350, 78364, 78448, 78462, 78560, 78588, 78600, 78622, 78624, 78652, 78656, 78712, 78726, 78744, 78768, 78782, 78798, 78812, 78818, 78820, 78824, 78838, 78862, 78876, 78904, 78960, 78974, 79072, 79100, 79296, 79352, 79368, 79376, 79390, 79392, 79420, 79424, 79480, 79600, 79628, 79640, 79664, 79678, 79712, 79740, 79772, 79800, 79810, 79812, 79816, 79824, 79838, 79846, 79852, 79894, 79910, 79916, 79942, 79948, 79960, 79982, 79988, 80006, 80024, 80048, 80062, 80078, 80092, 80098, 80100, 80104, 80134, 80140, 80176, 80190, 80224, 80252, 80270, 80284, 80312, 80328, 80336, 80350, 80358, 80364, 80378, 80390, 80396, 80408, 80432, 80446, 80480, 80508, 80576, 80632, 80654, 80668, 80696, 80752, 80766, 80776, 80784, 80798, 80800, 80828, 80844, 80856, 80878, 80882, 80884, 80914, 80916, 80930, 80932, 80936, 80950, 80962, 80968, 80976, 80990, 80998, 81004, 81026, 81028, 81040, 81054, 81056, 81084, 81094, 81100, 81112, 81134, 81154, 81156, 81160, 81168, 81182, 81184, 81212, 81216, 81272, 81286, 81292, 81304, 81328, 81342, 81358, 81372, 81380, 81384, 81398, 81434, 81454, 81458, 81460, 81486, 81500, 81506, 81508, 81512, 81526, 81550, 81564, 81592, 81602, 81604, 81608, 81616, 81630, 81638, 81644, 81702, 81708, 81722, 81734, 81740, 81752, 81774, 81778, 81780, 82050, 82078, 82080, 82108, 82180, 82184, 82192, 82206, 82208, 82236, 82240, 82296, 82316, 82328, 82352, 82366, 82402, 82404, 82408, 82440, 82448, 82462, 82464, 82492, 82496, 82552, 82672, 82694, 82700, 82712, 82736, 82750, 82784, 82812, 82830, 82882, 82884, 82888, 82896, 82918, 82924, 82952, 82960, 82974, 82976, 83004, 83008, 83064, 83184, 83424, 83468, 83480, 83504, 83518, 83552, 83580, 83648, 83704, 83740, 83768, 83824, 83838, 83842, 83844, 83848, 83856, 83872, 83900, 83910, 83916, 83928, 83950, 83984, 84e3, 84028, 84032, 84088, 84208, 84448, 84928, 85040, 85054, 85088, 85116, 85184, 85240, 85488, 85560, 85616, 85630, 85728, 85756, 85764, 85768, 85776, 85790, 85792, 85820, 85824, 85880, 85894, 85900, 85912, 85936, 85966, 85980, 86048, 86080, 86136, 86256, 86496, 86976, 88160, 88188, 88256, 88312, 88560, 89056, 89200, 89214, 89312, 89340, 89536, 89592, 89608, 89616, 89632, 89664, 89720, 89840, 89868, 89880, 89904, 89952, 89980, 89998, 90012, 90040, 90190, 90204, 90254, 90268, 90296, 90306, 90308, 90312, 90334, 90382, 90396, 90424, 90480, 90494, 90500, 90504, 90512, 90526, 90528, 90556, 90566, 90572, 90584, 90610, 90612, 90638, 90652, 90680, 90736, 90750, 90848, 90876, 90884, 90888, 90896, 90910, 90912, 90940, 90944, 91e3, 91014, 91020, 91032, 91056, 91070, 91086, 91100, 91106, 91108, 91112, 91126, 91150, 91164, 91192, 91248, 91262, 91360, 91388, 91584, 91640, 91664, 91678, 91680, 91708, 91712, 91768, 91888, 91928, 91952, 91966, 92e3, 92028, 92046, 92060, 92088, 92098, 92100, 92104, 92112, 92126, 92134, 92140, 92188, 92216, 92272, 92384, 92412, 92608, 92664, 93168, 93200, 93214, 93216, 93244, 93248, 93304, 93424, 93664, 93720, 93744, 93758, 93792, 93820, 93888, 93944, 93980, 94008, 94064, 94078, 94084, 94088, 94096, 94110, 94112, 94140, 94150, 94156, 94168, 94246, 94252, 94278, 94284, 94296, 94318, 94342, 94348, 94360, 94384, 94398, 94414, 94428, 94440, 94470, 94476, 94488, 94512, 94526, 94560, 94588, 94606, 94620, 94648, 94658, 94660, 94664, 94672, 94686, 94694, 94700, 94714, 94726, 94732, 94744, 94768, 94782, 94816, 94844, 94912, 94968, 94990, 95004, 95032, 95088, 95102, 95112, 95120, 95134, 95136, 95164, 95180, 95192, 95214, 95218, 95220, 95244, 95256, 95280, 95294, 95328, 95356, 95424, 95480, 95728, 95758, 95772, 95800, 95856, 95870, 95968, 95996, 96008, 96016, 96030, 96032, 96060, 96064, 96120, 96152, 96176, 96190, 96220, 96226, 96228, 96232, 96290, 96292, 96296, 96310, 96322, 96324, 96328, 96336, 96350, 96358, 96364, 96386, 96388, 96392, 96400, 96414, 96416, 96444, 96454, 96460, 96472, 96494, 96498, 96500, 96514, 96516, 96520, 96528, 96542, 96544, 96572, 96576, 96632, 96646, 96652, 96664, 96688, 96702, 96718, 96732, 96738, 96740, 96744, 96758, 96772, 96776, 96784, 96798, 96800, 96828, 96832, 96888, 97008, 97030, 97036, 97048, 97072, 97086, 97120, 97148, 97166, 97180, 97208, 97220, 97224, 97232, 97246, 97254, 97260, 97326, 97330, 97332, 97358, 97372, 97378, 97380, 97384, 97398, 97422, 97436, 97464, 97474, 97476, 97480, 97488, 97502, 97510, 97516, 97550, 97564, 97592, 97648, 97666, 97668, 97672, 97680, 97694, 97696, 97724, 97734, 97740, 97752, 97774, 97830, 97836, 97850, 97862, 97868, 97880, 97902, 97906, 97908, 97926, 97932, 97944, 97968, 97998, 98012, 98018, 98020, 98024, 98038, 98618, 98674, 98676, 98838, 98854, 98874, 98892, 98904, 98926, 98930, 98932, 98968, 99006, 99042, 99044, 99048, 99062, 99166, 99194, 99246, 99286, 99350, 99366, 99372, 99386, 99398, 99416, 99438, 99442, 99444, 99462, 99504, 99518, 99534, 99548, 99554, 99556, 99560, 99574, 99590, 99596, 99608, 99632, 99646, 99680, 99708, 99726, 99740, 99768, 99778, 99780, 99784, 99792, 99806, 99814, 99820, 99834, 99858, 99860, 99874, 99880, 99894, 99906, 99920, 99934, 99962, 99970, 99972, 99976, 99984, 99998, 1e5, 100028, 100038, 100044, 100056, 100078, 100082, 100084, 100142, 100174, 100188, 100246, 100262, 100268, 100306, 100308, 100390, 100396, 100410, 100422, 100428, 100440, 100462, 100466, 100468, 100486, 100504, 100528, 100542, 100558, 100572, 100578, 100580, 100584, 100598, 100620, 100656, 100670, 100704, 100732, 100750, 100792, 100802, 100808, 100816, 100830, 100838, 100844, 100858, 100888, 100912, 100926, 100960, 100988, 101056, 101112, 101148, 101176, 101232, 101246, 101250, 101252, 101256, 101264, 101278, 101280, 101308, 101318, 101324, 101336, 101358, 101362, 101364, 101410, 101412, 101416, 101430, 101442, 101448, 101456, 101470, 101478, 101498, 101506, 101508, 101520, 101534, 101536, 101564, 101580, 101618, 101620, 101636, 101640, 101648, 101662, 101664, 101692, 101696, 101752, 101766, 101784, 101838, 101858, 101860, 101864, 101934, 101938, 101940, 101966, 101980, 101986, 101988, 101992, 102030, 102044, 102072, 102082, 102084, 102088, 102096, 102138, 102166, 102182, 102188, 102214, 102220, 102232, 102254, 102282, 102290, 102292, 102306, 102308, 102312, 102326, 102444, 102458, 102470, 102476, 102488, 102514, 102516, 102534, 102552, 102576, 102590, 102606, 102620, 102626, 102632, 102646, 102662, 102668, 102704, 102718, 102752, 102780, 102798, 102812, 102840, 102850, 102856, 102864, 102878, 102886, 102892, 102906, 102936, 102974, 103008, 103036, 103104, 103160, 103224, 103280, 103294, 103298, 103300, 103312, 103326, 103328, 103356, 103366, 103372, 103384, 103406, 103410, 103412, 103472, 103486, 103520, 103548, 103616, 103672, 103920, 103992, 104048, 104062, 104160, 104188, 104194, 104196, 104200, 104208, 104224, 104252, 104256, 104312, 104326, 104332, 104344, 104368, 104382, 104398, 104412, 104418, 104420, 104424, 104482, 104484, 104514, 104520, 104528, 104542, 104550, 104570, 104578, 104580, 104592, 104606, 104608, 104636, 104652, 104690, 104692, 104706, 104712, 104734, 104736, 104764, 104768, 104824, 104838, 104856, 104910, 104930, 104932, 104936, 104968, 104976, 104990, 104992, 105020, 105024, 105080, 105200, 105240, 105278, 105312, 105372, 105410, 105412, 105416, 105424, 105446, 105518, 105524, 105550, 105564, 105570, 105572, 105576, 105614, 105628, 105656, 105666, 105672, 105680, 105702, 105722, 105742, 105756, 105784, 105840, 105854, 105858, 105860, 105864, 105872, 105888, 105932, 105970, 105972, 106006, 106022, 106028, 106054, 106060, 106072, 106100, 106118, 106124, 106136, 106160, 106174, 106190, 106210, 106212, 106216, 106250, 106258, 106260, 106274, 106276, 106280, 106306, 106308, 106312, 106320, 106334, 106348, 106394, 106414, 106418, 106420, 106566, 106572, 106610, 106612, 106630, 106636, 106648, 106672, 106686, 106722, 106724, 106728, 106742, 106758, 106764, 106776, 106800, 106814, 106848, 106876, 106894, 106908, 106936, 106946, 106948, 106952, 106960, 106974, 106982, 106988, 107032, 107056, 107070, 107104, 107132, 107200, 107256, 107292, 107320, 107376, 107390, 107394, 107396, 107400, 107408, 107422, 107424, 107452, 107462, 107468, 107480, 107502, 107506, 107508, 107544, 107568, 107582, 107616, 107644, 107712, 107768, 108016, 108060, 108088, 108144, 108158, 108256, 108284, 108290, 108292, 108296, 108304, 108318, 108320, 108348, 108352, 108408, 108422, 108428, 108440, 108464, 108478, 108494, 108508, 108514, 108516, 108520, 108592, 108640, 108668, 108736, 108792, 109040, 109536, 109680, 109694, 109792, 109820, 110016, 110072, 110084, 110088, 110096, 110112, 110140, 110144, 110200, 110320, 110342, 110348, 110360, 110384, 110398, 110432, 110460, 110478, 110492, 110520, 110532, 110536, 110544, 110558, 110658, 110686, 110714, 110722, 110724, 110728, 110736, 110750, 110752, 110780, 110796, 110834, 110836, 110850, 110852, 110856, 110864, 110878, 110880, 110908, 110912, 110968, 110982, 111e3, 111054, 111074, 111076, 111080, 111108, 111112, 111120, 111134, 111136, 111164, 111168, 111224, 111344, 111372, 111422, 111456, 111516, 111554, 111556, 111560, 111568, 111590, 111632, 111646, 111648, 111676, 111680, 111736, 111856, 112096, 112152, 112224, 112252, 112320, 112440, 112514, 112516, 112520, 112528, 112542, 112544, 112588, 112686, 112718, 112732, 112782, 112796, 112824, 112834, 112836, 112840, 112848, 112870, 112890, 112910, 112924, 112952, 113008, 113022, 113026, 113028, 113032, 113040, 113054, 113056, 113100, 113138, 113140, 113166, 113180, 113208, 113264, 113278, 113376, 113404, 113416, 113424, 113440, 113468, 113472, 113560, 113614, 113634, 113636, 113640, 113686, 113702, 113708, 113734, 113740, 113752, 113778, 113780, 113798, 113804, 113816, 113840, 113854, 113870, 113890, 113892, 113896, 113926, 113932, 113944, 113968, 113982, 114016, 114044, 114076, 114114, 114116, 114120, 114128, 114150, 114170, 114194, 114196, 114210, 114212, 114216, 114242, 114244, 114248, 114256, 114270, 114278, 114306, 114308, 114312, 114320, 114334, 114336, 114364, 114380, 114420, 114458, 114478, 114482, 114484, 114510, 114524, 114530, 114532, 114536, 114842, 114866, 114868, 114970, 114994, 114996, 115042, 115044, 115048, 115062, 115130, 115226, 115250, 115252, 115278, 115292, 115298, 115300, 115304, 115318, 115342, 115394, 115396, 115400, 115408, 115422, 115430, 115436, 115450, 115478, 115494, 115514, 115526, 115532, 115570, 115572, 115738, 115758, 115762, 115764, 115790, 115804, 115810, 115812, 115816, 115830, 115854, 115868, 115896, 115906, 115912, 115920, 115934, 115942, 115948, 115962, 115996, 116024, 116080, 116094, 116098, 116100, 116104, 116112, 116126, 116128, 116156, 116166, 116172, 116184, 116206, 116210, 116212, 116246, 116262, 116268, 116282, 116294, 116300, 116312, 116334, 116338, 116340, 116358, 116364, 116376, 116400, 116414, 116430, 116444, 116450, 116452, 116456, 116498, 116500, 116514, 116520, 116534, 116546, 116548, 116552, 116560, 116574, 116582, 116588, 116602, 116654, 116694, 116714, 116762, 116782, 116786, 116788, 116814, 116828, 116834, 116836, 116840, 116854, 116878, 116892, 116920, 116930, 116936, 116944, 116958, 116966, 116972, 116986, 117006, 117048, 117104, 117118, 117122, 117124, 117136, 117150, 117152, 117180, 117190, 117196, 117208, 117230, 117234, 117236, 117304, 117360, 117374, 117472, 117500, 117506, 117508, 117512, 117520, 117536, 117564, 117568, 117624, 117638, 117644, 117656, 117680, 117694, 117710, 117724, 117730, 117732, 117736, 117750, 117782, 117798, 117804, 117818, 117830, 117848, 117874, 117876, 117894, 117936, 117950, 117966, 117986, 117988, 117992, 118022, 118028, 118040, 118064, 118078, 118112, 118140, 118172, 118210, 118212, 118216, 118224, 118238, 118246, 118266, 118306, 118312, 118338, 118352, 118366, 118374, 118394, 118402, 118404, 118408, 118416, 118430, 118432, 118460, 118476, 118514, 118516, 118574, 118578, 118580, 118606, 118620, 118626, 118628, 118632, 118678, 118694, 118700, 118730, 118738, 118740, 118830, 118834, 118836, 118862, 118876, 118882, 118884, 118888, 118902, 118926, 118940, 118968, 118978, 118980, 118984, 118992, 119006, 119014, 119020, 119034, 119068, 119096, 119152, 119166, 119170, 119172, 119176, 119184, 119198, 119200, 119228, 119238, 119244, 119256, 119278, 119282, 119284, 119324, 119352, 119408, 119422, 119520, 119548, 119554, 119556, 119560, 119568, 119582, 119584, 119612, 119616, 119672, 119686, 119692, 119704, 119728, 119742, 119758, 119772, 119778, 119780, 119784, 119798, 119920, 119934, 120032, 120060, 120256, 120312, 120324, 120328, 120336, 120352, 120384, 120440, 120560, 120582, 120588, 120600, 120624, 120638, 120672, 120700, 120718, 120732, 120760, 120770, 120772, 120776, 120784, 120798, 120806, 120812, 120870, 120876, 120890, 120902, 120908, 120920, 120946, 120948, 120966, 120972, 120984, 121008, 121022, 121038, 121058, 121060, 121064, 121078, 121100, 121112, 121136, 121150, 121184, 121212, 121244, 121282, 121284, 121288, 121296, 121318, 121338, 121356, 121368, 121392, 121406, 121440, 121468, 121536, 121592, 121656, 121730, 121732, 121736, 121744, 121758, 121760, 121804, 121842, 121844, 121890, 121922, 121924, 121928, 121936, 121950, 121958, 121978, 121986, 121988, 121992, 122e3, 122014, 122016, 122044, 122060, 122098, 122100, 122116, 122120, 122128, 122142, 122144, 122172, 122176, 122232, 122246, 122264, 122318, 122338, 122340, 122344, 122414, 122418, 122420, 122446, 122460, 122466, 122468, 122472, 122510, 122524, 122552, 122562, 122564, 122568, 122576, 122598, 122618, 122646, 122662, 122668, 122694, 122700, 122712, 122738, 122740, 122762, 122770, 122772, 122786, 122788, 122792, 123018, 123026, 123028, 123042, 123044, 123048, 123062, 123098, 123146, 123154, 123156, 123170, 123172, 123176, 123190, 123202, 123204, 123208, 123216, 123238, 123244, 123258, 123290, 123314, 123316, 123402, 123410, 123412, 123426, 123428, 123432, 123446, 123458, 123464, 123472, 123486, 123494, 123500, 123514, 123522, 123524, 123528, 123536, 123552, 123580, 123590, 123596, 123608, 123630, 123634, 123636, 123674, 123698, 123700, 123740, 123746, 123748, 123752, 123834, 123914, 123922, 123924, 123938, 123944, 123958, 123970, 123976, 123984, 123998, 124006, 124012, 124026, 124034, 124036, 124048, 124062, 124064, 124092, 124102, 124108, 124120, 124142, 124146, 124148, 124162, 124164, 124168, 124176, 124190, 124192, 124220, 124224, 124280, 124294, 124300, 124312, 124336, 124350, 124366, 124380, 124386, 124388, 124392, 124406, 124442, 124462, 124466, 124468, 124494, 124508, 124514, 124520, 124558, 124572, 124600, 124610, 124612, 124616, 124624, 124646, 124666, 124694, 124710, 124716, 124730, 124742, 124748, 124760, 124786, 124788, 124818, 124820, 124834, 124836, 124840, 124854, 124946, 124948, 124962, 124964, 124968, 124982, 124994, 124996, 125e3, 125008, 125022, 125030, 125036, 125050, 125058, 125060, 125064, 125072, 125086, 125088, 125116, 125126, 125132, 125144, 125166, 125170, 125172, 125186, 125188, 125192, 125200, 125216, 125244, 125248, 125304, 125318, 125324, 125336, 125360, 125374, 125390, 125404, 125410, 125412, 125416, 125430, 125444, 125448, 125456, 125472, 125504, 125560, 125680, 125702, 125708, 125720, 125744, 125758, 125792, 125820, 125838, 125852, 125880, 125890, 125892, 125896, 125904, 125918, 125926, 125932, 125978, 125998, 126002, 126004, 126030, 126044, 126050, 126052, 126056, 126094, 126108, 126136, 126146, 126148, 126152, 126160, 126182, 126202, 126222, 126236, 126264, 126320, 126334, 126338, 126340, 126344, 126352, 126366, 126368, 126412, 126450, 126452, 126486, 126502, 126508, 126522, 126534, 126540, 126552, 126574, 126578, 126580, 126598, 126604, 126616, 126640, 126654, 126670, 126684, 126690, 126692, 126696, 126738, 126754, 126756, 126760, 126774, 126786, 126788, 126792, 126800, 126814, 126822, 126828, 126842, 126894, 126898, 126900, 126934, 127126, 127142, 127148, 127162, 127178, 127186, 127188, 127254, 127270, 127276, 127290, 127302, 127308, 127320, 127342, 127346, 127348, 127370, 127378, 127380, 127394, 127396, 127400, 127450, 127510, 127526, 127532, 127546, 127558, 127576, 127598, 127602, 127604, 127622, 127628, 127640, 127664, 127678, 127694, 127708, 127714, 127716, 127720, 127734, 127754, 127762, 127764, 127778, 127784, 127810, 127812, 127816, 127824, 127838, 127846, 127866, 127898, 127918, 127922, 127924, 128022, 128038, 128044, 128058, 128070, 128076, 128088, 128110, 128114, 128116, 128134, 128140, 128152, 128176, 128190, 128206, 128220, 128226, 128228, 128232, 128246, 128262, 128268, 128280, 128304, 128318, 128352, 128380, 128398, 128412, 128440, 128450, 128452, 128456, 128464, 128478, 128486, 128492, 128506, 128522, 128530, 128532, 128546, 128548, 128552, 128566, 128578, 128580, 128584, 128592, 128606, 128614, 128634, 128642, 128644, 128648, 128656, 128670, 128672, 128700, 128716, 128754, 128756, 128794, 128814, 128818, 128820, 128846, 128860, 128866, 128868, 128872, 128886, 128918, 128934, 128940, 128954, 128978, 128980, 129178, 129198, 129202, 129204, 129238, 129258, 129306, 129326, 129330, 129332, 129358, 129372, 129378, 129380, 129384, 129398, 129430, 129446, 129452, 129466, 129482, 129490, 129492, 129562, 129582, 129586, 129588, 129614, 129628, 129634, 129636, 129640, 129654, 129678, 129692, 129720, 129730, 129732, 129736, 129744, 129758, 129766, 129772, 129814, 129830, 129836, 129850, 129862, 129868, 129880, 129902, 129906, 129908, 129930, 129938, 129940, 129954, 129956, 129960, 129974, 130010]), t2.CODEWORD_TABLE = Int32Array.from([2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868, 865, 861, 859, 2511, 873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811, 810, 809, 2483, 807, 2482, 806, 2480, 815, 814, 813, 812, 2484, 817, 816, 1745, 1744, 1742, 1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752, 2739, 2737, 2728, 2727, 2725, 2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752, 1719, 692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341, 627, 2338, 651, 646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321, 594, 2319, 2317, 611, 610, 608, 606, 2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612, 616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909, 2509, 2507, 2504, 870, 867, 864, 860, 2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830, 2494, 827, 2492, 843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629, 1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740, 2738, 2786, 2784, 591, 588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545, 542, 539, 548, 1572, 1570, 481, 2245, 466, 2242, 462, 2239, 492, 485, 482, 2249, 496, 494, 1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419, 2202, 415, 2199, 432, 430, 427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155, 2152, 378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385, 1411, 384, 1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406, 2403, 750, 742, 738, 2414, 756, 753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684, 2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337, 2336, 2334, 2332, 1624, 2329, 1622, 640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653, 1651, 1649, 1655, 2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900, 910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876, 874, 1782, 2720, 2713, 2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675, 2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654, 2652, 2650, 2657, 2771, 1855, 2765, 2762, 1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142, 332, 2140, 345, 1375, 1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262, 257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308, 1320, 1318, 2052, 202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066, 1260, 1258, 1252, 231, 1248, 229, 1266, 1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991, 1988, 165, 164, 2007, 162, 2006, 159, 2003, 2e3, 172, 171, 169, 2012, 166, 2010, 1186, 1184, 1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313, 2307, 2305, 592, 589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536, 529, 2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478, 2247, 470, 2244, 465, 2241, 493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187, 2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414, 412, 2197, 409, 2195, 405, 2193, 2190, 426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434, 1477, 1475, 2478, 2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785, 2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358, 2357, 2355, 2353, 1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687, 2374, 683, 2372, 701, 698, 705, 1691, 1689, 2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588, 2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573, 2570, 2567, 2577, 2525, 2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539, 906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824, 2673, 2671, 2669, 2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766, 2764, 143, 1987, 139, 1986, 135, 133, 131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985, 1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971, 1969, 122, 121, 119, 117, 1977, 114, 1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78, 1950, 1948, 1945, 94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100, 1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53, 1922, 1919, 66, 64, 1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047, 1045, 1043, 1050, 1049, 12, 10, 1869, 1867, 1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28, 1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989, 987, 984, 34, 995, 994, 992, 2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359, 343, 341, 338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324, 310, 308, 305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353, 1351, 1357, 2092, 2091, 2089, 2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252, 2098, 2095, 272, 269, 2108, 266, 2106, 281, 279, 277, 1317, 1315, 1313, 1310, 282, 1321, 1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205, 2051, 201, 2049, 2046, 2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232, 1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299, 1593, 2308, 2306, 590, 2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577, 574, 571, 2298, 582, 581, 1592, 2263, 2262, 2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273, 2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549, 1575, 1573, 2224, 2222, 2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480, 477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474, 2479, 2469, 2468, 2466, 2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728, 2460, 2458, 2456, 2463, 805, 804, 2428, 2427, 2425, 2423, 1725, 2420, 1724, 2417, 1722, 2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388, 2386, 2384, 1697, 2381, 1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751, 748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801, 1799, 2594, 2592, 2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560, 2557, 1798, 2554, 1796, 2574, 2572, 2569, 2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845, 2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695, 2704, 1817, 1811, 1810, 897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818, 2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645, 1643, 1640, 1648, 602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608, 1606, 613, 1615, 1613, 2328, 926, 924, 892, 886, 899, 857, 850, 2505, 1778, 824, 823, 821, 819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632, 2630, 2746, 2734, 2732, 2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486, 483, 1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468, 1465, 2210, 366, 363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407, 1405, 382, 1402, 380, 1417, 1415, 1412, 1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722, 2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684, 1681, 626, 624, 622, 2335, 620, 2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527, 894, 891, 888, 2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768, 2759, 2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296, 2126, 315, 312, 1347, 1342, 1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301, 1298, 276, 1312, 1309, 2115, 203, 2048, 195, 2045, 191, 2041, 213, 209, 2056, 1246, 1244, 1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997, 150, 1995, 147, 1992, 1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183, 1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588, 520, 518, 512, 2268, 508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479, 471, 489, 1526, 1523, 1520, 397, 395, 2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422, 1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779, 776, 773, 2397, 2394, 2390, 734, 728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688, 1685, 1683, 2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890, 2718, 2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760, 2758, 142, 141, 1139, 1138, 134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108, 105, 1972, 101, 1970, 120, 118, 115, 1109, 1108, 1106, 1104, 123, 1113, 1111, 82, 79, 1951, 75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98, 1069, 96, 1084, 1082, 1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920, 1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044, 1944, 1943, 1941, 11, 9, 1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968, 966, 963, 29, 960, 26, 23, 983, 981, 978, 975, 33, 971, 31, 990, 988, 985, 1906, 1904, 1902, 993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339, 1372, 1370, 294, 293, 291, 289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090, 239, 2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186, 2036, 183, 2033, 2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237, 1255, 2310, 2302, 2300, 2286, 2284, 2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256, 2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569, 1567, 2223, 2221, 2218, 2215, 1483, 2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467, 2465, 2451, 2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382, 2379, 1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601, 2584, 2583, 2581, 2579, 1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929, 2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688, 2686, 1815, 1809, 1808, 1774, 1756, 1754, 1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636, 1633, 1641, 598, 1605, 1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524, 1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458, 1455, 2208, 364, 361, 358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403, 1413, 2173, 2172, 772, 726, 723, 1712, 672, 669, 666, 682, 1678, 1675, 625, 623, 621, 618, 2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849, 848, 847, 846, 2497, 855, 852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343, 255, 251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224, 214, 1220, 210, 1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162, 1160, 1158, 1155, 161, 1152, 157, 1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018, 2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458, 447, 2227, 472, 1516, 1513, 1510, 398, 396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460, 2209, 769, 764, 720, 712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919, 2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127, 1125, 1124, 1122, 1127, 109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80, 76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060, 87, 1075, 1073, 1070, 1080, 1966, 1965, 46, 43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008, 51, 1029, 1027, 1024, 1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952, 949, 946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986, 1905, 1903, 350, 349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341, 1339, 1337, 1345, 243, 240, 237, 2086, 233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114, 190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231, 1229, 1226, 217, 1223, 1241, 2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499, 2254, 515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512, 2447, 798, 797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714, 2602, 2582, 2580, 2548, 2546, 2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771, 1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670, 1668, 1631, 1629, 1626, 1634, 1599, 1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504, 1501, 1498, 1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399, 1397, 1394, 1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363, 1361, 1333, 1328, 1336, 1286, 1281, 1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197, 1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150, 1148, 1146, 152, 1143, 149, 1140, 145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582, 510, 1556, 1553, 452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713, 1709, 662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118, 1123, 1097, 1096, 1094, 1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74, 1066, 1064, 1061, 1071, 1964, 1963, 1007, 1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015, 1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940, 938, 935, 932, 5, 2, 955, 953, 950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897, 1379, 325, 1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112, 188, 185, 181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553, 551, 1583, 505, 503, 500, 513, 1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505, 1502, 796, 763, 762, 760, 767, 711, 710, 708, 706, 2377, 718, 715, 1710, 2544, 917, 915, 2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204, 1390, 1388, 1385, 1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214, 1207, 1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015, 1579, 1549, 1546, 1495, 1487, 1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667, 1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062, 1962, 1960, 1005, 1003, 1e3, 997, 38, 1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951, 948, 944, 1889, 1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275, 1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580, 501, 1551, 1548, 440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198, 1386, 2164, 2161, 1621, 1766, 2103, 1208, 2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009, 1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954, 1001, 998, 1924, 1921, 1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270, 2105, 1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700]), t2;
}();
var bn = function() {
  function t2(t3, e2) {
    this.bits = t3, this.points = e2;
  }
  return t2.prototype.getBits = function() {
    return this.bits;
  }, t2.prototype.getPoints = function() {
    return this.points;
  }, t2;
}();
var Rn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Nn = function() {
  function t2() {
  }
  return t2.detectMultiple = function(e2, r2, n2) {
    var o2 = e2.getBlackMatrix(), i2 = t2.detect(n2, o2);
    return i2.length || ((o2 = o2.clone()).rotate180(), i2 = t2.detect(n2, o2)), new bn(o2, i2);
  }, t2.detect = function(e2, r2) {
    for (var n2, o2, i2 = new Array(), a2 = 0, s2 = 0, u2 = false; a2 < r2.getHeight(); ) {
      var c2 = t2.findVertices(r2, a2, s2);
      if (null != c2[0] || null != c2[3]) {
        if (u2 = true, i2.push(c2), !e2)
          break;
        null != c2[2] ? (s2 = Math.trunc(c2[2].getX()), a2 = Math.trunc(c2[2].getY())) : (s2 = Math.trunc(c2[4].getX()), a2 = Math.trunc(c2[4].getY()));
      } else {
        if (!u2)
          break;
        u2 = false, s2 = 0;
        try {
          for (var f3 = (n2 = void 0, Rn(i2)), h2 = f3.next(); !h2.done; h2 = f3.next()) {
            var l2 = h2.value;
            null != l2[1] && (a2 = Math.trunc(Math.max(a2, l2[1].getY()))), null != l2[3] && (a2 = Math.max(a2, Math.trunc(l2[3].getY())));
          }
        } catch (t3) {
          n2 = { error: t3 };
        } finally {
          try {
            h2 && !h2.done && (o2 = f3.return) && o2.call(f3);
          } finally {
            if (n2)
              throw n2.error;
          }
        }
        a2 += t2.ROW_STEP;
      }
    }
    return i2;
  }, t2.findVertices = function(e2, r2, n2) {
    var o2 = e2.getHeight(), i2 = e2.getWidth(), a2 = new Array(8);
    return t2.copyToResult(a2, t2.findRowsWithPattern(e2, o2, i2, r2, n2, t2.START_PATTERN), t2.INDEXES_START_PATTERN), null != a2[4] && (n2 = Math.trunc(a2[4].getX()), r2 = Math.trunc(a2[4].getY())), t2.copyToResult(a2, t2.findRowsWithPattern(e2, o2, i2, r2, n2, t2.STOP_PATTERN), t2.INDEXES_STOP_PATTERN), a2;
  }, t2.copyToResult = function(t3, e2, r2) {
    for (var n2 = 0; n2 < r2.length; n2++)
      t3[r2[n2]] = e2[n2];
  }, t2.findRowsWithPattern = function(e2, r2, n2, o2, i2, a2) {
    for (var s2 = new Array(4), u2 = false, c2 = new Int32Array(a2.length); o2 < r2; o2 += t2.ROW_STEP) {
      if (null != (d2 = t2.findGuardPattern(e2, i2, o2, n2, false, a2, c2))) {
        for (; o2 > 0; ) {
          if (null == (l2 = t2.findGuardPattern(e2, i2, --o2, n2, false, a2, c2))) {
            o2++;
            break;
          }
          d2 = l2;
        }
        s2[0] = new Lt(d2[0], o2), s2[1] = new Lt(d2[1], o2), u2 = true;
        break;
      }
    }
    var f3 = o2 + 1;
    if (u2) {
      for (var h2 = 0, l2 = Int32Array.from([Math.trunc(s2[0].getX()), Math.trunc(s2[1].getX())]); f3 < r2; f3++) {
        var d2;
        if (null != (d2 = t2.findGuardPattern(e2, l2[0], f3, n2, false, a2, c2)) && Math.abs(l2[0] - d2[0]) < t2.MAX_PATTERN_DRIFT && Math.abs(l2[1] - d2[1]) < t2.MAX_PATTERN_DRIFT)
          l2 = d2, h2 = 0;
        else {
          if (h2 > t2.SKIPPED_ROW_COUNT_MAX)
            break;
          h2++;
        }
      }
      f3 -= h2 + 1, s2[2] = new Lt(l2[0], f3), s2[3] = new Lt(l2[1], f3);
    }
    return f3 - o2 < t2.BARCODE_MIN_HEIGHT && k.fill(s2, null), s2;
  }, t2.findGuardPattern = function(e2, r2, n2, o2, i2, a2, s2) {
    k.fillWithin(s2, 0, s2.length, 0);
    for (var u2 = r2, c2 = 0; e2.get(u2, n2) && u2 > 0 && c2++ < t2.MAX_PIXEL_DRIFT; )
      u2--;
    for (var f3 = u2, h2 = 0, l2 = a2.length, d2 = i2; f3 < o2; f3++) {
      if (e2.get(f3, n2) !== d2)
        s2[h2]++;
      else {
        if (h2 === l2 - 1) {
          if (t2.patternMatchVariance(s2, a2, t2.MAX_INDIVIDUAL_VARIANCE) < t2.MAX_AVG_VARIANCE)
            return new Int32Array([u2, f3]);
          u2 += s2[0] + s2[1], D.arraycopy(s2, 2, s2, 0, h2 - 1), s2[h2 - 1] = 0, s2[h2] = 0, h2--;
        } else
          h2++;
        s2[h2] = 1, d2 = !d2;
      }
    }
    return h2 === l2 - 1 && t2.patternMatchVariance(s2, a2, t2.MAX_INDIVIDUAL_VARIANCE) < t2.MAX_AVG_VARIANCE ? new Int32Array([u2, f3 - 1]) : null;
  }, t2.patternMatchVariance = function(t3, e2, r2) {
    for (var n2 = t3.length, o2 = 0, i2 = 0, a2 = 0; a2 < n2; a2++)
      o2 += t3[a2], i2 += e2[a2];
    if (o2 < i2)
      return 1 / 0;
    var s2 = o2 / i2;
    r2 *= s2;
    for (var u2 = 0, c2 = 0; c2 < n2; c2++) {
      var f3 = t3[c2], h2 = e2[c2] * s2, l2 = f3 > h2 ? f3 - h2 : h2 - f3;
      if (l2 > r2)
        return 1 / 0;
      u2 += l2;
    }
    return u2 / o2;
  }, t2.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]), t2.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]), t2.MAX_AVG_VARIANCE = 0.42, t2.MAX_INDIVIDUAL_VARIANCE = 0.8, t2.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]), t2.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]), t2.MAX_PIXEL_DRIFT = 3, t2.MAX_PATTERN_DRIFT = 5, t2.SKIPPED_ROW_COUNT_MAX = 25, t2.ROW_STEP = 5, t2.BARCODE_MIN_HEIGHT = 10, t2;
}();
var Dn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Mn = function() {
  function t2(t3, e2) {
    if (0 === e2.length)
      throw new T();
    this.field = t3;
    var r2 = e2.length;
    if (r2 > 1 && 0 === e2[0]) {
      for (var n2 = 1; n2 < r2 && 0 === e2[n2]; )
        n2++;
      n2 === r2 ? this.coefficients = new Int32Array([0]) : (this.coefficients = new Int32Array(r2 - n2), D.arraycopy(e2, n2, this.coefficients, 0, this.coefficients.length));
    } else
      this.coefficients = e2;
  }
  return t2.prototype.getCoefficients = function() {
    return this.coefficients;
  }, t2.prototype.getDegree = function() {
    return this.coefficients.length - 1;
  }, t2.prototype.isZero = function() {
    return 0 === this.coefficients[0];
  }, t2.prototype.getCoefficient = function(t3) {
    return this.coefficients[this.coefficients.length - 1 - t3];
  }, t2.prototype.evaluateAt = function(t3) {
    var e2, r2;
    if (0 === t3)
      return this.getCoefficient(0);
    if (1 === t3) {
      var n2 = 0;
      try {
        for (var o2 = Dn(this.coefficients), i2 = o2.next(); !i2.done; i2 = o2.next()) {
          var a2 = i2.value;
          n2 = this.field.add(n2, a2);
        }
      } catch (t4) {
        e2 = { error: t4 };
      } finally {
        try {
          i2 && !i2.done && (r2 = o2.return) && r2.call(o2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return n2;
    }
    for (var s2 = this.coefficients[0], u2 = this.coefficients.length, c2 = 1; c2 < u2; c2++)
      s2 = this.field.add(this.field.multiply(t3, s2), this.coefficients[c2]);
    return s2;
  }, t2.prototype.add = function(e2) {
    if (!this.field.equals(e2.field))
      throw new T("ModulusPolys do not have same ModulusGF field");
    if (this.isZero())
      return e2;
    if (e2.isZero())
      return this;
    var r2 = this.coefficients, n2 = e2.coefficients;
    if (r2.length > n2.length) {
      var o2 = r2;
      r2 = n2, n2 = o2;
    }
    var i2 = new Int32Array(n2.length), a2 = n2.length - r2.length;
    D.arraycopy(n2, 0, i2, 0, a2);
    for (var s2 = a2; s2 < n2.length; s2++)
      i2[s2] = this.field.add(r2[s2 - a2], n2[s2]);
    return new t2(this.field, i2);
  }, t2.prototype.subtract = function(t3) {
    if (!this.field.equals(t3.field))
      throw new T("ModulusPolys do not have same ModulusGF field");
    return t3.isZero() ? this : this.add(t3.negative());
  }, t2.prototype.multiply = function(e2) {
    return e2 instanceof t2 ? this.multiplyOther(e2) : this.multiplyScalar(e2);
  }, t2.prototype.multiplyOther = function(e2) {
    if (!this.field.equals(e2.field))
      throw new T("ModulusPolys do not have same ModulusGF field");
    if (this.isZero() || e2.isZero())
      return new t2(this.field, new Int32Array([0]));
    for (var r2 = this.coefficients, n2 = r2.length, o2 = e2.coefficients, i2 = o2.length, a2 = new Int32Array(n2 + i2 - 1), s2 = 0; s2 < n2; s2++)
      for (var u2 = r2[s2], c2 = 0; c2 < i2; c2++)
        a2[s2 + c2] = this.field.add(a2[s2 + c2], this.field.multiply(u2, o2[c2]));
    return new t2(this.field, a2);
  }, t2.prototype.negative = function() {
    for (var e2 = this.coefficients.length, r2 = new Int32Array(e2), n2 = 0; n2 < e2; n2++)
      r2[n2] = this.field.subtract(0, this.coefficients[n2]);
    return new t2(this.field, r2);
  }, t2.prototype.multiplyScalar = function(e2) {
    if (0 === e2)
      return new t2(this.field, new Int32Array([0]));
    if (1 === e2)
      return this;
    for (var r2 = this.coefficients.length, n2 = new Int32Array(r2), o2 = 0; o2 < r2; o2++)
      n2[o2] = this.field.multiply(this.coefficients[o2], e2);
    return new t2(this.field, n2);
  }, t2.prototype.multiplyByMonomial = function(e2, r2) {
    if (e2 < 0)
      throw new T();
    if (0 === r2)
      return new t2(this.field, new Int32Array([0]));
    for (var n2 = this.coefficients.length, o2 = new Int32Array(n2 + e2), i2 = 0; i2 < n2; i2++)
      o2[i2] = this.field.multiply(this.coefficients[i2], r2);
    return new t2(this.field, o2);
  }, t2.prototype.toString = function() {
    for (var t3 = new Q(), e2 = this.getDegree(); e2 >= 0; e2--) {
      var r2 = this.getCoefficient(e2);
      0 !== r2 && (r2 < 0 ? (t3.append(" - "), r2 = -r2) : t3.length() > 0 && t3.append(" + "), 0 !== e2 && 1 === r2 || t3.append(r2), 0 !== e2 && (1 === e2 ? t3.append("x") : (t3.append("x^"), t3.append(e2))));
    }
    return t3.toString();
  }, t2;
}();
var Pn = function() {
  function t2() {
  }
  return t2.prototype.add = function(t3, e2) {
    return (t3 + e2) % this.modulus;
  }, t2.prototype.subtract = function(t3, e2) {
    return (this.modulus + t3 - e2) % this.modulus;
  }, t2.prototype.exp = function(t3) {
    return this.expTable[t3];
  }, t2.prototype.log = function(t3) {
    if (0 === t3)
      throw new T();
    return this.logTable[t3];
  }, t2.prototype.inverse = function(t3) {
    if (0 === t3)
      throw new It();
    return this.expTable[this.modulus - this.logTable[t3] - 1];
  }, t2.prototype.multiply = function(t3, e2) {
    return 0 === t3 || 0 === e2 ? 0 : this.expTable[(this.logTable[t3] + this.logTable[e2]) % (this.modulus - 1)];
  }, t2.prototype.getSize = function() {
    return this.modulus;
  }, t2.prototype.equals = function(t3) {
    return t3 === this;
  }, t2;
}();
var Bn = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Ln = function(t2) {
  function e2(e3, r2) {
    var n2 = t2.call(this) || this;
    n2.modulus = e3, n2.expTable = new Int32Array(e3), n2.logTable = new Int32Array(e3);
    for (var o2 = 1, i2 = 0; i2 < e3; i2++)
      n2.expTable[i2] = o2, o2 = o2 * r2 % e3;
    for (i2 = 0; i2 < e3 - 1; i2++)
      n2.logTable[n2.expTable[i2]] = i2;
    return n2.zero = new Mn(n2, new Int32Array([0])), n2.one = new Mn(n2, new Int32Array([1])), n2;
  }
  return Bn(e2, t2), e2.prototype.getZero = function() {
    return this.zero;
  }, e2.prototype.getOne = function() {
    return this.one;
  }, e2.prototype.buildMonomial = function(t3, e3) {
    if (t3 < 0)
      throw new T();
    if (0 === e3)
      return this.zero;
    var r2 = new Int32Array(t3 + 1);
    return r2[0] = e3, new Mn(this, r2);
  }, e2.PDF417_GF = new e2(On.NUMBER_OF_CODEWORDS, 3), e2;
}(Pn);
var Fn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var kn = function() {
  function t2() {
    this.field = Ln.PDF417_GF;
  }
  return t2.prototype.decode = function(t3, e2, r2) {
    for (var n2, o2, i2 = new Mn(this.field, t3), a2 = new Int32Array(e2), s2 = false, u2 = e2; u2 > 0; u2--) {
      var c2 = i2.evaluateAt(this.field.exp(u2));
      a2[e2 - u2] = c2, 0 !== c2 && (s2 = true);
    }
    if (!s2)
      return 0;
    var f3 = this.field.getOne();
    if (null != r2)
      try {
        for (var h2 = Fn(r2), l2 = h2.next(); !l2.done; l2 = h2.next()) {
          var d2 = l2.value, p2 = this.field.exp(t3.length - 1 - d2), g2 = new Mn(this.field, new Int32Array([this.field.subtract(0, p2), 1]));
          f3 = f3.multiply(g2);
        }
      } catch (t4) {
        n2 = { error: t4 };
      } finally {
        try {
          l2 && !l2.done && (o2 = h2.return) && o2.call(h2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
    var y2 = new Mn(this.field, a2), w2 = this.runEuclideanAlgorithm(this.field.buildMonomial(e2, 1), y2, e2), v2 = w2[0], _2 = w2[1], A2 = this.findErrorLocations(v2), C2 = this.findErrorMagnitudes(_2, v2, A2);
    for (u2 = 0; u2 < A2.length; u2++) {
      var m2 = t3.length - 1 - this.field.log(A2[u2]);
      if (m2 < 0)
        throw R.getChecksumInstance();
      t3[m2] = this.field.subtract(t3[m2], C2[u2]);
    }
    return A2.length;
  }, t2.prototype.runEuclideanAlgorithm = function(t3, e2, r2) {
    if (t3.getDegree() < e2.getDegree()) {
      var n2 = t3;
      t3 = e2, e2 = n2;
    }
    for (var o2 = t3, i2 = e2, a2 = this.field.getZero(), s2 = this.field.getOne(); i2.getDegree() >= Math.round(r2 / 2); ) {
      var u2 = o2, c2 = a2;
      if (a2 = s2, (o2 = i2).isZero())
        throw R.getChecksumInstance();
      i2 = u2;
      for (var f3 = this.field.getZero(), h2 = o2.getCoefficient(o2.getDegree()), l2 = this.field.inverse(h2); i2.getDegree() >= o2.getDegree() && !i2.isZero(); ) {
        var d2 = i2.getDegree() - o2.getDegree(), p2 = this.field.multiply(i2.getCoefficient(i2.getDegree()), l2);
        f3 = f3.add(this.field.buildMonomial(d2, p2)), i2 = i2.subtract(o2.multiplyByMonomial(d2, p2));
      }
      s2 = f3.multiply(a2).subtract(c2).negative();
    }
    var g2 = s2.getCoefficient(0);
    if (0 === g2)
      throw R.getChecksumInstance();
    var y2 = this.field.inverse(g2);
    return [s2.multiply(y2), i2.multiply(y2)];
  }, t2.prototype.findErrorLocations = function(t3) {
    for (var e2 = t3.getDegree(), r2 = new Int32Array(e2), n2 = 0, o2 = 1; o2 < this.field.getSize() && n2 < e2; o2++)
      0 === t3.evaluateAt(o2) && (r2[n2] = this.field.inverse(o2), n2++);
    if (n2 !== e2)
      throw R.getChecksumInstance();
    return r2;
  }, t2.prototype.findErrorMagnitudes = function(t3, e2, r2) {
    for (var n2 = e2.getDegree(), o2 = new Int32Array(n2), i2 = 1; i2 <= n2; i2++)
      o2[n2 - i2] = this.field.multiply(i2, e2.getCoefficient(i2));
    var a2 = new Mn(this.field, o2), s2 = r2.length, u2 = new Int32Array(s2);
    for (i2 = 0; i2 < s2; i2++) {
      var c2 = this.field.inverse(r2[i2]), f3 = this.field.subtract(0, t3.evaluateAt(c2)), h2 = this.field.inverse(a2.evaluateAt(c2));
      u2[i2] = this.field.multiply(f3, h2);
    }
    return u2;
  }, t2;
}();
var xn = function() {
  function t2(e2, r2, n2, o2, i2) {
    e2 instanceof t2 ? this.constructor_2(e2) : this.constructor_1(e2, r2, n2, o2, i2);
  }
  return t2.prototype.constructor_1 = function(t3, e2, r2, n2, o2) {
    var i2 = null == e2 || null == r2, a2 = null == n2 || null == o2;
    if (i2 && a2)
      throw new tt();
    i2 ? (e2 = new Lt(0, n2.getY()), r2 = new Lt(0, o2.getY())) : a2 && (n2 = new Lt(t3.getWidth() - 1, e2.getY()), o2 = new Lt(t3.getWidth() - 1, r2.getY())), this.image = t3, this.topLeft = e2, this.bottomLeft = r2, this.topRight = n2, this.bottomRight = o2, this.minX = Math.trunc(Math.min(e2.getX(), r2.getX())), this.maxX = Math.trunc(Math.max(n2.getX(), o2.getX())), this.minY = Math.trunc(Math.min(e2.getY(), n2.getY())), this.maxY = Math.trunc(Math.max(r2.getY(), o2.getY()));
  }, t2.prototype.constructor_2 = function(t3) {
    this.image = t3.image, this.topLeft = t3.getTopLeft(), this.bottomLeft = t3.getBottomLeft(), this.topRight = t3.getTopRight(), this.bottomRight = t3.getBottomRight(), this.minX = t3.getMinX(), this.maxX = t3.getMaxX(), this.minY = t3.getMinY(), this.maxY = t3.getMaxY();
  }, t2.merge = function(e2, r2) {
    return null == e2 ? r2 : null == r2 ? e2 : new t2(e2.image, e2.topLeft, e2.bottomLeft, r2.topRight, r2.bottomRight);
  }, t2.prototype.addMissingRows = function(e2, r2, n2) {
    var o2 = this.topLeft, i2 = this.bottomLeft, a2 = this.topRight, s2 = this.bottomRight;
    if (e2 > 0) {
      var u2 = n2 ? this.topLeft : this.topRight, c2 = Math.trunc(u2.getY() - e2);
      c2 < 0 && (c2 = 0);
      var f3 = new Lt(u2.getX(), c2);
      n2 ? o2 = f3 : a2 = f3;
    }
    if (r2 > 0) {
      var h2 = n2 ? this.bottomLeft : this.bottomRight, l2 = Math.trunc(h2.getY() + r2);
      l2 >= this.image.getHeight() && (l2 = this.image.getHeight() - 1);
      var d2 = new Lt(h2.getX(), l2);
      n2 ? i2 = d2 : s2 = d2;
    }
    return new t2(this.image, o2, i2, a2, s2);
  }, t2.prototype.getMinX = function() {
    return this.minX;
  }, t2.prototype.getMaxX = function() {
    return this.maxX;
  }, t2.prototype.getMinY = function() {
    return this.minY;
  }, t2.prototype.getMaxY = function() {
    return this.maxY;
  }, t2.prototype.getTopLeft = function() {
    return this.topLeft;
  }, t2.prototype.getTopRight = function() {
    return this.topRight;
  }, t2.prototype.getBottomLeft = function() {
    return this.bottomLeft;
  }, t2.prototype.getBottomRight = function() {
    return this.bottomRight;
  }, t2;
}();
var Vn = function() {
  function t2(t3, e2, r2, n2) {
    this.columnCount = t3, this.errorCorrectionLevel = n2, this.rowCountUpperPart = e2, this.rowCountLowerPart = r2, this.rowCount = e2 + r2;
  }
  return t2.prototype.getColumnCount = function() {
    return this.columnCount;
  }, t2.prototype.getErrorCorrectionLevel = function() {
    return this.errorCorrectionLevel;
  }, t2.prototype.getRowCount = function() {
    return this.rowCount;
  }, t2.prototype.getRowCountUpperPart = function() {
    return this.rowCountUpperPart;
  }, t2.prototype.getRowCountLowerPart = function() {
    return this.rowCountLowerPart;
  }, t2;
}();
var Hn = function() {
  function t2() {
    this.buffer = "";
  }
  return t2.form = function(t3, e2) {
    var r2 = -1;
    return t3.replace(/%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g, function(t4, n2, o2, i2, a2, s2) {
      if ("%%" === t4)
        return "%";
      if (void 0 !== e2[++r2]) {
        t4 = i2 ? parseInt(i2.substr(1)) : void 0;
        var u2, c2 = a2 ? parseInt(a2.substr(1)) : void 0;
        switch (s2) {
          case "s":
            u2 = e2[r2];
            break;
          case "c":
            u2 = e2[r2][0];
            break;
          case "f":
            u2 = parseFloat(e2[r2]).toFixed(t4);
            break;
          case "p":
            u2 = parseFloat(e2[r2]).toPrecision(t4);
            break;
          case "e":
            u2 = parseFloat(e2[r2]).toExponential(t4);
            break;
          case "x":
            u2 = parseInt(e2[r2]).toString(c2 || 16);
            break;
          case "d":
            u2 = parseFloat(parseInt(e2[r2], c2 || 10).toPrecision(t4)).toFixed(0);
        }
        u2 = "object" == typeof u2 ? JSON.stringify(u2) : (+u2).toString(c2);
        for (var f3 = parseInt(o2), h2 = o2 && o2[0] + "" == "0" ? "0" : " "; u2.length < f3; )
          u2 = void 0 !== n2 ? u2 + h2 : h2 + u2;
        return u2;
      }
    });
  }, t2.prototype.format = function(e2) {
    for (var r2 = [], n2 = 1; n2 < arguments.length; n2++)
      r2[n2 - 1] = arguments[n2];
    this.buffer += t2.form(e2, r2);
  }, t2.prototype.toString = function() {
    return this.buffer;
  }, t2;
}();
var Un = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Xn = function() {
  function t2(t3) {
    this.boundingBox = new xn(t3), this.codewords = new Array(t3.getMaxY() - t3.getMinY() + 1);
  }
  return t2.prototype.getCodewordNearby = function(e2) {
    var r2 = this.getCodeword(e2);
    if (null != r2)
      return r2;
    for (var n2 = 1; n2 < t2.MAX_NEARBY_DISTANCE; n2++) {
      var o2 = this.imageRowToCodewordIndex(e2) - n2;
      if (o2 >= 0 && null != (r2 = this.codewords[o2]))
        return r2;
      if ((o2 = this.imageRowToCodewordIndex(e2) + n2) < this.codewords.length && null != (r2 = this.codewords[o2]))
        return r2;
    }
    return null;
  }, t2.prototype.imageRowToCodewordIndex = function(t3) {
    return t3 - this.boundingBox.getMinY();
  }, t2.prototype.setCodeword = function(t3, e2) {
    this.codewords[this.imageRowToCodewordIndex(t3)] = e2;
  }, t2.prototype.getCodeword = function(t3) {
    return this.codewords[this.imageRowToCodewordIndex(t3)];
  }, t2.prototype.getBoundingBox = function() {
    return this.boundingBox;
  }, t2.prototype.getCodewords = function() {
    return this.codewords;
  }, t2.prototype.toString = function() {
    var t3, e2, r2 = new Hn(), n2 = 0;
    try {
      for (var o2 = Un(this.codewords), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        var a2 = i2.value;
        null != a2 ? r2.format("%3d: %3d|%3d%n", n2++, a2.getRowNumber(), a2.getValue()) : r2.format("%3d:    |   %n", n2++);
      }
    } catch (e3) {
      t3 = { error: e3 };
    } finally {
      try {
        i2 && !i2.done && (e2 = o2.return) && e2.call(o2);
      } finally {
        if (t3)
          throw t3.error;
      }
    }
    return r2.toString();
  }, t2.MAX_NEARBY_DISTANCE = 5, t2;
}();
var Gn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Wn = function(t2, e2) {
  var r2 = "function" == typeof Symbol && t2[Symbol.iterator];
  if (!r2)
    return t2;
  var n2, o2, i2 = r2.call(t2), a2 = [];
  try {
    for (; (void 0 === e2 || e2-- > 0) && !(n2 = i2.next()).done; )
      a2.push(n2.value);
  } catch (t3) {
    o2 = { error: t3 };
  } finally {
    try {
      n2 && !n2.done && (r2 = i2.return) && r2.call(i2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
  return a2;
};
var zn = function() {
  function t2() {
    this.values = /* @__PURE__ */ new Map();
  }
  return t2.prototype.setValue = function(t3) {
    t3 = Math.trunc(t3);
    var e2 = this.values.get(t3);
    null == e2 && (e2 = 0), e2++, this.values.set(t3, e2);
  }, t2.prototype.getValue = function() {
    var t3, e2, r2 = -1, n2 = new Array(), o2 = function(t4, e3) {
      var o3 = function() {
        return t4;
      }, i3 = function() {
        return e3;
      };
      i3() > r2 ? (r2 = i3(), (n2 = []).push(o3())) : i3() === r2 && n2.push(o3());
    };
    try {
      for (var i2 = Gn(this.values.entries()), a2 = i2.next(); !a2.done; a2 = i2.next()) {
        var s2 = Wn(a2.value, 2);
        o2(s2[0], s2[1]);
      }
    } catch (e3) {
      t3 = { error: e3 };
    } finally {
      try {
        a2 && !a2.done && (e2 = i2.return) && e2.call(i2);
      } finally {
        if (t3)
          throw t3.error;
      }
    }
    return On.toIntArray(n2);
  }, t2.prototype.getConfidence = function(t3) {
    return this.values.get(t3);
  }, t2;
}();
var jn = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Yn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Zn = function(t2) {
  function e2(e3, r2) {
    var n2 = t2.call(this, e3) || this;
    return n2._isLeft = r2, n2;
  }
  return jn(e2, t2), e2.prototype.setRowNumbers = function() {
    var t3, e3;
    try {
      for (var r2 = Yn(this.getCodewords()), n2 = r2.next(); !n2.done; n2 = r2.next()) {
        var o2 = n2.value;
        null != o2 && o2.setRowNumberAsRowIndicatorColumn();
      }
    } catch (e4) {
      t3 = { error: e4 };
    } finally {
      try {
        n2 && !n2.done && (e3 = r2.return) && e3.call(r2);
      } finally {
        if (t3)
          throw t3.error;
      }
    }
  }, e2.prototype.adjustCompleteIndicatorColumnRowNumbers = function(t3) {
    var e3 = this.getCodewords();
    this.setRowNumbers(), this.removeIncorrectCodewords(e3, t3);
    for (var r2 = this.getBoundingBox(), n2 = this._isLeft ? r2.getTopLeft() : r2.getTopRight(), o2 = this._isLeft ? r2.getBottomLeft() : r2.getBottomRight(), i2 = this.imageRowToCodewordIndex(Math.trunc(n2.getY())), a2 = this.imageRowToCodewordIndex(Math.trunc(o2.getY())), s2 = -1, u2 = 1, c2 = 0, f3 = i2; f3 < a2; f3++)
      if (null != e3[f3]) {
        var h2 = e3[f3], l2 = h2.getRowNumber() - s2;
        if (0 === l2)
          c2++;
        else if (1 === l2)
          u2 = Math.max(u2, c2), c2 = 1, s2 = h2.getRowNumber();
        else if (l2 < 0 || h2.getRowNumber() >= t3.getRowCount() || l2 > f3)
          e3[f3] = null;
        else {
          for (var d2 = void 0, p2 = (d2 = u2 > 2 ? (u2 - 2) * l2 : l2) >= f3, g2 = 1; g2 <= d2 && !p2; g2++)
            p2 = null != e3[f3 - g2];
          p2 ? e3[f3] = null : (s2 = h2.getRowNumber(), c2 = 1);
        }
      }
  }, e2.prototype.getRowHeights = function() {
    var t3, e3, r2 = this.getBarcodeMetadata();
    if (null == r2)
      return null;
    this.adjustIncompleteIndicatorColumnRowNumbers(r2);
    var n2 = new Int32Array(r2.getRowCount());
    try {
      for (var o2 = Yn(this.getCodewords()), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        var a2 = i2.value;
        if (null != a2) {
          var s2 = a2.getRowNumber();
          if (s2 >= n2.length)
            continue;
          n2[s2]++;
        }
      }
    } catch (e4) {
      t3 = { error: e4 };
    } finally {
      try {
        i2 && !i2.done && (e3 = o2.return) && e3.call(o2);
      } finally {
        if (t3)
          throw t3.error;
      }
    }
    return n2;
  }, e2.prototype.adjustIncompleteIndicatorColumnRowNumbers = function(t3) {
    for (var e3 = this.getBoundingBox(), r2 = this._isLeft ? e3.getTopLeft() : e3.getTopRight(), n2 = this._isLeft ? e3.getBottomLeft() : e3.getBottomRight(), o2 = this.imageRowToCodewordIndex(Math.trunc(r2.getY())), i2 = this.imageRowToCodewordIndex(Math.trunc(n2.getY())), a2 = this.getCodewords(), s2 = -1, u2 = o2; u2 < i2; u2++)
      if (null != a2[u2]) {
        var c2 = a2[u2];
        c2.setRowNumberAsRowIndicatorColumn();
        var f3 = c2.getRowNumber() - s2;
        0 === f3 || (1 === f3 ? s2 = c2.getRowNumber() : c2.getRowNumber() >= t3.getRowCount() ? a2[u2] = null : s2 = c2.getRowNumber());
      }
  }, e2.prototype.getBarcodeMetadata = function() {
    var t3, e3, r2 = this.getCodewords(), n2 = new zn(), o2 = new zn(), i2 = new zn(), a2 = new zn();
    try {
      for (var s2 = Yn(r2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
        var c2 = u2.value;
        if (null != c2) {
          c2.setRowNumberAsRowIndicatorColumn();
          var f3 = c2.getValue() % 30, h2 = c2.getRowNumber();
          switch (this._isLeft || (h2 += 2), h2 % 3) {
            case 0:
              o2.setValue(3 * f3 + 1);
              break;
            case 1:
              a2.setValue(f3 / 3), i2.setValue(f3 % 3);
              break;
            case 2:
              n2.setValue(f3 + 1);
          }
        }
      }
    } catch (e4) {
      t3 = { error: e4 };
    } finally {
      try {
        u2 && !u2.done && (e3 = s2.return) && e3.call(s2);
      } finally {
        if (t3)
          throw t3.error;
      }
    }
    if (0 === n2.getValue().length || 0 === o2.getValue().length || 0 === i2.getValue().length || 0 === a2.getValue().length || n2.getValue()[0] < 1 || o2.getValue()[0] + i2.getValue()[0] < On.MIN_ROWS_IN_BARCODE || o2.getValue()[0] + i2.getValue()[0] > On.MAX_ROWS_IN_BARCODE)
      return null;
    var l2 = new Vn(n2.getValue()[0], o2.getValue()[0], i2.getValue()[0], a2.getValue()[0]);
    return this.removeIncorrectCodewords(r2, l2), l2;
  }, e2.prototype.removeIncorrectCodewords = function(t3, e3) {
    for (var r2 = 0; r2 < t3.length; r2++) {
      var n2 = t3[r2];
      if (null != t3[r2]) {
        var o2 = n2.getValue() % 30, i2 = n2.getRowNumber();
        if (i2 > e3.getRowCount())
          t3[r2] = null;
        else
          switch (this._isLeft || (i2 += 2), i2 % 3) {
            case 0:
              3 * o2 + 1 !== e3.getRowCountUpperPart() && (t3[r2] = null);
              break;
            case 1:
              Math.trunc(o2 / 3) === e3.getErrorCorrectionLevel() && o2 % 3 === e3.getRowCountLowerPart() || (t3[r2] = null);
              break;
            case 2:
              o2 + 1 !== e3.getColumnCount() && (t3[r2] = null);
          }
      }
    }
  }, e2.prototype.isLeft = function() {
    return this._isLeft;
  }, e2.prototype.toString = function() {
    return "IsLeft: " + this._isLeft + "\n" + t2.prototype.toString.call(this);
  }, e2;
}(Xn);
var Kn = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var qn = function() {
  function t2(t3, e2) {
    this.ADJUST_ROW_NUMBER_SKIP = 2, this.barcodeMetadata = t3, this.barcodeColumnCount = t3.getColumnCount(), this.boundingBox = e2, this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
  }
  return t2.prototype.getDetectionResultColumns = function() {
    this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]), this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
    var t3, e2 = On.MAX_CODEWORDS_IN_BARCODE;
    do {
      t3 = e2, e2 = this.adjustRowNumbersAndGetCount();
    } while (e2 > 0 && e2 < t3);
    return this.detectionResultColumns;
  }, t2.prototype.adjustIndicatorColumnRowNumbers = function(t3) {
    null != t3 && t3.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
  }, t2.prototype.adjustRowNumbersAndGetCount = function() {
    var t3 = this.adjustRowNumbersByRow();
    if (0 === t3)
      return 0;
    for (var e2 = 1; e2 < this.barcodeColumnCount + 1; e2++)
      for (var r2 = this.detectionResultColumns[e2].getCodewords(), n2 = 0; n2 < r2.length; n2++)
        null != r2[n2] && (r2[n2].hasValidRowNumber() || this.adjustRowNumbers(e2, n2, r2));
    return t3;
  }, t2.prototype.adjustRowNumbersByRow = function() {
    return this.adjustRowNumbersFromBothRI(), this.adjustRowNumbersFromLRI() + this.adjustRowNumbersFromRRI();
  }, t2.prototype.adjustRowNumbersFromBothRI = function() {
    if (null != this.detectionResultColumns[0] && null != this.detectionResultColumns[this.barcodeColumnCount + 1]) {
      for (var t3 = this.detectionResultColumns[0].getCodewords(), e2 = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords(), r2 = 0; r2 < t3.length; r2++)
        if (null != t3[r2] && null != e2[r2] && t3[r2].getRowNumber() === e2[r2].getRowNumber())
          for (var n2 = 1; n2 <= this.barcodeColumnCount; n2++) {
            var o2 = this.detectionResultColumns[n2].getCodewords()[r2];
            null != o2 && (o2.setRowNumber(t3[r2].getRowNumber()), o2.hasValidRowNumber() || (this.detectionResultColumns[n2].getCodewords()[r2] = null));
          }
    }
  }, t2.prototype.adjustRowNumbersFromRRI = function() {
    if (null == this.detectionResultColumns[this.barcodeColumnCount + 1])
      return 0;
    for (var e2 = 0, r2 = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords(), n2 = 0; n2 < r2.length; n2++)
      if (null != r2[n2])
        for (var o2 = r2[n2].getRowNumber(), i2 = 0, a2 = this.barcodeColumnCount + 1; a2 > 0 && i2 < this.ADJUST_ROW_NUMBER_SKIP; a2--) {
          var s2 = this.detectionResultColumns[a2].getCodewords()[n2];
          null != s2 && (i2 = t2.adjustRowNumberIfValid(o2, i2, s2), s2.hasValidRowNumber() || e2++);
        }
    return e2;
  }, t2.prototype.adjustRowNumbersFromLRI = function() {
    if (null == this.detectionResultColumns[0])
      return 0;
    for (var e2 = 0, r2 = this.detectionResultColumns[0].getCodewords(), n2 = 0; n2 < r2.length; n2++)
      if (null != r2[n2])
        for (var o2 = r2[n2].getRowNumber(), i2 = 0, a2 = 1; a2 < this.barcodeColumnCount + 1 && i2 < this.ADJUST_ROW_NUMBER_SKIP; a2++) {
          var s2 = this.detectionResultColumns[a2].getCodewords()[n2];
          null != s2 && (i2 = t2.adjustRowNumberIfValid(o2, i2, s2), s2.hasValidRowNumber() || e2++);
        }
    return e2;
  }, t2.adjustRowNumberIfValid = function(t3, e2, r2) {
    return null == r2 || r2.hasValidRowNumber() || (r2.isValidRowNumber(t3) ? (r2.setRowNumber(t3), e2 = 0) : ++e2), e2;
  }, t2.prototype.adjustRowNumbers = function(e2, r2, n2) {
    var o2, i2;
    if (null != this.detectionResultColumns[e2 - 1]) {
      var a2 = n2[r2], s2 = this.detectionResultColumns[e2 - 1].getCodewords(), u2 = s2;
      null != this.detectionResultColumns[e2 + 1] && (u2 = this.detectionResultColumns[e2 + 1].getCodewords());
      var c2 = new Array(14);
      c2[2] = s2[r2], c2[3] = u2[r2], r2 > 0 && (c2[0] = n2[r2 - 1], c2[4] = s2[r2 - 1], c2[5] = u2[r2 - 1]), r2 > 1 && (c2[8] = n2[r2 - 2], c2[10] = s2[r2 - 2], c2[11] = u2[r2 - 2]), r2 < n2.length - 1 && (c2[1] = n2[r2 + 1], c2[6] = s2[r2 + 1], c2[7] = u2[r2 + 1]), r2 < n2.length - 2 && (c2[9] = n2[r2 + 2], c2[12] = s2[r2 + 2], c2[13] = u2[r2 + 2]);
      try {
        for (var f3 = Kn(c2), h2 = f3.next(); !h2.done; h2 = f3.next()) {
          var l2 = h2.value;
          if (t2.adjustRowNumber(a2, l2))
            return;
        }
      } catch (t3) {
        o2 = { error: t3 };
      } finally {
        try {
          h2 && !h2.done && (i2 = f3.return) && i2.call(f3);
        } finally {
          if (o2)
            throw o2.error;
        }
      }
    }
  }, t2.adjustRowNumber = function(t3, e2) {
    return null != e2 && (!(!e2.hasValidRowNumber() || e2.getBucket() !== t3.getBucket()) && (t3.setRowNumber(e2.getRowNumber()), true));
  }, t2.prototype.getBarcodeColumnCount = function() {
    return this.barcodeColumnCount;
  }, t2.prototype.getBarcodeRowCount = function() {
    return this.barcodeMetadata.getRowCount();
  }, t2.prototype.getBarcodeECLevel = function() {
    return this.barcodeMetadata.getErrorCorrectionLevel();
  }, t2.prototype.setBoundingBox = function(t3) {
    this.boundingBox = t3;
  }, t2.prototype.getBoundingBox = function() {
    return this.boundingBox;
  }, t2.prototype.setDetectionResultColumn = function(t3, e2) {
    this.detectionResultColumns[t3] = e2;
  }, t2.prototype.getDetectionResultColumn = function(t3) {
    return this.detectionResultColumns[t3];
  }, t2.prototype.toString = function() {
    var t3 = this.detectionResultColumns[0];
    null == t3 && (t3 = this.detectionResultColumns[this.barcodeColumnCount + 1]);
    for (var e2 = new Hn(), r2 = 0; r2 < t3.getCodewords().length; r2++) {
      e2.format("CW %3d:", r2);
      for (var n2 = 0; n2 < this.barcodeColumnCount + 2; n2++)
        if (null != this.detectionResultColumns[n2]) {
          var o2 = this.detectionResultColumns[n2].getCodewords()[r2];
          null != o2 ? e2.format(" %3d|%3d", o2.getRowNumber(), o2.getValue()) : e2.format("    |   ");
        } else
          e2.format("    |   ");
      e2.format("%n");
    }
    return e2.toString();
  }, t2;
}();
var Qn = function() {
  function t2(e2, r2, n2, o2) {
    this.rowNumber = t2.BARCODE_ROW_UNKNOWN, this.startX = Math.trunc(e2), this.endX = Math.trunc(r2), this.bucket = Math.trunc(n2), this.value = Math.trunc(o2);
  }
  return t2.prototype.hasValidRowNumber = function() {
    return this.isValidRowNumber(this.rowNumber);
  }, t2.prototype.isValidRowNumber = function(e2) {
    return e2 !== t2.BARCODE_ROW_UNKNOWN && this.bucket === e2 % 3 * 3;
  }, t2.prototype.setRowNumberAsRowIndicatorColumn = function() {
    this.rowNumber = Math.trunc(3 * Math.trunc(this.value / 30) + Math.trunc(this.bucket / 3));
  }, t2.prototype.getWidth = function() {
    return this.endX - this.startX;
  }, t2.prototype.getStartX = function() {
    return this.startX;
  }, t2.prototype.getEndX = function() {
    return this.endX;
  }, t2.prototype.getBucket = function() {
    return this.bucket;
  }, t2.prototype.getValue = function() {
    return this.value;
  }, t2.prototype.getRowNumber = function() {
    return this.rowNumber;
  }, t2.prototype.setRowNumber = function(t3) {
    this.rowNumber = t3;
  }, t2.prototype.toString = function() {
    return this.rowNumber + "|" + this.value;
  }, t2.BARCODE_ROW_UNKNOWN = -1, t2;
}();
var Jn = function() {
  function t2() {
  }
  return t2.initialize = function() {
    for (var e2 = 0; e2 < On.SYMBOL_TABLE.length; e2++)
      for (var r2 = On.SYMBOL_TABLE[e2], n2 = 1 & r2, o2 = 0; o2 < On.BARS_IN_MODULE; o2++) {
        for (var i2 = 0; (1 & r2) === n2; )
          i2 += 1, r2 >>= 1;
        n2 = 1 & r2, t2.RATIOS_TABLE[e2] || (t2.RATIOS_TABLE[e2] = new Array(On.BARS_IN_MODULE)), t2.RATIOS_TABLE[e2][On.BARS_IN_MODULE - o2 - 1] = Math.fround(i2 / On.MODULES_IN_CODEWORD);
      }
    this.bSymbolTableReady = true;
  }, t2.getDecodedValue = function(e2) {
    var r2 = t2.getDecodedCodewordValue(t2.sampleBitCounts(e2));
    return -1 !== r2 ? r2 : t2.getClosestDecodedValue(e2);
  }, t2.sampleBitCounts = function(t3) {
    for (var e2 = Pt.sum(t3), r2 = new Int32Array(On.BARS_IN_MODULE), n2 = 0, o2 = 0, i2 = 0; i2 < On.MODULES_IN_CODEWORD; i2++) {
      var a2 = e2 / (2 * On.MODULES_IN_CODEWORD) + i2 * e2 / On.MODULES_IN_CODEWORD;
      o2 + t3[n2] <= a2 && (o2 += t3[n2], n2++), r2[n2]++;
    }
    return r2;
  }, t2.getDecodedCodewordValue = function(e2) {
    var r2 = t2.getBitValue(e2);
    return -1 === On.getCodeword(r2) ? -1 : r2;
  }, t2.getBitValue = function(t3) {
    for (var e2 = 0, r2 = 0; r2 < t3.length; r2++)
      for (var n2 = 0; n2 < t3[r2]; n2++)
        e2 = e2 << 1 | (r2 % 2 == 0 ? 1 : 0);
    return Math.trunc(e2);
  }, t2.getClosestDecodedValue = function(e2) {
    var r2 = Pt.sum(e2), n2 = new Array(On.BARS_IN_MODULE);
    if (r2 > 1)
      for (var o2 = 0; o2 < n2.length; o2++)
        n2[o2] = Math.fround(e2[o2] / r2);
    var i2 = Bt.MAX_VALUE, a2 = -1;
    this.bSymbolTableReady || t2.initialize();
    for (var s2 = 0; s2 < t2.RATIOS_TABLE.length; s2++) {
      for (var u2 = 0, c2 = t2.RATIOS_TABLE[s2], f3 = 0; f3 < On.BARS_IN_MODULE; f3++) {
        var h2 = Math.fround(c2[f3] - n2[f3]);
        if ((u2 += Math.fround(h2 * h2)) >= i2)
          break;
      }
      u2 < i2 && (i2 = u2, a2 = On.SYMBOL_TABLE[s2]);
    }
    return a2;
  }, t2.bSymbolTableReady = false, t2.RATIOS_TABLE = new Array(On.SYMBOL_TABLE.length).map(function(t3) {
    return new Array(On.BARS_IN_MODULE);
  }), t2;
}();
var $n = function() {
  function t2() {
    this.segmentCount = -1, this.fileSize = -1, this.timestamp = -1, this.checksum = -1;
  }
  return t2.prototype.getSegmentIndex = function() {
    return this.segmentIndex;
  }, t2.prototype.setSegmentIndex = function(t3) {
    this.segmentIndex = t3;
  }, t2.prototype.getFileId = function() {
    return this.fileId;
  }, t2.prototype.setFileId = function(t3) {
    this.fileId = t3;
  }, t2.prototype.getOptionalData = function() {
    return this.optionalData;
  }, t2.prototype.setOptionalData = function(t3) {
    this.optionalData = t3;
  }, t2.prototype.isLastSegment = function() {
    return this.lastSegment;
  }, t2.prototype.setLastSegment = function(t3) {
    this.lastSegment = t3;
  }, t2.prototype.getSegmentCount = function() {
    return this.segmentCount;
  }, t2.prototype.setSegmentCount = function(t3) {
    this.segmentCount = t3;
  }, t2.prototype.getSender = function() {
    return this.sender || null;
  }, t2.prototype.setSender = function(t3) {
    this.sender = t3;
  }, t2.prototype.getAddressee = function() {
    return this.addressee || null;
  }, t2.prototype.setAddressee = function(t3) {
    this.addressee = t3;
  }, t2.prototype.getFileName = function() {
    return this.fileName;
  }, t2.prototype.setFileName = function(t3) {
    this.fileName = t3;
  }, t2.prototype.getFileSize = function() {
    return this.fileSize;
  }, t2.prototype.setFileSize = function(t3) {
    this.fileSize = t3;
  }, t2.prototype.getChecksum = function() {
    return this.checksum;
  }, t2.prototype.setChecksum = function(t3) {
    this.checksum = t3;
  }, t2.prototype.getTimestamp = function() {
    return this.timestamp;
  }, t2.prototype.setTimestamp = function(t3) {
    this.timestamp = t3;
  }, t2;
}();
var to = function() {
  function t2() {
  }
  return t2.parseLong = function(t3, e2) {
    return void 0 === e2 && (e2 = void 0), parseInt(t3, e2);
  }, t2;
}();
var eo = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ro = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return eo(e2, t2), e2.kind = "NullPointerException", e2;
}(m);
var no = function() {
  function t2() {
  }
  return t2.prototype.writeBytes = function(t3) {
    this.writeBytesOffset(t3, 0, t3.length);
  }, t2.prototype.writeBytesOffset = function(t3, e2, r2) {
    if (null == t3)
      throw new ro();
    if (e2 < 0 || e2 > t3.length || r2 < 0 || e2 + r2 > t3.length || e2 + r2 < 0)
      throw new P();
    if (0 !== r2)
      for (var n2 = 0; n2 < r2; n2++)
        this.write(t3[e2 + n2]);
  }, t2.prototype.flush = function() {
  }, t2.prototype.close = function() {
  }, t2;
}();
var oo = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var io = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return oo(e2, t2), e2;
}(m);
var ao = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var so = function(t2) {
  function e2(e3) {
    void 0 === e3 && (e3 = 32);
    var r2 = t2.call(this) || this;
    if (r2.count = 0, e3 < 0)
      throw new T("Negative initial size: " + e3);
    return r2.buf = new Uint8Array(e3), r2;
  }
  return ao(e2, t2), e2.prototype.ensureCapacity = function(t3) {
    t3 - this.buf.length > 0 && this.grow(t3);
  }, e2.prototype.grow = function(t3) {
    var e3 = this.buf.length << 1;
    if (e3 - t3 < 0 && (e3 = t3), e3 < 0) {
      if (t3 < 0)
        throw new io();
      e3 = x.MAX_VALUE;
    }
    this.buf = k.copyOfUint8Array(this.buf, e3);
  }, e2.prototype.write = function(t3) {
    this.ensureCapacity(this.count + 1), this.buf[this.count] = t3, this.count += 1;
  }, e2.prototype.writeBytesOffset = function(t3, e3, r2) {
    if (e3 < 0 || e3 > t3.length || r2 < 0 || e3 + r2 - t3.length > 0)
      throw new P();
    this.ensureCapacity(this.count + r2), D.arraycopy(t3, e3, this.buf, this.count, r2), this.count += r2;
  }, e2.prototype.writeTo = function(t3) {
    t3.writeBytesOffset(this.buf, 0, this.count);
  }, e2.prototype.reset = function() {
    this.count = 0;
  }, e2.prototype.toByteArray = function() {
    return k.copyOfUint8Array(this.buf, this.count);
  }, e2.prototype.size = function() {
    return this.count;
  }, e2.prototype.toString = function(t3) {
    return t3 ? "string" == typeof t3 ? this.toString_string(t3) : this.toString_number(t3) : this.toString_void();
  }, e2.prototype.toString_void = function() {
    return new String(this.buf).toString();
  }, e2.prototype.toString_string = function(t3) {
    return new String(this.buf).toString();
  }, e2.prototype.toString_number = function(t3) {
    return new String(this.buf).toString();
  }, e2.prototype.close = function() {
  }, e2;
}(no);
function uo() {
  if ("undefined" != typeof window)
    return window.BigInt || null;
  if ("undefined" != typeof global)
    return global.BigInt || null;
  if ("undefined" != typeof self)
    return self.BigInt || null;
  throw new Error("Can't search globals for BigInt!");
}
function co(t2) {
  if (void 0 === cn && (cn = uo()), null === cn)
    throw new Error("BigInt is not supported!");
  return cn(t2);
}
!function(t2) {
  t2[t2.ALPHA = 0] = "ALPHA", t2[t2.LOWER = 1] = "LOWER", t2[t2.MIXED = 2] = "MIXED", t2[t2.PUNCT = 3] = "PUNCT", t2[t2.ALPHA_SHIFT = 4] = "ALPHA_SHIFT", t2[t2.PUNCT_SHIFT = 5] = "PUNCT_SHIFT";
}(un || (un = {}));
var fo = function() {
  function t2() {
  }
  return t2.decode = function(e2, r2) {
    var n2 = new Q(""), o2 = j.ISO8859_1;
    n2.enableDecoding(o2);
    for (var i2 = 1, a2 = e2[i2++], s2 = new $n(); i2 < e2[0]; ) {
      switch (a2) {
        case t2.TEXT_COMPACTION_MODE_LATCH:
          i2 = t2.textCompaction(e2, i2, n2);
          break;
        case t2.BYTE_COMPACTION_MODE_LATCH:
        case t2.BYTE_COMPACTION_MODE_LATCH_6:
          i2 = t2.byteCompaction(a2, e2, o2, i2, n2);
          break;
        case t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
          n2.append(e2[i2++]);
          break;
        case t2.NUMERIC_COMPACTION_MODE_LATCH:
          i2 = t2.numericCompaction(e2, i2, n2);
          break;
        case t2.ECI_CHARSET:
          j.getCharacterSetECIByValue(e2[i2++]);
          break;
        case t2.ECI_GENERAL_PURPOSE:
          i2 += 2;
          break;
        case t2.ECI_USER_DEFINED:
          i2++;
          break;
        case t2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
          i2 = t2.decodeMacroBlock(e2, i2, s2);
          break;
        case t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
        case t2.MACRO_PDF417_TERMINATOR:
          throw new G();
        default:
          i2--, i2 = t2.textCompaction(e2, i2, n2);
      }
      if (!(i2 < e2.length))
        throw G.getFormatInstance();
      a2 = e2[i2++];
    }
    if (0 === n2.length())
      throw G.getFormatInstance();
    var u2 = new At(null, n2.toString(), null, r2);
    return u2.setOther(s2), u2;
  }, t2.decodeMacroBlock = function(e2, r2, n2) {
    if (r2 + t2.NUMBER_OF_SEQUENCE_CODEWORDS > e2[0])
      throw G.getFormatInstance();
    for (var o2 = new Int32Array(t2.NUMBER_OF_SEQUENCE_CODEWORDS), i2 = 0; i2 < t2.NUMBER_OF_SEQUENCE_CODEWORDS; i2++, r2++)
      o2[i2] = e2[r2];
    n2.setSegmentIndex(x.parseInt(t2.decodeBase900toBase10(o2, t2.NUMBER_OF_SEQUENCE_CODEWORDS)));
    var a2 = new Q();
    r2 = t2.textCompaction(e2, r2, a2), n2.setFileId(a2.toString());
    var s2 = -1;
    for (e2[r2] === t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD && (s2 = r2 + 1); r2 < e2[0]; )
      switch (e2[r2]) {
        case t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
          switch (e2[++r2]) {
            case t2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
              var u2 = new Q();
              r2 = t2.textCompaction(e2, r2 + 1, u2), n2.setFileName(u2.toString());
              break;
            case t2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
              var c2 = new Q();
              r2 = t2.textCompaction(e2, r2 + 1, c2), n2.setSender(c2.toString());
              break;
            case t2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
              var f3 = new Q();
              r2 = t2.textCompaction(e2, r2 + 1, f3), n2.setAddressee(f3.toString());
              break;
            case t2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
              var h2 = new Q();
              r2 = t2.numericCompaction(e2, r2 + 1, h2), n2.setSegmentCount(x.parseInt(h2.toString()));
              break;
            case t2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
              var l2 = new Q();
              r2 = t2.numericCompaction(e2, r2 + 1, l2), n2.setTimestamp(to.parseLong(l2.toString()));
              break;
            case t2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
              var d2 = new Q();
              r2 = t2.numericCompaction(e2, r2 + 1, d2), n2.setChecksum(x.parseInt(d2.toString()));
              break;
            case t2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
              var p2 = new Q();
              r2 = t2.numericCompaction(e2, r2 + 1, p2), n2.setFileSize(to.parseLong(p2.toString()));
              break;
            default:
              throw G.getFormatInstance();
          }
          break;
        case t2.MACRO_PDF417_TERMINATOR:
          r2++, n2.setLastSegment(true);
          break;
        default:
          throw G.getFormatInstance();
      }
    if (-1 !== s2) {
      var g2 = r2 - s2;
      n2.isLastSegment() && g2--, n2.setOptionalData(k.copyOfRange(e2, s2, s2 + g2));
    }
    return r2;
  }, t2.textCompaction = function(e2, r2, n2) {
    for (var o2 = new Int32Array(2 * (e2[0] - r2)), i2 = new Int32Array(2 * (e2[0] - r2)), a2 = 0, s2 = false; r2 < e2[0] && !s2; ) {
      var u2 = e2[r2++];
      if (u2 < t2.TEXT_COMPACTION_MODE_LATCH)
        o2[a2] = u2 / 30, o2[a2 + 1] = u2 % 30, a2 += 2;
      else
        switch (u2) {
          case t2.TEXT_COMPACTION_MODE_LATCH:
            o2[a2++] = t2.TEXT_COMPACTION_MODE_LATCH;
            break;
          case t2.BYTE_COMPACTION_MODE_LATCH:
          case t2.BYTE_COMPACTION_MODE_LATCH_6:
          case t2.NUMERIC_COMPACTION_MODE_LATCH:
          case t2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
          case t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
          case t2.MACRO_PDF417_TERMINATOR:
            r2--, s2 = true;
            break;
          case t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
            o2[a2] = t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE, u2 = e2[r2++], i2[a2] = u2, a2++;
        }
    }
    return t2.decodeTextCompaction(o2, i2, a2, n2), r2;
  }, t2.decodeTextCompaction = function(e2, r2, n2, o2) {
    for (var i2 = un.ALPHA, a2 = un.ALPHA, s2 = 0; s2 < n2; ) {
      var u2 = e2[s2], c2 = "";
      switch (i2) {
        case un.ALPHA:
          if (u2 < 26)
            c2 = String.fromCharCode(65 + u2);
          else
            switch (u2) {
              case 26:
                c2 = " ";
                break;
              case t2.LL:
                i2 = un.LOWER;
                break;
              case t2.ML:
                i2 = un.MIXED;
                break;
              case t2.PS:
                a2 = i2, i2 = un.PUNCT_SHIFT;
                break;
              case t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                o2.append(r2[s2]);
                break;
              case t2.TEXT_COMPACTION_MODE_LATCH:
                i2 = un.ALPHA;
            }
          break;
        case un.LOWER:
          if (u2 < 26)
            c2 = String.fromCharCode(97 + u2);
          else
            switch (u2) {
              case 26:
                c2 = " ";
                break;
              case t2.AS:
                a2 = i2, i2 = un.ALPHA_SHIFT;
                break;
              case t2.ML:
                i2 = un.MIXED;
                break;
              case t2.PS:
                a2 = i2, i2 = un.PUNCT_SHIFT;
                break;
              case t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                o2.append(r2[s2]);
                break;
              case t2.TEXT_COMPACTION_MODE_LATCH:
                i2 = un.ALPHA;
            }
          break;
        case un.MIXED:
          if (u2 < t2.PL)
            c2 = t2.MIXED_CHARS[u2];
          else
            switch (u2) {
              case t2.PL:
                i2 = un.PUNCT;
                break;
              case 26:
                c2 = " ";
                break;
              case t2.LL:
                i2 = un.LOWER;
                break;
              case t2.AL:
                i2 = un.ALPHA;
                break;
              case t2.PS:
                a2 = i2, i2 = un.PUNCT_SHIFT;
                break;
              case t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                o2.append(r2[s2]);
                break;
              case t2.TEXT_COMPACTION_MODE_LATCH:
                i2 = un.ALPHA;
            }
          break;
        case un.PUNCT:
          if (u2 < t2.PAL)
            c2 = t2.PUNCT_CHARS[u2];
          else
            switch (u2) {
              case t2.PAL:
                i2 = un.ALPHA;
                break;
              case t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                o2.append(r2[s2]);
                break;
              case t2.TEXT_COMPACTION_MODE_LATCH:
                i2 = un.ALPHA;
            }
          break;
        case un.ALPHA_SHIFT:
          if (i2 = a2, u2 < 26)
            c2 = String.fromCharCode(65 + u2);
          else
            switch (u2) {
              case 26:
                c2 = " ";
                break;
              case t2.TEXT_COMPACTION_MODE_LATCH:
                i2 = un.ALPHA;
            }
          break;
        case un.PUNCT_SHIFT:
          if (i2 = a2, u2 < t2.PAL)
            c2 = t2.PUNCT_CHARS[u2];
          else
            switch (u2) {
              case t2.PAL:
                i2 = un.ALPHA;
                break;
              case t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                o2.append(r2[s2]);
                break;
              case t2.TEXT_COMPACTION_MODE_LATCH:
                i2 = un.ALPHA;
            }
      }
      "" !== c2 && o2.append(c2), s2++;
    }
  }, t2.byteCompaction = function(e2, r2, n2, o2, i2) {
    var a2 = new so(), s2 = 0, u2 = 0, c2 = false;
    switch (e2) {
      case t2.BYTE_COMPACTION_MODE_LATCH:
        for (var f3 = new Int32Array(6), h2 = r2[o2++]; o2 < r2[0] && !c2; )
          switch (f3[s2++] = h2, u2 = 900 * u2 + h2, h2 = r2[o2++]) {
            case t2.TEXT_COMPACTION_MODE_LATCH:
            case t2.BYTE_COMPACTION_MODE_LATCH:
            case t2.NUMERIC_COMPACTION_MODE_LATCH:
            case t2.BYTE_COMPACTION_MODE_LATCH_6:
            case t2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
            case t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case t2.MACRO_PDF417_TERMINATOR:
              o2--, c2 = true;
              break;
            default:
              if (s2 % 5 == 0 && s2 > 0) {
                for (var l2 = 0; l2 < 6; ++l2)
                  a2.write(Number(co(u2) >> co(8 * (5 - l2))));
                u2 = 0, s2 = 0;
              }
          }
        o2 === r2[0] && h2 < t2.TEXT_COMPACTION_MODE_LATCH && (f3[s2++] = h2);
        for (var d2 = 0; d2 < s2; d2++)
          a2.write(f3[d2]);
        break;
      case t2.BYTE_COMPACTION_MODE_LATCH_6:
        for (; o2 < r2[0] && !c2; ) {
          var p2 = r2[o2++];
          if (p2 < t2.TEXT_COMPACTION_MODE_LATCH)
            s2++, u2 = 900 * u2 + p2;
          else
            switch (p2) {
              case t2.TEXT_COMPACTION_MODE_LATCH:
              case t2.BYTE_COMPACTION_MODE_LATCH:
              case t2.NUMERIC_COMPACTION_MODE_LATCH:
              case t2.BYTE_COMPACTION_MODE_LATCH_6:
              case t2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case t2.MACRO_PDF417_TERMINATOR:
                o2--, c2 = true;
            }
          if (s2 % 5 == 0 && s2 > 0) {
            for (l2 = 0; l2 < 6; ++l2)
              a2.write(Number(co(u2) >> co(8 * (5 - l2))));
            u2 = 0, s2 = 0;
          }
        }
    }
    return i2.append(K.decode(a2.toByteArray(), n2)), o2;
  }, t2.numericCompaction = function(e2, r2, n2) {
    for (var o2 = 0, i2 = false, a2 = new Int32Array(t2.MAX_NUMERIC_CODEWORDS); r2 < e2[0] && !i2; ) {
      var s2 = e2[r2++];
      if (r2 === e2[0] && (i2 = true), s2 < t2.TEXT_COMPACTION_MODE_LATCH)
        a2[o2] = s2, o2++;
      else
        switch (s2) {
          case t2.TEXT_COMPACTION_MODE_LATCH:
          case t2.BYTE_COMPACTION_MODE_LATCH:
          case t2.BYTE_COMPACTION_MODE_LATCH_6:
          case t2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
          case t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
          case t2.MACRO_PDF417_TERMINATOR:
            r2--, i2 = true;
        }
      (o2 % t2.MAX_NUMERIC_CODEWORDS == 0 || s2 === t2.NUMERIC_COMPACTION_MODE_LATCH || i2) && o2 > 0 && (n2.append(t2.decodeBase900toBase10(a2, o2)), o2 = 0);
    }
    return r2;
  }, t2.decodeBase900toBase10 = function(e2, r2) {
    for (var n2 = co(0), o2 = 0; o2 < r2; o2++)
      n2 += t2.EXP900[r2 - o2 - 1] * co(e2[o2]);
    var i2 = n2.toString();
    if ("1" !== i2.charAt(0))
      throw new G();
    return i2.substring(1);
  }, t2.TEXT_COMPACTION_MODE_LATCH = 900, t2.BYTE_COMPACTION_MODE_LATCH = 901, t2.NUMERIC_COMPACTION_MODE_LATCH = 902, t2.BYTE_COMPACTION_MODE_LATCH_6 = 924, t2.ECI_USER_DEFINED = 925, t2.ECI_GENERAL_PURPOSE = 926, t2.ECI_CHARSET = 927, t2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928, t2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923, t2.MACRO_PDF417_TERMINATOR = 922, t2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913, t2.MAX_NUMERIC_CODEWORDS = 15, t2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0, t2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1, t2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2, t2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3, t2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4, t2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5, t2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6, t2.PL = 25, t2.LL = 27, t2.AS = 27, t2.ML = 28, t2.AL = 28, t2.PS = 29, t2.PAL = 29, t2.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'", t2.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^", t2.EXP900 = uo() ? function() {
    var t3 = [];
    t3[0] = co(1);
    var e2 = co(900);
    t3[1] = e2;
    for (var r2 = 2; r2 < 16; r2++)
      t3[r2] = t3[r2 - 1] * e2;
    return t3;
  }() : [], t2.NUMBER_OF_SEQUENCE_CODEWORDS = 2, t2;
}();
var ho = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var lo = function() {
  function t2() {
  }
  return t2.decode = function(e2, r2, n2, o2, i2, a2, s2) {
    for (var u2, c2 = new xn(e2, r2, n2, o2, i2), f3 = null, h2 = null, l2 = true; ; l2 = false) {
      if (null != r2 && (f3 = t2.getRowIndicatorColumn(e2, c2, r2, true, a2, s2)), null != o2 && (h2 = t2.getRowIndicatorColumn(e2, c2, o2, false, a2, s2)), null == (u2 = t2.merge(f3, h2)))
        throw tt.getNotFoundInstance();
      var d2 = u2.getBoundingBox();
      if (!l2 || null == d2 || !(d2.getMinY() < c2.getMinY() || d2.getMaxY() > c2.getMaxY()))
        break;
      c2 = d2;
    }
    u2.setBoundingBox(c2);
    var p2 = u2.getBarcodeColumnCount() + 1;
    u2.setDetectionResultColumn(0, f3), u2.setDetectionResultColumn(p2, h2);
    for (var g2 = null != f3, y2 = 1; y2 <= p2; y2++) {
      var w2 = g2 ? y2 : p2 - y2;
      if (void 0 === u2.getDetectionResultColumn(w2)) {
        var v2 = void 0;
        v2 = 0 === w2 || w2 === p2 ? new Zn(c2, 0 === w2) : new Xn(c2), u2.setDetectionResultColumn(w2, v2);
        for (var _2 = -1, A2 = _2, C2 = c2.getMinY(); C2 <= c2.getMaxY(); C2++) {
          if ((_2 = t2.getStartColumn(u2, w2, C2, g2)) < 0 || _2 > c2.getMaxX()) {
            if (-1 === A2)
              continue;
            _2 = A2;
          }
          var m2 = t2.detectCodeword(e2, c2.getMinX(), c2.getMaxX(), g2, _2, C2, a2, s2);
          null != m2 && (v2.setCodeword(C2, m2), A2 = _2, a2 = Math.min(a2, m2.getWidth()), s2 = Math.max(s2, m2.getWidth()));
        }
      }
    }
    return t2.createDecoderResult(u2);
  }, t2.merge = function(e2, r2) {
    if (null == e2 && null == r2)
      return null;
    var n2 = t2.getBarcodeMetadata(e2, r2);
    if (null == n2)
      return null;
    var o2 = xn.merge(t2.adjustBoundingBox(e2), t2.adjustBoundingBox(r2));
    return new qn(n2, o2);
  }, t2.adjustBoundingBox = function(e2) {
    var r2, n2;
    if (null == e2)
      return null;
    var o2 = e2.getRowHeights();
    if (null == o2)
      return null;
    var i2 = t2.getMax(o2), a2 = 0;
    try {
      for (var s2 = ho(o2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
        var c2 = u2.value;
        if (a2 += i2 - c2, c2 > 0)
          break;
      }
    } catch (t3) {
      r2 = { error: t3 };
    } finally {
      try {
        u2 && !u2.done && (n2 = s2.return) && n2.call(s2);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    for (var f3 = e2.getCodewords(), h2 = 0; a2 > 0 && null == f3[h2]; h2++)
      a2--;
    var l2 = 0;
    for (h2 = o2.length - 1; h2 >= 0 && (l2 += i2 - o2[h2], !(o2[h2] > 0)); h2--)
      ;
    for (h2 = f3.length - 1; l2 > 0 && null == f3[h2]; h2--)
      l2--;
    return e2.getBoundingBox().addMissingRows(a2, l2, e2.isLeft());
  }, t2.getMax = function(t3) {
    var e2, r2, n2 = -1;
    try {
      for (var o2 = ho(t3), i2 = o2.next(); !i2.done; i2 = o2.next()) {
        var a2 = i2.value;
        n2 = Math.max(n2, a2);
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        i2 && !i2.done && (r2 = o2.return) && r2.call(o2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return n2;
  }, t2.getBarcodeMetadata = function(t3, e2) {
    var r2, n2;
    return null == t3 || null == (r2 = t3.getBarcodeMetadata()) ? null == e2 ? null : e2.getBarcodeMetadata() : null == e2 || null == (n2 = e2.getBarcodeMetadata()) ? r2 : r2.getColumnCount() !== n2.getColumnCount() && r2.getErrorCorrectionLevel() !== n2.getErrorCorrectionLevel() && r2.getRowCount() !== n2.getRowCount() ? null : r2;
  }, t2.getRowIndicatorColumn = function(e2, r2, n2, o2, i2, a2) {
    for (var s2 = new Zn(r2, o2), u2 = 0; u2 < 2; u2++)
      for (var c2 = 0 === u2 ? 1 : -1, f3 = Math.trunc(Math.trunc(n2.getX())), h2 = Math.trunc(Math.trunc(n2.getY())); h2 <= r2.getMaxY() && h2 >= r2.getMinY(); h2 += c2) {
        var l2 = t2.detectCodeword(e2, 0, e2.getWidth(), o2, f3, h2, i2, a2);
        null != l2 && (s2.setCodeword(h2, l2), f3 = o2 ? l2.getStartX() : l2.getEndX());
      }
    return s2;
  }, t2.adjustCodewordCount = function(e2, r2) {
    var n2 = r2[0][1], o2 = n2.getValue(), i2 = e2.getBarcodeColumnCount() * e2.getBarcodeRowCount() - t2.getNumberOfECCodeWords(e2.getBarcodeECLevel());
    if (0 === o2.length) {
      if (i2 < 1 || i2 > On.MAX_CODEWORDS_IN_BARCODE)
        throw tt.getNotFoundInstance();
      n2.setValue(i2);
    } else
      o2[0] !== i2 && n2.setValue(i2);
  }, t2.createDecoderResult = function(e2) {
    var r2 = t2.createBarcodeMatrix(e2);
    t2.adjustCodewordCount(e2, r2);
    for (var n2 = new Array(), o2 = new Int32Array(e2.getBarcodeRowCount() * e2.getBarcodeColumnCount()), i2 = [], a2 = new Array(), s2 = 0; s2 < e2.getBarcodeRowCount(); s2++)
      for (var u2 = 0; u2 < e2.getBarcodeColumnCount(); u2++) {
        var c2 = r2[s2][u2 + 1].getValue(), f3 = s2 * e2.getBarcodeColumnCount() + u2;
        0 === c2.length ? n2.push(f3) : 1 === c2.length ? o2[f3] = c2[0] : (a2.push(f3), i2.push(c2));
      }
    for (var h2 = new Array(i2.length), l2 = 0; l2 < h2.length; l2++)
      h2[l2] = i2[l2];
    return t2.createDecoderResultFromAmbiguousValues(e2.getBarcodeECLevel(), o2, On.toIntArray(n2), On.toIntArray(a2), h2);
  }, t2.createDecoderResultFromAmbiguousValues = function(e2, r2, n2, o2, i2) {
    for (var a2 = new Int32Array(o2.length), s2 = 100; s2-- > 0; ) {
      for (var u2 = 0; u2 < a2.length; u2++)
        r2[o2[u2]] = i2[u2][a2[u2]];
      try {
        return t2.decodeCodewords(r2, e2, n2);
      } catch (t3) {
        if (!(t3 instanceof R))
          throw t3;
      }
      if (0 === a2.length)
        throw R.getChecksumInstance();
      for (u2 = 0; u2 < a2.length; u2++) {
        if (a2[u2] < i2[u2].length - 1) {
          a2[u2]++;
          break;
        }
        if (a2[u2] = 0, u2 === a2.length - 1)
          throw R.getChecksumInstance();
      }
    }
    throw R.getChecksumInstance();
  }, t2.createBarcodeMatrix = function(t3) {
    for (var e2, r2, n2, o2, i2 = Array.from({ length: t3.getBarcodeRowCount() }, function() {
      return new Array(t3.getBarcodeColumnCount() + 2);
    }), a2 = 0; a2 < i2.length; a2++)
      for (var s2 = 0; s2 < i2[a2].length; s2++)
        i2[a2][s2] = new zn();
    var u2 = 0;
    try {
      for (var c2 = ho(t3.getDetectionResultColumns()), f3 = c2.next(); !f3.done; f3 = c2.next()) {
        var h2 = f3.value;
        if (null != h2)
          try {
            for (var l2 = (n2 = void 0, ho(h2.getCodewords())), d2 = l2.next(); !d2.done; d2 = l2.next()) {
              var p2 = d2.value;
              if (null != p2) {
                var g2 = p2.getRowNumber();
                if (g2 >= 0) {
                  if (g2 >= i2.length)
                    continue;
                  i2[g2][u2].setValue(p2.getValue());
                }
              }
            }
          } catch (t4) {
            n2 = { error: t4 };
          } finally {
            try {
              d2 && !d2.done && (o2 = l2.return) && o2.call(l2);
            } finally {
              if (n2)
                throw n2.error;
            }
          }
        u2++;
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        f3 && !f3.done && (r2 = c2.return) && r2.call(c2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return i2;
  }, t2.isValidBarcodeColumn = function(t3, e2) {
    return e2 >= 0 && e2 <= t3.getBarcodeColumnCount() + 1;
  }, t2.getStartColumn = function(e2, r2, n2, o2) {
    var i2, a2, s2 = o2 ? 1 : -1, u2 = null;
    if (t2.isValidBarcodeColumn(e2, r2 - s2) && (u2 = e2.getDetectionResultColumn(r2 - s2).getCodeword(n2)), null != u2)
      return o2 ? u2.getEndX() : u2.getStartX();
    if (null != (u2 = e2.getDetectionResultColumn(r2).getCodewordNearby(n2)))
      return o2 ? u2.getStartX() : u2.getEndX();
    if (t2.isValidBarcodeColumn(e2, r2 - s2) && (u2 = e2.getDetectionResultColumn(r2 - s2).getCodewordNearby(n2)), null != u2)
      return o2 ? u2.getEndX() : u2.getStartX();
    for (var c2 = 0; t2.isValidBarcodeColumn(e2, r2 - s2); ) {
      r2 -= s2;
      try {
        for (var f3 = (i2 = void 0, ho(e2.getDetectionResultColumn(r2).getCodewords())), h2 = f3.next(); !h2.done; h2 = f3.next()) {
          var l2 = h2.value;
          if (null != l2)
            return (o2 ? l2.getEndX() : l2.getStartX()) + s2 * c2 * (l2.getEndX() - l2.getStartX());
        }
      } catch (t3) {
        i2 = { error: t3 };
      } finally {
        try {
          h2 && !h2.done && (a2 = f3.return) && a2.call(f3);
        } finally {
          if (i2)
            throw i2.error;
        }
      }
      c2++;
    }
    return o2 ? e2.getBoundingBox().getMinX() : e2.getBoundingBox().getMaxX();
  }, t2.detectCodeword = function(e2, r2, n2, o2, i2, a2, s2, u2) {
    i2 = t2.adjustCodewordStartColumn(e2, r2, n2, o2, i2, a2);
    var c2, f3 = t2.getModuleBitCount(e2, r2, n2, o2, i2, a2);
    if (null == f3)
      return null;
    var h2 = Pt.sum(f3);
    if (o2)
      c2 = i2 + h2;
    else {
      for (var l2 = 0; l2 < f3.length / 2; l2++) {
        var d2 = f3[l2];
        f3[l2] = f3[f3.length - 1 - l2], f3[f3.length - 1 - l2] = d2;
      }
      i2 = (c2 = i2) - h2;
    }
    if (!t2.checkCodewordSkew(h2, s2, u2))
      return null;
    var p2 = Jn.getDecodedValue(f3), g2 = On.getCodeword(p2);
    return -1 === g2 ? null : new Qn(i2, c2, t2.getCodewordBucketNumber(p2), g2);
  }, t2.getModuleBitCount = function(t3, e2, r2, n2, o2, i2) {
    for (var a2 = o2, s2 = new Int32Array(8), u2 = 0, c2 = n2 ? 1 : -1, f3 = n2; (n2 ? a2 < r2 : a2 >= e2) && u2 < s2.length; )
      t3.get(a2, i2) === f3 ? (s2[u2]++, a2 += c2) : (u2++, f3 = !f3);
    return u2 === s2.length || a2 === (n2 ? r2 : e2) && u2 === s2.length - 1 ? s2 : null;
  }, t2.getNumberOfECCodeWords = function(t3) {
    return 2 << t3;
  }, t2.adjustCodewordStartColumn = function(e2, r2, n2, o2, i2, a2) {
    for (var s2 = i2, u2 = o2 ? -1 : 1, c2 = 0; c2 < 2; c2++) {
      for (; (o2 ? s2 >= r2 : s2 < n2) && o2 === e2.get(s2, a2); ) {
        if (Math.abs(i2 - s2) > t2.CODEWORD_SKEW_SIZE)
          return i2;
        s2 += u2;
      }
      u2 = -u2, o2 = !o2;
    }
    return s2;
  }, t2.checkCodewordSkew = function(e2, r2, n2) {
    return r2 - t2.CODEWORD_SKEW_SIZE <= e2 && e2 <= n2 + t2.CODEWORD_SKEW_SIZE;
  }, t2.decodeCodewords = function(e2, r2, n2) {
    if (0 === e2.length)
      throw G.getFormatInstance();
    var o2 = 1 << r2 + 1, i2 = t2.correctErrors(e2, n2, o2);
    t2.verifyCodewordCount(e2, o2);
    var a2 = fo.decode(e2, "" + r2);
    return a2.setErrorsCorrected(i2), a2.setErasures(n2.length), a2;
  }, t2.correctErrors = function(e2, r2, n2) {
    if (null != r2 && r2.length > n2 / 2 + t2.MAX_ERRORS || n2 < 0 || n2 > t2.MAX_EC_CODEWORDS)
      throw R.getChecksumInstance();
    return t2.errorCorrection.decode(e2, n2, r2);
  }, t2.verifyCodewordCount = function(t3, e2) {
    if (t3.length < 4)
      throw G.getFormatInstance();
    var r2 = t3[0];
    if (r2 > t3.length)
      throw G.getFormatInstance();
    if (0 === r2) {
      if (!(e2 < t3.length))
        throw G.getFormatInstance();
      t3[0] = t3.length - e2;
    }
  }, t2.getBitCountForCodeword = function(t3) {
    for (var e2 = new Int32Array(8), r2 = 0, n2 = e2.length - 1; !((1 & t3) !== r2 && (r2 = 1 & t3, --n2 < 0)); )
      e2[n2]++, t3 >>= 1;
    return e2;
  }, t2.getCodewordBucketNumber = function(t3) {
    return t3 instanceof Int32Array ? this.getCodewordBucketNumber_Int32Array(t3) : this.getCodewordBucketNumber_number(t3);
  }, t2.getCodewordBucketNumber_number = function(e2) {
    return t2.getCodewordBucketNumber(t2.getBitCountForCodeword(e2));
  }, t2.getCodewordBucketNumber_Int32Array = function(t3) {
    return (t3[0] - t3[2] + t3[4] - t3[6] + 9) % 9;
  }, t2.toString = function(t3) {
    for (var e2 = new Hn(), r2 = 0; r2 < t3.length; r2++) {
      e2.format("Row %2d: ", r2);
      for (var n2 = 0; n2 < t3[r2].length; n2++) {
        var o2 = t3[r2][n2];
        0 === o2.getValue().length ? e2.format("        ", null) : e2.format("%4d(%2d)", o2.getValue()[0], o2.getConfidence(o2.getValue()[0]));
      }
      e2.format("%n");
    }
    return e2.toString();
  }, t2.CODEWORD_SKEW_SIZE = 2, t2.MAX_ERRORS = 3, t2.MAX_EC_CODEWORDS = 512, t2.errorCorrection = new kn(), t2;
}();
var po = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var go = function() {
  function t2() {
  }
  return t2.prototype.decode = function(e2, r2) {
    void 0 === r2 && (r2 = null);
    var n2 = t2.decode(e2, r2, false);
    if (null == n2 || 0 === n2.length || null == n2[0])
      throw tt.getNotFoundInstance();
    return n2[0];
  }, t2.prototype.decodeMultiple = function(e2, r2) {
    void 0 === r2 && (r2 = null);
    try {
      return t2.decode(e2, r2, true);
    } catch (t3) {
      if (t3 instanceof G || t3 instanceof R)
        throw tt.getNotFoundInstance();
      throw t3;
    }
  }, t2.decode = function(e2, r2, n2) {
    var o2, i2, a2 = new Array(), s2 = Nn.detectMultiple(e2, r2, n2);
    try {
      for (var u2 = po(s2.getPoints()), c2 = u2.next(); !c2.done; c2 = u2.next()) {
        var f3 = c2.value, h2 = lo.decode(s2.getBits(), f3[4], f3[5], f3[6], f3[7], t2.getMinCodewordWidth(f3), t2.getMaxCodewordWidth(f3)), l2 = new gt(h2.getText(), h2.getRawBytes(), void 0, f3, wt.PDF_417);
        l2.putMetadata(_t.ERROR_CORRECTION_LEVEL, h2.getECLevel());
        var d2 = h2.getOther();
        null != d2 && l2.putMetadata(_t.PDF417_EXTRA_METADATA, d2), a2.push(l2);
      }
    } catch (t3) {
      o2 = { error: t3 };
    } finally {
      try {
        c2 && !c2.done && (i2 = u2.return) && i2.call(u2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    return a2.map(function(t3) {
      return t3;
    });
  }, t2.getMaxWidth = function(t3, e2) {
    return null == t3 || null == e2 ? 0 : Math.trunc(Math.abs(t3.getX() - e2.getX()));
  }, t2.getMinWidth = function(t3, e2) {
    return null == t3 || null == e2 ? x.MAX_VALUE : Math.trunc(Math.abs(t3.getX() - e2.getX()));
  }, t2.getMaxCodewordWidth = function(e2) {
    return Math.floor(Math.max(Math.max(t2.getMaxWidth(e2[0], e2[4]), t2.getMaxWidth(e2[6], e2[2]) * On.MODULES_IN_CODEWORD / On.MODULES_IN_STOP_PATTERN), Math.max(t2.getMaxWidth(e2[1], e2[5]), t2.getMaxWidth(e2[7], e2[3]) * On.MODULES_IN_CODEWORD / On.MODULES_IN_STOP_PATTERN)));
  }, t2.getMinCodewordWidth = function(e2) {
    return Math.floor(Math.min(Math.min(t2.getMinWidth(e2[0], e2[4]), t2.getMinWidth(e2[6], e2[2]) * On.MODULES_IN_CODEWORD / On.MODULES_IN_STOP_PATTERN), Math.min(t2.getMinWidth(e2[1], e2[5]), t2.getMinWidth(e2[7], e2[3]) * On.MODULES_IN_CODEWORD / On.MODULES_IN_STOP_PATTERN)));
  }, t2.prototype.reset = function() {
  }, t2;
}();
var yo = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var wo = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return yo(e2, t2), e2.kind = "ReaderException", e2;
}(m);
var vo = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var _o = function() {
  function t2() {
  }
  return t2.prototype.decode = function(t3, e2) {
    return this.setHints(e2), this.decodeInternal(t3);
  }, t2.prototype.decodeWithState = function(t3) {
    return null !== this.readers && void 0 !== this.readers || this.setHints(null), this.decodeInternal(t3);
  }, t2.prototype.setHints = function(t3) {
    this.hints = t3;
    var e2 = null != t3 && void 0 !== t3.get(U.TRY_HARDER), r2 = null == t3 ? null : t3.get(U.POSSIBLE_FORMATS), n2 = new Array();
    if (null != r2) {
      var o2 = r2.some(function(t4) {
        return t4 === wt.UPC_A || t4 === wt.UPC_E || t4 === wt.EAN_13 || t4 === wt.EAN_8 || t4 === wt.CODABAR || t4 === wt.CODE_39 || t4 === wt.CODE_93 || t4 === wt.CODE_128 || t4 === wt.ITF || t4 === wt.RSS_14 || t4 === wt.RSS_EXPANDED;
      });
      o2 && !e2 && n2.push(new Rr(t3)), r2.includes(wt.QR_CODE) && n2.push(new Sn()), r2.includes(wt.DATA_MATRIX) && n2.push(new zr()), r2.includes(wt.AZTEC) && n2.push(new Yt()), r2.includes(wt.PDF_417) && n2.push(new go()), o2 && e2 && n2.push(new Rr(t3));
    }
    0 === n2.length && (e2 || n2.push(new Rr(t3)), n2.push(new Sn()), n2.push(new zr()), n2.push(new Yt()), n2.push(new go()), e2 && n2.push(new Rr(t3))), this.readers = n2;
  }, t2.prototype.reset = function() {
    var t3, e2;
    if (null !== this.readers)
      try {
        for (var r2 = vo(this.readers), n2 = r2.next(); !n2.done; n2 = r2.next()) {
          n2.value.reset();
        }
      } catch (e3) {
        t3 = { error: e3 };
      } finally {
        try {
          n2 && !n2.done && (e2 = r2.return) && e2.call(r2);
        } finally {
          if (t3)
            throw t3.error;
        }
      }
  }, t2.prototype.decodeInternal = function(t3) {
    var e2, r2;
    if (null === this.readers)
      throw new wo("No readers where selected, nothing can be read.");
    try {
      for (var n2 = vo(this.readers), o2 = n2.next(); !o2.done; o2 = n2.next()) {
        var i2 = o2.value;
        try {
          return i2.decode(t3, this.hints);
        } catch (t4) {
          if (t4 instanceof wo)
            continue;
        }
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        o2 && !o2.done && (r2 = n2.return) && r2.call(n2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    throw new tt("No MultiFormat Readers were able to detect the code.");
  }, t2;
}();
var Ao = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Co = function(t2) {
  function e2(e3, r2) {
    void 0 === e3 && (e3 = null), void 0 === r2 && (r2 = 500);
    var n2 = new _o();
    return n2.setHints(e3), t2.call(this, n2, r2) || this;
  }
  return Ao(e2, t2), e2.prototype.decodeBitmap = function(t3) {
    return this.reader.decodeWithState(t3);
  }, e2;
}(pt);
var mo = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  function e2(e3) {
    return void 0 === e3 && (e3 = 500), t2.call(this, new go(), e3) || this;
  }
  mo(e2, t2);
}(pt);
var Eo;
var Io = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  function e2(e3) {
    return void 0 === e3 && (e3 = 500), t2.call(this, new Sn(), e3) || this;
  }
  Io(e2, t2);
}(pt), function(t2) {
  t2[t2.ERROR_CORRECTION = 0] = "ERROR_CORRECTION", t2[t2.CHARACTER_SET = 1] = "CHARACTER_SET", t2[t2.DATA_MATRIX_SHAPE = 2] = "DATA_MATRIX_SHAPE", t2[t2.DATA_MATRIX_COMPACT = 3] = "DATA_MATRIX_COMPACT", t2[t2.MIN_SIZE = 4] = "MIN_SIZE", t2[t2.MAX_SIZE = 5] = "MAX_SIZE", t2[t2.MARGIN = 6] = "MARGIN", t2[t2.PDF417_COMPACT = 7] = "PDF417_COMPACT", t2[t2.PDF417_COMPACTION = 8] = "PDF417_COMPACTION", t2[t2.PDF417_DIMENSIONS = 9] = "PDF417_DIMENSIONS", t2[t2.AZTEC_LAYERS = 10] = "AZTEC_LAYERS", t2[t2.QR_VERSION = 11] = "QR_VERSION", t2[t2.GS1_FORMAT = 12] = "GS1_FORMAT", t2[t2.FORCE_C40 = 13] = "FORCE_C40";
}(Eo || (Eo = {}));
var So = Eo;
var To = function() {
  function t2(t3) {
    this.field = t3, this.cachedGenerators = [], this.cachedGenerators.push(new mt(t3, Int32Array.from([1])));
  }
  return t2.prototype.buildGenerator = function(t3) {
    var e2 = this.cachedGenerators;
    if (t3 >= e2.length)
      for (var r2 = e2[e2.length - 1], n2 = this.field, o2 = e2.length; o2 <= t3; o2++) {
        var i2 = r2.multiply(new mt(n2, Int32Array.from([1, n2.exp(o2 - 1 + n2.getGeneratorBase())])));
        e2.push(i2), r2 = i2;
      }
    return e2[t3];
  }, t2.prototype.encode = function(t3, e2) {
    if (0 === e2)
      throw new T("No error correction bytes");
    var r2 = t3.length - e2;
    if (r2 <= 0)
      throw new T("No data bytes provided");
    var n2 = this.buildGenerator(e2), o2 = new Int32Array(r2);
    D.arraycopy(t3, 0, o2, 0, r2);
    for (var i2 = new mt(this.field, o2), a2 = (i2 = i2.multiplyByMonomial(e2, 1)).divide(n2)[1].getCoefficients(), s2 = e2 - a2.length, u2 = 0; u2 < s2; u2++)
      t3[r2 + u2] = 0;
    D.arraycopy(a2, 0, t3, r2 + s2, a2.length);
  }, t2;
}();
var Oo = function() {
  function t2() {
  }
  return t2.applyMaskPenaltyRule1 = function(e2) {
    return t2.applyMaskPenaltyRule1Internal(e2, true) + t2.applyMaskPenaltyRule1Internal(e2, false);
  }, t2.applyMaskPenaltyRule2 = function(e2) {
    for (var r2 = 0, n2 = e2.getArray(), o2 = e2.getWidth(), i2 = e2.getHeight(), a2 = 0; a2 < i2 - 1; a2++)
      for (var s2 = n2[a2], u2 = 0; u2 < o2 - 1; u2++) {
        var c2 = s2[u2];
        c2 === s2[u2 + 1] && c2 === n2[a2 + 1][u2] && c2 === n2[a2 + 1][u2 + 1] && r2++;
      }
    return t2.N2 * r2;
  }, t2.applyMaskPenaltyRule3 = function(e2) {
    for (var r2 = 0, n2 = e2.getArray(), o2 = e2.getWidth(), i2 = e2.getHeight(), a2 = 0; a2 < i2; a2++)
      for (var s2 = 0; s2 < o2; s2++) {
        var u2 = n2[a2];
        s2 + 6 < o2 && 1 === u2[s2] && 0 === u2[s2 + 1] && 1 === u2[s2 + 2] && 1 === u2[s2 + 3] && 1 === u2[s2 + 4] && 0 === u2[s2 + 5] && 1 === u2[s2 + 6] && (t2.isWhiteHorizontal(u2, s2 - 4, s2) || t2.isWhiteHorizontal(u2, s2 + 7, s2 + 11)) && r2++, a2 + 6 < i2 && 1 === n2[a2][s2] && 0 === n2[a2 + 1][s2] && 1 === n2[a2 + 2][s2] && 1 === n2[a2 + 3][s2] && 1 === n2[a2 + 4][s2] && 0 === n2[a2 + 5][s2] && 1 === n2[a2 + 6][s2] && (t2.isWhiteVertical(n2, s2, a2 - 4, a2) || t2.isWhiteVertical(n2, s2, a2 + 7, a2 + 11)) && r2++;
      }
    return r2 * t2.N3;
  }, t2.isWhiteHorizontal = function(t3, e2, r2) {
    e2 = Math.max(e2, 0), r2 = Math.min(r2, t3.length);
    for (var n2 = e2; n2 < r2; n2++)
      if (1 === t3[n2])
        return false;
    return true;
  }, t2.isWhiteVertical = function(t3, e2, r2, n2) {
    r2 = Math.max(r2, 0), n2 = Math.min(n2, t3.length);
    for (var o2 = r2; o2 < n2; o2++)
      if (1 === t3[o2][e2])
        return false;
    return true;
  }, t2.applyMaskPenaltyRule4 = function(e2) {
    for (var r2 = 0, n2 = e2.getArray(), o2 = e2.getWidth(), i2 = e2.getHeight(), a2 = 0; a2 < i2; a2++)
      for (var s2 = n2[a2], u2 = 0; u2 < o2; u2++)
        1 === s2[u2] && r2++;
    var c2 = e2.getHeight() * e2.getWidth();
    return Math.floor(10 * Math.abs(2 * r2 - c2) / c2) * t2.N4;
  }, t2.getDataMaskBit = function(t3, e2, r2) {
    var n2, o2;
    switch (t3) {
      case 0:
        n2 = r2 + e2 & 1;
        break;
      case 1:
        n2 = 1 & r2;
        break;
      case 2:
        n2 = e2 % 3;
        break;
      case 3:
        n2 = (r2 + e2) % 3;
        break;
      case 4:
        n2 = Math.floor(r2 / 2) + Math.floor(e2 / 3) & 1;
        break;
      case 5:
        n2 = (1 & (o2 = r2 * e2)) + o2 % 3;
        break;
      case 6:
        n2 = (1 & (o2 = r2 * e2)) + o2 % 3 & 1;
        break;
      case 7:
        n2 = (o2 = r2 * e2) % 3 + (r2 + e2 & 1) & 1;
        break;
      default:
        throw new T("Invalid mask pattern: " + t3);
    }
    return 0 === n2;
  }, t2.applyMaskPenaltyRule1Internal = function(e2, r2) {
    for (var n2 = 0, o2 = r2 ? e2.getHeight() : e2.getWidth(), i2 = r2 ? e2.getWidth() : e2.getHeight(), a2 = e2.getArray(), s2 = 0; s2 < o2; s2++) {
      for (var u2 = 0, c2 = -1, f3 = 0; f3 < i2; f3++) {
        var h2 = r2 ? a2[s2][f3] : a2[f3][s2];
        h2 === c2 ? u2++ : (u2 >= 5 && (n2 += t2.N1 + (u2 - 5)), u2 = 1, c2 = h2);
      }
      u2 >= 5 && (n2 += t2.N1 + (u2 - 5));
    }
    return n2;
  }, t2.N1 = 3, t2.N2 = 3, t2.N3 = 40, t2.N4 = 10, t2;
}();
var bo = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Ro = function() {
  function t2(t3, e2) {
    this.width = t3, this.height = e2;
    for (var r2 = new Array(e2), n2 = 0; n2 !== e2; n2++)
      r2[n2] = new Uint8Array(t3);
    this.bytes = r2;
  }
  return t2.prototype.getHeight = function() {
    return this.height;
  }, t2.prototype.getWidth = function() {
    return this.width;
  }, t2.prototype.get = function(t3, e2) {
    return this.bytes[e2][t3];
  }, t2.prototype.getArray = function() {
    return this.bytes;
  }, t2.prototype.setNumber = function(t3, e2, r2) {
    this.bytes[e2][t3] = r2;
  }, t2.prototype.setBoolean = function(t3, e2, r2) {
    this.bytes[e2][t3] = r2 ? 1 : 0;
  }, t2.prototype.clear = function(t3) {
    var e2, r2;
    try {
      for (var n2 = bo(this.bytes), o2 = n2.next(); !o2.done; o2 = n2.next()) {
        var i2 = o2.value;
        k.fill(i2, t3);
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        o2 && !o2.done && (r2 = n2.return) && r2.call(n2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
  }, t2.prototype.equals = function(e2) {
    if (!(e2 instanceof t2))
      return false;
    var r2 = e2;
    if (this.width !== r2.width)
      return false;
    if (this.height !== r2.height)
      return false;
    for (var n2 = 0, o2 = this.height; n2 < o2; ++n2)
      for (var i2 = this.bytes[n2], a2 = r2.bytes[n2], s2 = 0, u2 = this.width; s2 < u2; ++s2)
        if (i2[s2] !== a2[s2])
          return false;
    return true;
  }, t2.prototype.toString = function() {
    for (var t3 = new Q(), e2 = 0, r2 = this.height; e2 < r2; ++e2) {
      for (var n2 = this.bytes[e2], o2 = 0, i2 = this.width; o2 < i2; ++o2)
        switch (n2[o2]) {
          case 0:
            t3.append(" 0");
            break;
          case 1:
            t3.append(" 1");
            break;
          default:
            t3.append("  ");
        }
      t3.append("\n");
    }
    return t3.toString();
  }, t2;
}();
var No = function() {
  function t2() {
    this.maskPattern = -1;
  }
  return t2.prototype.getMode = function() {
    return this.mode;
  }, t2.prototype.getECLevel = function() {
    return this.ecLevel;
  }, t2.prototype.getVersion = function() {
    return this.version;
  }, t2.prototype.getMaskPattern = function() {
    return this.maskPattern;
  }, t2.prototype.getMatrix = function() {
    return this.matrix;
  }, t2.prototype.toString = function() {
    var t3 = new Q();
    return t3.append("<<\n"), t3.append(" mode: "), t3.append(this.mode ? this.mode.toString() : "null"), t3.append("\n ecLevel: "), t3.append(this.ecLevel ? this.ecLevel.toString() : "null"), t3.append("\n version: "), t3.append(this.version ? this.version.toString() : "null"), t3.append("\n maskPattern: "), t3.append(this.maskPattern.toString()), this.matrix ? (t3.append("\n matrix:\n"), t3.append(this.matrix.toString())) : t3.append("\n matrix: null\n"), t3.append(">>\n"), t3.toString();
  }, t2.prototype.setMode = function(t3) {
    this.mode = t3;
  }, t2.prototype.setECLevel = function(t3) {
    this.ecLevel = t3;
  }, t2.prototype.setVersion = function(t3) {
    this.version = t3;
  }, t2.prototype.setMaskPattern = function(t3) {
    this.maskPattern = t3;
  }, t2.prototype.setMatrix = function(t3) {
    this.matrix = t3;
  }, t2.isValidMaskPattern = function(e2) {
    return e2 >= 0 && e2 < t2.NUM_MASK_PATTERNS;
  }, t2.NUM_MASK_PATTERNS = 8, t2;
}();
var Do = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Mo = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return Do(e2, t2), e2.kind = "WriterException", e2;
}(m);
var Po = function() {
  function t2() {
  }
  return t2.clearMatrix = function(t3) {
    t3.clear(255);
  }, t2.buildMatrix = function(e2, r2, n2, o2, i2) {
    t2.clearMatrix(i2), t2.embedBasicPatterns(n2, i2), t2.embedTypeInfo(r2, o2, i2), t2.maybeEmbedVersionInfo(n2, i2), t2.embedDataBits(e2, o2, i2);
  }, t2.embedBasicPatterns = function(e2, r2) {
    t2.embedPositionDetectionPatternsAndSeparators(r2), t2.embedDarkDotAtLeftBottomCorner(r2), t2.maybeEmbedPositionAdjustmentPatterns(e2, r2), t2.embedTimingPatterns(r2);
  }, t2.embedTypeInfo = function(e2, r2, n2) {
    var o2 = new V();
    t2.makeTypeInfoBits(e2, r2, o2);
    for (var i2 = 0, a2 = o2.getSize(); i2 < a2; ++i2) {
      var s2 = o2.get(o2.getSize() - 1 - i2), u2 = t2.TYPE_INFO_COORDINATES[i2], c2 = u2[0], f3 = u2[1];
      if (n2.setBoolean(c2, f3, s2), i2 < 8) {
        var h2 = n2.getWidth() - i2 - 1, l2 = 8;
        n2.setBoolean(h2, l2, s2);
      } else {
        h2 = 8, l2 = n2.getHeight() - 7 + (i2 - 8);
        n2.setBoolean(h2, l2, s2);
      }
    }
  }, t2.maybeEmbedVersionInfo = function(e2, r2) {
    if (!(e2.getVersionNumber() < 7)) {
      var n2 = new V();
      t2.makeVersionInfoBits(e2, n2);
      for (var o2 = 17, i2 = 0; i2 < 6; ++i2)
        for (var a2 = 0; a2 < 3; ++a2) {
          var s2 = n2.get(o2);
          o2--, r2.setBoolean(i2, r2.getHeight() - 11 + a2, s2), r2.setBoolean(r2.getHeight() - 11 + a2, i2, s2);
        }
    }
  }, t2.embedDataBits = function(e2, r2, n2) {
    for (var o2 = 0, i2 = -1, a2 = n2.getWidth() - 1, s2 = n2.getHeight() - 1; a2 > 0; ) {
      for (6 === a2 && (a2 -= 1); s2 >= 0 && s2 < n2.getHeight(); ) {
        for (var u2 = 0; u2 < 2; ++u2) {
          var c2 = a2 - u2;
          if (t2.isEmpty(n2.get(c2, s2))) {
            var f3 = void 0;
            o2 < e2.getSize() ? (f3 = e2.get(o2), ++o2) : f3 = false, 255 !== r2 && Oo.getDataMaskBit(r2, c2, s2) && (f3 = !f3), n2.setBoolean(c2, s2, f3);
          }
        }
        s2 += i2;
      }
      s2 += i2 = -i2, a2 -= 2;
    }
    if (o2 !== e2.getSize())
      throw new Mo("Not all bits consumed: " + o2 + "/" + e2.getSize());
  }, t2.findMSBSet = function(t3) {
    return 32 - x.numberOfLeadingZeros(t3);
  }, t2.calculateBCHCode = function(e2, r2) {
    if (0 === r2)
      throw new T("0 polynomial");
    var n2 = t2.findMSBSet(r2);
    for (e2 <<= n2 - 1; t2.findMSBSet(e2) >= n2; )
      e2 ^= r2 << t2.findMSBSet(e2) - n2;
    return e2;
  }, t2.makeTypeInfoBits = function(e2, r2, n2) {
    if (!No.isValidMaskPattern(r2))
      throw new Mo("Invalid mask pattern");
    var o2 = e2.getBits() << 3 | r2;
    n2.appendBits(o2, 5);
    var i2 = t2.calculateBCHCode(o2, t2.TYPE_INFO_POLY);
    n2.appendBits(i2, 10);
    var a2 = new V();
    if (a2.appendBits(t2.TYPE_INFO_MASK_PATTERN, 15), n2.xor(a2), 15 !== n2.getSize())
      throw new Mo("should not happen but we got: " + n2.getSize());
  }, t2.makeVersionInfoBits = function(e2, r2) {
    r2.appendBits(e2.getVersionNumber(), 6);
    var n2 = t2.calculateBCHCode(e2.getVersionNumber(), t2.VERSION_INFO_POLY);
    if (r2.appendBits(n2, 12), 18 !== r2.getSize())
      throw new Mo("should not happen but we got: " + r2.getSize());
  }, t2.isEmpty = function(t3) {
    return 255 === t3;
  }, t2.embedTimingPatterns = function(e2) {
    for (var r2 = 8; r2 < e2.getWidth() - 8; ++r2) {
      var n2 = (r2 + 1) % 2;
      t2.isEmpty(e2.get(r2, 6)) && e2.setNumber(r2, 6, n2), t2.isEmpty(e2.get(6, r2)) && e2.setNumber(6, r2, n2);
    }
  }, t2.embedDarkDotAtLeftBottomCorner = function(t3) {
    if (0 === t3.get(8, t3.getHeight() - 8))
      throw new Mo();
    t3.setNumber(8, t3.getHeight() - 8, 1);
  }, t2.embedHorizontalSeparationPattern = function(e2, r2, n2) {
    for (var o2 = 0; o2 < 8; ++o2) {
      if (!t2.isEmpty(n2.get(e2 + o2, r2)))
        throw new Mo();
      n2.setNumber(e2 + o2, r2, 0);
    }
  }, t2.embedVerticalSeparationPattern = function(e2, r2, n2) {
    for (var o2 = 0; o2 < 7; ++o2) {
      if (!t2.isEmpty(n2.get(e2, r2 + o2)))
        throw new Mo();
      n2.setNumber(e2, r2 + o2, 0);
    }
  }, t2.embedPositionAdjustmentPattern = function(e2, r2, n2) {
    for (var o2 = 0; o2 < 5; ++o2)
      for (var i2 = t2.POSITION_ADJUSTMENT_PATTERN[o2], a2 = 0; a2 < 5; ++a2)
        n2.setNumber(e2 + a2, r2 + o2, i2[a2]);
  }, t2.embedPositionDetectionPattern = function(e2, r2, n2) {
    for (var o2 = 0; o2 < 7; ++o2)
      for (var i2 = t2.POSITION_DETECTION_PATTERN[o2], a2 = 0; a2 < 7; ++a2)
        n2.setNumber(e2 + a2, r2 + o2, i2[a2]);
  }, t2.embedPositionDetectionPatternsAndSeparators = function(e2) {
    var r2 = t2.POSITION_DETECTION_PATTERN[0].length;
    t2.embedPositionDetectionPattern(0, 0, e2), t2.embedPositionDetectionPattern(e2.getWidth() - r2, 0, e2), t2.embedPositionDetectionPattern(0, e2.getWidth() - r2, e2);
    t2.embedHorizontalSeparationPattern(0, 7, e2), t2.embedHorizontalSeparationPattern(e2.getWidth() - 8, 7, e2), t2.embedHorizontalSeparationPattern(0, e2.getWidth() - 8, e2);
    t2.embedVerticalSeparationPattern(7, 0, e2), t2.embedVerticalSeparationPattern(e2.getHeight() - 7 - 1, 0, e2), t2.embedVerticalSeparationPattern(7, e2.getHeight() - 7, e2);
  }, t2.maybeEmbedPositionAdjustmentPatterns = function(e2, r2) {
    if (!(e2.getVersionNumber() < 2))
      for (var n2 = e2.getVersionNumber() - 1, o2 = t2.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[n2], i2 = 0, a2 = o2.length; i2 !== a2; i2++) {
        var s2 = o2[i2];
        if (s2 >= 0)
          for (var u2 = 0; u2 !== a2; u2++) {
            var c2 = o2[u2];
            c2 >= 0 && t2.isEmpty(r2.get(c2, s2)) && t2.embedPositionAdjustmentPattern(c2 - 2, s2 - 2, r2);
          }
      }
  }, t2.POSITION_DETECTION_PATTERN = Array.from([Int32Array.from([1, 1, 1, 1, 1, 1, 1]), Int32Array.from([1, 0, 0, 0, 0, 0, 1]), Int32Array.from([1, 0, 1, 1, 1, 0, 1]), Int32Array.from([1, 0, 1, 1, 1, 0, 1]), Int32Array.from([1, 0, 1, 1, 1, 0, 1]), Int32Array.from([1, 0, 0, 0, 0, 0, 1]), Int32Array.from([1, 1, 1, 1, 1, 1, 1])]), t2.POSITION_ADJUSTMENT_PATTERN = Array.from([Int32Array.from([1, 1, 1, 1, 1]), Int32Array.from([1, 0, 0, 0, 1]), Int32Array.from([1, 0, 1, 0, 1]), Int32Array.from([1, 0, 0, 0, 1]), Int32Array.from([1, 1, 1, 1, 1])]), t2.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([Int32Array.from([-1, -1, -1, -1, -1, -1, -1]), Int32Array.from([6, 18, -1, -1, -1, -1, -1]), Int32Array.from([6, 22, -1, -1, -1, -1, -1]), Int32Array.from([6, 26, -1, -1, -1, -1, -1]), Int32Array.from([6, 30, -1, -1, -1, -1, -1]), Int32Array.from([6, 34, -1, -1, -1, -1, -1]), Int32Array.from([6, 22, 38, -1, -1, -1, -1]), Int32Array.from([6, 24, 42, -1, -1, -1, -1]), Int32Array.from([6, 26, 46, -1, -1, -1, -1]), Int32Array.from([6, 28, 50, -1, -1, -1, -1]), Int32Array.from([6, 30, 54, -1, -1, -1, -1]), Int32Array.from([6, 32, 58, -1, -1, -1, -1]), Int32Array.from([6, 34, 62, -1, -1, -1, -1]), Int32Array.from([6, 26, 46, 66, -1, -1, -1]), Int32Array.from([6, 26, 48, 70, -1, -1, -1]), Int32Array.from([6, 26, 50, 74, -1, -1, -1]), Int32Array.from([6, 30, 54, 78, -1, -1, -1]), Int32Array.from([6, 30, 56, 82, -1, -1, -1]), Int32Array.from([6, 30, 58, 86, -1, -1, -1]), Int32Array.from([6, 34, 62, 90, -1, -1, -1]), Int32Array.from([6, 28, 50, 72, 94, -1, -1]), Int32Array.from([6, 26, 50, 74, 98, -1, -1]), Int32Array.from([6, 30, 54, 78, 102, -1, -1]), Int32Array.from([6, 28, 54, 80, 106, -1, -1]), Int32Array.from([6, 32, 58, 84, 110, -1, -1]), Int32Array.from([6, 30, 58, 86, 114, -1, -1]), Int32Array.from([6, 34, 62, 90, 118, -1, -1]), Int32Array.from([6, 26, 50, 74, 98, 122, -1]), Int32Array.from([6, 30, 54, 78, 102, 126, -1]), Int32Array.from([6, 26, 52, 78, 104, 130, -1]), Int32Array.from([6, 30, 56, 82, 108, 134, -1]), Int32Array.from([6, 34, 60, 86, 112, 138, -1]), Int32Array.from([6, 30, 58, 86, 114, 142, -1]), Int32Array.from([6, 34, 62, 90, 118, 146, -1]), Int32Array.from([6, 30, 54, 78, 102, 126, 150]), Int32Array.from([6, 24, 50, 76, 102, 128, 154]), Int32Array.from([6, 28, 54, 80, 106, 132, 158]), Int32Array.from([6, 32, 58, 84, 110, 136, 162]), Int32Array.from([6, 26, 54, 82, 110, 138, 166]), Int32Array.from([6, 30, 58, 86, 114, 142, 170])]), t2.TYPE_INFO_COORDINATES = Array.from([Int32Array.from([8, 0]), Int32Array.from([8, 1]), Int32Array.from([8, 2]), Int32Array.from([8, 3]), Int32Array.from([8, 4]), Int32Array.from([8, 5]), Int32Array.from([8, 7]), Int32Array.from([8, 8]), Int32Array.from([7, 8]), Int32Array.from([5, 8]), Int32Array.from([4, 8]), Int32Array.from([3, 8]), Int32Array.from([2, 8]), Int32Array.from([1, 8]), Int32Array.from([0, 8])]), t2.VERSION_INFO_POLY = 7973, t2.TYPE_INFO_POLY = 1335, t2.TYPE_INFO_MASK_PATTERN = 21522, t2;
}();
var Bo = function() {
  function t2(t3, e2) {
    this.dataBytes = t3, this.errorCorrectionBytes = e2;
  }
  return t2.prototype.getDataBytes = function() {
    return this.dataBytes;
  }, t2.prototype.getErrorCorrectionBytes = function() {
    return this.errorCorrectionBytes;
  }, t2;
}();
var Lo = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
!function() {
  function t2() {
  }
  t2.calculateMaskPenalty = function(t3) {
    return Oo.applyMaskPenaltyRule1(t3) + Oo.applyMaskPenaltyRule2(t3) + Oo.applyMaskPenaltyRule3(t3) + Oo.applyMaskPenaltyRule4(t3);
  }, t2.encode = function(e2, r2, n2) {
    void 0 === n2 && (n2 = null);
    var o2 = t2.DEFAULT_BYTE_MODE_ENCODING, i2 = null !== n2 && void 0 !== n2.get(So.CHARACTER_SET);
    i2 && (o2 = n2.get(So.CHARACTER_SET).toString());
    var a2 = this.chooseMode(e2, o2), s2 = new V();
    if (a2 === fn.BYTE && (i2 || t2.DEFAULT_BYTE_MODE_ENCODING !== o2)) {
      var u2 = j.getCharacterSetECIByName(o2);
      void 0 !== u2 && this.appendECI(u2, s2);
    }
    this.appendModeInfo(a2, s2);
    var c2, f3 = new V();
    if (this.appendBytes(e2, a2, f3, o2), null !== n2 && void 0 !== n2.get(So.QR_VERSION)) {
      var h2 = Number.parseInt(n2.get(So.QR_VERSION).toString(), 10);
      c2 = en.getVersionForNumber(h2);
      var l2 = this.calculateBitsNeeded(a2, s2, f3, c2);
      if (!this.willFit(l2, c2, r2))
        throw new Mo("Data too big for requested version");
    } else
      c2 = this.recommendVersion(r2, a2, s2, f3);
    var d2 = new V();
    d2.appendBitArray(s2);
    var p2 = a2 === fn.BYTE ? f3.getSizeInBytes() : e2.length;
    this.appendLengthInfo(p2, c2, a2, d2), d2.appendBitArray(f3);
    var g2 = c2.getECBlocksForLevel(r2), y2 = c2.getTotalCodewords() - g2.getTotalECCodewords();
    this.terminateBits(y2, d2);
    var w2 = this.interleaveWithECBytes(d2, c2.getTotalCodewords(), y2, g2.getNumBlocks()), v2 = new No();
    v2.setECLevel(r2), v2.setMode(a2), v2.setVersion(c2);
    var _2 = c2.getDimensionForVersion(), A2 = new Ro(_2, _2), C2 = this.chooseMaskPattern(w2, r2, c2, A2);
    return v2.setMaskPattern(C2), Po.buildMatrix(w2, r2, c2, C2, A2), v2.setMatrix(A2), v2;
  }, t2.recommendVersion = function(t3, e2, r2, n2) {
    var o2 = this.calculateBitsNeeded(e2, r2, n2, en.getVersionForNumber(1)), i2 = this.chooseVersion(o2, t3), a2 = this.calculateBitsNeeded(e2, r2, n2, i2);
    return this.chooseVersion(a2, t3);
  }, t2.calculateBitsNeeded = function(t3, e2, r2, n2) {
    return e2.getSize() + t3.getCharacterCountBits(n2) + r2.getSize();
  }, t2.getAlphanumericCode = function(e2) {
    return e2 < t2.ALPHANUMERIC_TABLE.length ? t2.ALPHANUMERIC_TABLE[e2] : -1;
  }, t2.chooseMode = function(e2, r2) {
    if (void 0 === r2 && (r2 = null), j.SJIS.getName() === r2 && this.isOnlyDoubleByteKanji(e2))
      return fn.KANJI;
    for (var n2 = false, o2 = false, i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
      var s2 = e2.charAt(i2);
      if (t2.isDigit(s2))
        n2 = true;
      else {
        if (-1 === this.getAlphanumericCode(s2.charCodeAt(0)))
          return fn.BYTE;
        o2 = true;
      }
    }
    return o2 ? fn.ALPHANUMERIC : n2 ? fn.NUMERIC : fn.BYTE;
  }, t2.isOnlyDoubleByteKanji = function(t3) {
    var e2;
    try {
      e2 = K.encode(t3, j.SJIS);
    } catch (t4) {
      return false;
    }
    var r2 = e2.length;
    if (r2 % 2 != 0)
      return false;
    for (var n2 = 0; n2 < r2; n2 += 2) {
      var o2 = 255 & e2[n2];
      if ((o2 < 129 || o2 > 159) && (o2 < 224 || o2 > 235))
        return false;
    }
    return true;
  }, t2.chooseMaskPattern = function(t3, e2, r2, n2) {
    for (var o2 = Number.MAX_SAFE_INTEGER, i2 = -1, a2 = 0; a2 < No.NUM_MASK_PATTERNS; a2++) {
      Po.buildMatrix(t3, e2, r2, a2, n2);
      var s2 = this.calculateMaskPenalty(n2);
      s2 < o2 && (o2 = s2, i2 = a2);
    }
    return i2;
  }, t2.chooseVersion = function(e2, r2) {
    for (var n2 = 1; n2 <= 40; n2++) {
      var o2 = en.getVersionForNumber(n2);
      if (t2.willFit(e2, o2, r2))
        return o2;
    }
    throw new Mo("Data too big");
  }, t2.willFit = function(t3, e2, r2) {
    return e2.getTotalCodewords() - e2.getECBlocksForLevel(r2).getTotalECCodewords() >= (t3 + 7) / 8;
  }, t2.terminateBits = function(t3, e2) {
    var r2 = 8 * t3;
    if (e2.getSize() > r2)
      throw new Mo("data bits cannot fit in the QR Code" + e2.getSize() + " > " + r2);
    for (var n2 = 0; n2 < 4 && e2.getSize() < r2; ++n2)
      e2.appendBit(false);
    var o2 = 7 & e2.getSize();
    if (o2 > 0)
      for (n2 = o2; n2 < 8; n2++)
        e2.appendBit(false);
    var i2 = t3 - e2.getSizeInBytes();
    for (n2 = 0; n2 < i2; ++n2)
      e2.appendBits(0 == (1 & n2) ? 236 : 17, 8);
    if (e2.getSize() !== r2)
      throw new Mo("Bits size does not equal capacity");
  }, t2.getNumDataBytesAndNumECBytesForBlockID = function(t3, e2, r2, n2, o2, i2) {
    if (n2 >= r2)
      throw new Mo("Block ID too large");
    var a2 = t3 % r2, s2 = r2 - a2, u2 = Math.floor(t3 / r2), c2 = u2 + 1, f3 = Math.floor(e2 / r2), h2 = f3 + 1, l2 = u2 - f3, d2 = c2 - h2;
    if (l2 !== d2)
      throw new Mo("EC bytes mismatch");
    if (r2 !== s2 + a2)
      throw new Mo("RS blocks mismatch");
    if (t3 !== (f3 + l2) * s2 + (h2 + d2) * a2)
      throw new Mo("Total bytes mismatch");
    n2 < s2 ? (o2[0] = f3, i2[0] = l2) : (o2[0] = h2, i2[0] = d2);
  }, t2.interleaveWithECBytes = function(e2, r2, n2, o2) {
    var i2, a2, s2, u2;
    if (e2.getSizeInBytes() !== n2)
      throw new Mo("Number of bits and data bytes does not match");
    for (var c2 = 0, f3 = 0, h2 = 0, l2 = new Array(), d2 = 0; d2 < o2; ++d2) {
      var p2 = new Int32Array(1), g2 = new Int32Array(1);
      t2.getNumDataBytesAndNumECBytesForBlockID(r2, n2, o2, d2, p2, g2);
      var y2 = p2[0], w2 = new Uint8Array(y2);
      e2.toBytes(8 * c2, w2, 0, y2);
      var v2 = t2.generateECBytes(w2, g2[0]);
      l2.push(new Bo(w2, v2)), f3 = Math.max(f3, y2), h2 = Math.max(h2, v2.length), c2 += p2[0];
    }
    if (n2 !== c2)
      throw new Mo("Data bytes does not match offset");
    var _2 = new V();
    for (d2 = 0; d2 < f3; ++d2)
      try {
        for (var A2 = (i2 = void 0, Lo(l2)), C2 = A2.next(); !C2.done; C2 = A2.next()) {
          d2 < (w2 = C2.value.getDataBytes()).length && _2.appendBits(w2[d2], 8);
        }
      } catch (t3) {
        i2 = { error: t3 };
      } finally {
        try {
          C2 && !C2.done && (a2 = A2.return) && a2.call(A2);
        } finally {
          if (i2)
            throw i2.error;
        }
      }
    for (d2 = 0; d2 < h2; ++d2)
      try {
        for (var m2 = (s2 = void 0, Lo(l2)), E2 = m2.next(); !E2.done; E2 = m2.next()) {
          d2 < (v2 = E2.value.getErrorCorrectionBytes()).length && _2.appendBits(v2[d2], 8);
        }
      } catch (t3) {
        s2 = { error: t3 };
      } finally {
        try {
          E2 && !E2.done && (u2 = m2.return) && u2.call(m2);
        } finally {
          if (s2)
            throw s2.error;
        }
      }
    if (r2 !== _2.getSizeInBytes())
      throw new Mo("Interleaving error: " + r2 + " and " + _2.getSizeInBytes() + " differ.");
    return _2;
  }, t2.generateECBytes = function(t3, e2) {
    for (var r2 = t3.length, n2 = new Int32Array(r2 + e2), o2 = 0; o2 < r2; o2++)
      n2[o2] = 255 & t3[o2];
    new To(Tt.QR_CODE_FIELD_256).encode(n2, e2);
    var i2 = new Uint8Array(e2);
    for (o2 = 0; o2 < e2; o2++)
      i2[o2] = n2[r2 + o2];
    return i2;
  }, t2.appendModeInfo = function(t3, e2) {
    e2.appendBits(t3.getBits(), 4);
  }, t2.appendLengthInfo = function(t3, e2, r2, n2) {
    var o2 = r2.getCharacterCountBits(e2);
    if (t3 >= 1 << o2)
      throw new Mo(t3 + " is bigger than " + ((1 << o2) - 1));
    n2.appendBits(t3, o2);
  }, t2.appendBytes = function(e2, r2, n2, o2) {
    switch (r2) {
      case fn.NUMERIC:
        t2.appendNumericBytes(e2, n2);
        break;
      case fn.ALPHANUMERIC:
        t2.appendAlphanumericBytes(e2, n2);
        break;
      case fn.BYTE:
        t2.append8BitBytes(e2, n2, o2);
        break;
      case fn.KANJI:
        t2.appendKanjiBytes(e2, n2);
        break;
      default:
        throw new Mo("Invalid mode: " + r2);
    }
  }, t2.getDigit = function(t3) {
    return t3.charCodeAt(0) - 48;
  }, t2.isDigit = function(e2) {
    var r2 = t2.getDigit(e2);
    return r2 >= 0 && r2 <= 9;
  }, t2.appendNumericBytes = function(e2, r2) {
    for (var n2 = e2.length, o2 = 0; o2 < n2; ) {
      var i2 = t2.getDigit(e2.charAt(o2));
      if (o2 + 2 < n2) {
        var a2 = t2.getDigit(e2.charAt(o2 + 1)), s2 = t2.getDigit(e2.charAt(o2 + 2));
        r2.appendBits(100 * i2 + 10 * a2 + s2, 10), o2 += 3;
      } else if (o2 + 1 < n2) {
        a2 = t2.getDigit(e2.charAt(o2 + 1));
        r2.appendBits(10 * i2 + a2, 7), o2 += 2;
      } else
        r2.appendBits(i2, 4), o2++;
    }
  }, t2.appendAlphanumericBytes = function(e2, r2) {
    for (var n2 = e2.length, o2 = 0; o2 < n2; ) {
      var i2 = t2.getAlphanumericCode(e2.charCodeAt(o2));
      if (-1 === i2)
        throw new Mo();
      if (o2 + 1 < n2) {
        var a2 = t2.getAlphanumericCode(e2.charCodeAt(o2 + 1));
        if (-1 === a2)
          throw new Mo();
        r2.appendBits(45 * i2 + a2, 11), o2 += 2;
      } else
        r2.appendBits(i2, 6), o2++;
    }
  }, t2.append8BitBytes = function(t3, e2, r2) {
    var n2;
    try {
      n2 = K.encode(t3, r2);
    } catch (t4) {
      throw new Mo(t4);
    }
    for (var o2 = 0, i2 = n2.length; o2 !== i2; o2++) {
      var a2 = n2[o2];
      e2.appendBits(a2, 8);
    }
  }, t2.appendKanjiBytes = function(t3, e2) {
    var r2;
    try {
      r2 = K.encode(t3, j.SJIS);
    } catch (t4) {
      throw new Mo(t4);
    }
    for (var n2 = r2.length, o2 = 0; o2 < n2; o2 += 2) {
      var i2 = (255 & r2[o2]) << 8 & 4294967295 | 255 & r2[o2 + 1], a2 = -1;
      if (i2 >= 33088 && i2 <= 40956 ? a2 = i2 - 33088 : i2 >= 57408 && i2 <= 60351 && (a2 = i2 - 49472), -1 === a2)
        throw new Mo("Invalid byte sequence");
      var s2 = 192 * (a2 >> 8) + (255 & a2);
      e2.appendBits(s2, 13);
    }
  }, t2.appendECI = function(t3, e2) {
    e2.appendBits(fn.ECI.getBits(), 4), e2.appendBits(t3.getValue(), 8);
  }, t2.ALPHANUMERIC_TABLE = Int32Array.from([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1]), t2.DEFAULT_BYTE_MODE_ENCODING = j.UTF8.getName();
}();
var Fo = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  function e2(e3, r2, n2, o2, i2, a2, s2, u2) {
    var c2 = t2.call(this, a2, s2) || this;
    if (c2.yuvData = e3, c2.dataWidth = r2, c2.dataHeight = n2, c2.left = o2, c2.top = i2, o2 + a2 > r2 || i2 + s2 > n2)
      throw new T("Crop rectangle does not fit within image data.");
    return u2 && c2.reverseHorizontal(a2, s2), c2;
  }
  Fo(e2, t2), e2.prototype.getRow = function(t3, e3) {
    if (t3 < 0 || t3 >= this.getHeight())
      throw new T("Requested row is outside the image: " + t3);
    var r2 = this.getWidth();
    (null == e3 || e3.length < r2) && (e3 = new Uint8ClampedArray(r2));
    var n2 = (t3 + this.top) * this.dataWidth + this.left;
    return D.arraycopy(this.yuvData, n2, e3, 0, r2), e3;
  }, e2.prototype.getMatrix = function() {
    var t3 = this.getWidth(), e3 = this.getHeight();
    if (t3 === this.dataWidth && e3 === this.dataHeight)
      return this.yuvData;
    var r2 = t3 * e3, n2 = new Uint8ClampedArray(r2), o2 = this.top * this.dataWidth + this.left;
    if (t3 === this.dataWidth)
      return D.arraycopy(this.yuvData, o2, n2, 0, r2), n2;
    for (var i2 = 0; i2 < e3; i2++) {
      var a2 = i2 * t3;
      D.arraycopy(this.yuvData, o2, n2, a2, t3), o2 += this.dataWidth;
    }
    return n2;
  }, e2.prototype.isCropSupported = function() {
    return true;
  }, e2.prototype.crop = function(t3, r2, n2, o2) {
    return new e2(this.yuvData, this.dataWidth, this.dataHeight, this.left + t3, this.top + r2, n2, o2, false);
  }, e2.prototype.renderThumbnail = function() {
    for (var t3 = this.getWidth() / e2.THUMBNAIL_SCALE_FACTOR, r2 = this.getHeight() / e2.THUMBNAIL_SCALE_FACTOR, n2 = new Int32Array(t3 * r2), o2 = this.yuvData, i2 = this.top * this.dataWidth + this.left, a2 = 0; a2 < r2; a2++) {
      for (var s2 = a2 * t3, u2 = 0; u2 < t3; u2++) {
        var c2 = 255 & o2[i2 + u2 * e2.THUMBNAIL_SCALE_FACTOR];
        n2[s2 + u2] = 4278190080 | 65793 * c2;
      }
      i2 += this.dataWidth * e2.THUMBNAIL_SCALE_FACTOR;
    }
    return n2;
  }, e2.prototype.getThumbnailWidth = function() {
    return this.getWidth() / e2.THUMBNAIL_SCALE_FACTOR;
  }, e2.prototype.getThumbnailHeight = function() {
    return this.getHeight() / e2.THUMBNAIL_SCALE_FACTOR;
  }, e2.prototype.reverseHorizontal = function(t3, e3) {
    for (var r2 = this.yuvData, n2 = 0, o2 = this.top * this.dataWidth + this.left; n2 < e3; n2++, o2 += this.dataWidth)
      for (var i2 = o2 + t3 / 2, a2 = o2, s2 = o2 + t3 - 1; a2 < i2; a2++, s2--) {
        var u2 = r2[a2];
        r2[a2] = r2[s2], r2[s2] = u2;
      }
  }, e2.prototype.invert = function() {
    return new st(this);
  }, e2.THUMBNAIL_SCALE_FACTOR = 2;
}(it);
var ko = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  function e2(e3, r2, n2, o2, i2, a2, s2) {
    var u2 = t2.call(this, r2, n2) || this;
    if (u2.dataWidth = o2, u2.dataHeight = i2, u2.left = a2, u2.top = s2, 4 === e3.BYTES_PER_ELEMENT) {
      for (var c2 = r2 * n2, f3 = new Uint8ClampedArray(c2), h2 = 0; h2 < c2; h2++) {
        var l2 = e3[h2], d2 = l2 >> 16 & 255, p2 = l2 >> 7 & 510, g2 = 255 & l2;
        f3[h2] = (d2 + p2 + g2) / 4 & 255;
      }
      u2.luminances = f3;
    } else
      u2.luminances = e3;
    if (void 0 === o2 && (u2.dataWidth = r2), void 0 === i2 && (u2.dataHeight = n2), void 0 === a2 && (u2.left = 0), void 0 === s2 && (u2.top = 0), u2.left + r2 > u2.dataWidth || u2.top + n2 > u2.dataHeight)
      throw new T("Crop rectangle does not fit within image data.");
    return u2;
  }
  ko(e2, t2), e2.prototype.getRow = function(t3, e3) {
    if (t3 < 0 || t3 >= this.getHeight())
      throw new T("Requested row is outside the image: " + t3);
    var r2 = this.getWidth();
    (null == e3 || e3.length < r2) && (e3 = new Uint8ClampedArray(r2));
    var n2 = (t3 + this.top) * this.dataWidth + this.left;
    return D.arraycopy(this.luminances, n2, e3, 0, r2), e3;
  }, e2.prototype.getMatrix = function() {
    var t3 = this.getWidth(), e3 = this.getHeight();
    if (t3 === this.dataWidth && e3 === this.dataHeight)
      return this.luminances;
    var r2 = t3 * e3, n2 = new Uint8ClampedArray(r2), o2 = this.top * this.dataWidth + this.left;
    if (t3 === this.dataWidth)
      return D.arraycopy(this.luminances, o2, n2, 0, r2), n2;
    for (var i2 = 0; i2 < e3; i2++) {
      var a2 = i2 * t3;
      D.arraycopy(this.luminances, o2, n2, a2, t3), o2 += this.dataWidth;
    }
    return n2;
  }, e2.prototype.isCropSupported = function() {
    return true;
  }, e2.prototype.crop = function(t3, r2, n2, o2) {
    return new e2(this.luminances, n2, o2, this.dataWidth, this.dataHeight, this.left + t3, this.top + r2);
  }, e2.prototype.invert = function() {
    return new st(this);
  };
}(it);
var xo;
var Vo;
var Ho = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Uo = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return Ho(e2, t2), e2.forName = function(t3) {
    return this.getCharacterSetECIByName(t3);
  }, e2;
}(j);
var Xo = function() {
  function t2() {
  }
  return t2.ISO_8859_1 = j.ISO8859_1, t2;
}();
(xo = function(t2, e2) {
  for (var r2 = 1, n2 = 0; n2 < 255; n2++)
    e2[n2] = r2, t2[r2] = n2, (r2 *= 2) >= 256 && (r2 ^= 301);
  return { LOG: t2, ALOG: e2 };
}([], [])).LOG, xo.ALOG, function(t2) {
  t2[t2.FORCE_NONE = 0] = "FORCE_NONE", t2[t2.FORCE_SQUARE = 1] = "FORCE_SQUARE", t2[t2.FORCE_RECTANGLE = 2] = "FORCE_RECTANGLE";
}(Vo || (Vo = {}));
var Go;
var Wo = "[)>05";
var zo = "[)>06";
var jo = function() {
  function t2() {
  }
  return t2.prototype.getEncodingMode = function() {
    return 0;
  }, t2.prototype.encode = function(t3) {
    if (si.determineConsecutiveDigitCount(t3.getMessage(), t3.pos) >= 2)
      t3.writeCodeword(this.encodeASCIIDigits(t3.getMessage().charCodeAt(t3.pos), t3.getMessage().charCodeAt(t3.pos + 1))), t3.pos += 2;
    else {
      var e2 = t3.getCurrentChar(), r2 = si.lookAheadTest(t3.getMessage(), t3.pos, this.getEncodingMode());
      if (r2 !== this.getEncodingMode())
        switch (r2) {
          case 5:
            return t3.writeCodeword(231), void t3.signalEncoderChange(5);
          case 1:
            return t3.writeCodeword(230), void t3.signalEncoderChange(1);
          case 3:
            t3.writeCodeword(238), t3.signalEncoderChange(3);
            break;
          case 2:
            t3.writeCodeword(239), t3.signalEncoderChange(2);
            break;
          case 4:
            t3.writeCodeword(240), t3.signalEncoderChange(4);
            break;
          default:
            throw new Error("Illegal mode: " + r2);
        }
      else
        si.isExtendedASCII(e2) ? (t3.writeCodeword(235), t3.writeCodeword(e2 - 128 + 1), t3.pos++) : (t3.writeCodeword(e2 + 1), t3.pos++);
    }
  }, t2.prototype.encodeASCIIDigits = function(t3, e2) {
    if (si.isDigit(t3) && si.isDigit(e2))
      return 10 * (t3 - 48) + (e2 - 48) + 130;
    throw new Error("not digits: " + t3 + e2);
  }, t2;
}();
var Yo = function() {
  function t2() {
  }
  return t2.prototype.getEncodingMode = function() {
    return 5;
  }, t2.prototype.encode = function(t3) {
    var e2 = new Q();
    for (e2.append(0); t3.hasMoreCharacters(); ) {
      var r2 = t3.getCurrentChar();
      if (e2.append(r2), t3.pos++, si.lookAheadTest(t3.getMessage(), t3.pos, this.getEncodingMode()) !== this.getEncodingMode()) {
        t3.signalEncoderChange(0);
        break;
      }
    }
    var n2 = e2.length() - 1, o2 = t3.getCodewordCount() + n2 + 1;
    t3.updateSymbolInfo(o2);
    var i2 = t3.getSymbolInfo().getDataCapacity() - o2 > 0;
    if (t3.hasMoreCharacters() || i2)
      if (n2 <= 249)
        e2.setCharAt(0, q.getCharAt(n2));
      else {
        if (!(n2 <= 1555))
          throw new Error("Message length not in valid ranges: " + n2);
        e2.setCharAt(0, q.getCharAt(Math.floor(n2 / 250) + 249)), e2.insert(1, q.getCharAt(n2 % 250));
      }
    var a2 = 0;
    for (r2 = e2.length(); a2 < r2; a2++)
      t3.writeCodeword(this.randomize255State(e2.charAt(a2).charCodeAt(0), t3.getCodewordCount() + 1));
  }, t2.prototype.randomize255State = function(t3, e2) {
    var r2 = t3 + (149 * e2 % 255 + 1);
    return r2 <= 255 ? r2 : r2 - 256;
  }, t2;
}();
var Zo = function() {
  function t2() {
  }
  return t2.prototype.getEncodingMode = function() {
    return 1;
  }, t2.prototype.encodeMaximal = function(t3) {
    for (var e2 = new Q(), r2 = 0, n2 = t3.pos, o2 = 0; t3.hasMoreCharacters(); ) {
      var i2 = t3.getCurrentChar();
      t3.pos++, r2 = this.encodeChar(i2, e2), e2.length() % 3 == 0 && (n2 = t3.pos, o2 = e2.length());
    }
    if (o2 !== e2.length()) {
      var a2 = Math.floor(e2.length() / 3 * 2), s2 = Math.floor(t3.getCodewordCount() + a2 + 1);
      t3.updateSymbolInfo(s2);
      var u2 = t3.getSymbolInfo().getDataCapacity() - s2, c2 = Math.floor(e2.length() % 3);
      (2 === c2 && 2 !== u2 || 1 === c2 && (r2 > 3 || 1 !== u2)) && (t3.pos = n2);
    }
    e2.length() > 0 && t3.writeCodeword(230), this.handleEOD(t3, e2);
  }, t2.prototype.encode = function(t3) {
    for (var e2 = new Q(); t3.hasMoreCharacters(); ) {
      var r2 = t3.getCurrentChar();
      t3.pos++;
      var n2 = this.encodeChar(r2, e2), o2 = 2 * Math.floor(e2.length() / 3), i2 = t3.getCodewordCount() + o2;
      t3.updateSymbolInfo(i2);
      var a2 = t3.getSymbolInfo().getDataCapacity() - i2;
      if (!t3.hasMoreCharacters()) {
        var s2 = new Q();
        for (e2.length() % 3 == 2 && 2 !== a2 && (n2 = this.backtrackOneCharacter(t3, e2, s2, n2)); e2.length() % 3 == 1 && (n2 > 3 || 1 !== a2); )
          n2 = this.backtrackOneCharacter(t3, e2, s2, n2);
        break;
      }
      if (e2.length() % 3 == 0) {
        if (si.lookAheadTest(t3.getMessage(), t3.pos, this.getEncodingMode()) !== this.getEncodingMode()) {
          t3.signalEncoderChange(0);
          break;
        }
      }
    }
    this.handleEOD(t3, e2);
  }, t2.prototype.backtrackOneCharacter = function(t3, e2, r2, n2) {
    var o2 = e2.length(), i2 = e2.toString().substring(0, o2 - n2);
    e2.setLengthToZero(), e2.append(i2), t3.pos--;
    var a2 = t3.getCurrentChar();
    return n2 = this.encodeChar(a2, r2), t3.resetSymbolInfo(), n2;
  }, t2.prototype.writeNextTriplet = function(t3, e2) {
    t3.writeCodewords(this.encodeToCodewords(e2.toString()));
    var r2 = e2.toString().substring(3);
    e2.setLengthToZero(), e2.append(r2);
  }, t2.prototype.handleEOD = function(t3, e2) {
    var r2 = Math.floor(e2.length() / 3 * 2), n2 = e2.length() % 3, o2 = t3.getCodewordCount() + r2;
    t3.updateSymbolInfo(o2);
    var i2 = t3.getSymbolInfo().getDataCapacity() - o2;
    if (2 === n2) {
      for (e2.append("\0"); e2.length() >= 3; )
        this.writeNextTriplet(t3, e2);
      t3.hasMoreCharacters() && t3.writeCodeword(254);
    } else if (1 === i2 && 1 === n2) {
      for (; e2.length() >= 3; )
        this.writeNextTriplet(t3, e2);
      t3.hasMoreCharacters() && t3.writeCodeword(254), t3.pos--;
    } else {
      if (0 !== n2)
        throw new Error("Unexpected case. Please report!");
      for (; e2.length() >= 3; )
        this.writeNextTriplet(t3, e2);
      (i2 > 0 || t3.hasMoreCharacters()) && t3.writeCodeword(254);
    }
    t3.signalEncoderChange(0);
  }, t2.prototype.encodeChar = function(t3, e2) {
    if (t3 === " ".charCodeAt(0))
      return e2.append(3), 1;
    if (t3 >= "0".charCodeAt(0) && t3 <= "9".charCodeAt(0))
      return e2.append(t3 - 48 + 4), 1;
    if (t3 >= "A".charCodeAt(0) && t3 <= "Z".charCodeAt(0))
      return e2.append(t3 - 65 + 14), 1;
    if (t3 < " ".charCodeAt(0))
      return e2.append(0), e2.append(t3), 2;
    if (t3 <= "/".charCodeAt(0))
      return e2.append(1), e2.append(t3 - 33), 2;
    if (t3 <= "@".charCodeAt(0))
      return e2.append(1), e2.append(t3 - 58 + 15), 2;
    if (t3 <= "_".charCodeAt(0))
      return e2.append(1), e2.append(t3 - 91 + 22), 2;
    if (t3 <= 127)
      return e2.append(2), e2.append(t3 - 96), 2;
    e2.append("1");
    var r2 = 2;
    return r2 += this.encodeChar(t3 - 128, e2);
  }, t2.prototype.encodeToCodewords = function(t3) {
    var e2 = 1600 * t3.charCodeAt(0) + 40 * t3.charCodeAt(1) + t3.charCodeAt(2) + 1, r2 = e2 / 256, n2 = e2 % 256, o2 = new Q();
    return o2.append(r2), o2.append(n2), o2.toString();
  }, t2;
}();
var Ko = function() {
  function t2() {
  }
  return t2.prototype.getEncodingMode = function() {
    return 4;
  }, t2.prototype.encode = function(t3) {
    for (var e2 = new Q(); t3.hasMoreCharacters(); ) {
      var r2 = t3.getCurrentChar();
      if (this.encodeChar(r2, e2), t3.pos++, e2.length() >= 4) {
        t3.writeCodewords(this.encodeToCodewords(e2.toString()));
        var n2 = e2.toString().substring(4);
        if (e2.setLengthToZero(), e2.append(n2), si.lookAheadTest(t3.getMessage(), t3.pos, this.getEncodingMode()) !== this.getEncodingMode()) {
          t3.signalEncoderChange(0);
          break;
        }
      }
    }
    e2.append(q.getCharAt(31)), this.handleEOD(t3, e2);
  }, t2.prototype.handleEOD = function(t3, e2) {
    try {
      var r2 = e2.length();
      if (0 === r2)
        return;
      if (1 === r2) {
        t3.updateSymbolInfo();
        var n2 = t3.getSymbolInfo().getDataCapacity() - t3.getCodewordCount(), o2 = t3.getRemainingCharacters();
        if (o2 > n2 && (t3.updateSymbolInfo(t3.getCodewordCount() + 1), n2 = t3.getSymbolInfo().getDataCapacity() - t3.getCodewordCount()), o2 <= n2 && n2 <= 2)
          return;
      }
      if (r2 > 4)
        throw new Error("Count must not exceed 4");
      var i2 = r2 - 1, a2 = this.encodeToCodewords(e2.toString()), s2 = !t3.hasMoreCharacters() && i2 <= 2;
      if (i2 <= 2)
        t3.updateSymbolInfo(t3.getCodewordCount() + i2), (n2 = t3.getSymbolInfo().getDataCapacity() - t3.getCodewordCount()) >= 3 && (s2 = false, t3.updateSymbolInfo(t3.getCodewordCount() + a2.length));
      s2 ? (t3.resetSymbolInfo(), t3.pos -= i2) : t3.writeCodewords(a2);
    } finally {
      t3.signalEncoderChange(0);
    }
  }, t2.prototype.encodeChar = function(t3, e2) {
    t3 >= " ".charCodeAt(0) && t3 <= "?".charCodeAt(0) ? e2.append(t3) : t3 >= "@".charCodeAt(0) && t3 <= "^".charCodeAt(0) ? e2.append(q.getCharAt(t3 - 64)) : si.illegalCharacter(q.getCharAt(t3));
  }, t2.prototype.encodeToCodewords = function(t3) {
    var e2 = t3.length;
    if (0 === e2)
      throw new Error("StringBuilder must not be empty");
    var r2 = (t3.charAt(0).charCodeAt(0) << 18) + ((e2 >= 2 ? t3.charAt(1).charCodeAt(0) : 0) << 12) + ((e2 >= 3 ? t3.charAt(2).charCodeAt(0) : 0) << 6) + (e2 >= 4 ? t3.charAt(3).charCodeAt(0) : 0), n2 = r2 >> 16 & 255, o2 = r2 >> 8 & 255, i2 = 255 & r2, a2 = new Q();
    return a2.append(n2), e2 >= 2 && a2.append(o2), e2 >= 3 && a2.append(i2), a2.toString();
  }, t2;
}();
var qo = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Qo = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Jo = function() {
  function t2(t3, e2, r2, n2, o2, i2, a2, s2) {
    void 0 === a2 && (a2 = 0), void 0 === s2 && (s2 = 0), this.rectangular = t3, this.dataCapacity = e2, this.errorCodewords = r2, this.matrixWidth = n2, this.matrixHeight = o2, this.dataRegions = i2, this.rsBlockData = a2, this.rsBlockError = s2;
  }
  return t2.lookup = function(t3, e2, r2, n2, o2) {
    var i2, a2;
    void 0 === e2 && (e2 = 0), void 0 === r2 && (r2 = null), void 0 === n2 && (n2 = null), void 0 === o2 && (o2 = true);
    try {
      for (var s2 = Qo(ti), u2 = s2.next(); !u2.done; u2 = s2.next()) {
        var c2 = u2.value;
        if ((1 !== e2 || !c2.rectangular) && ((2 !== e2 || c2.rectangular) && (null == r2 || !(c2.getSymbolWidth() < r2.getWidth() || c2.getSymbolHeight() < r2.getHeight())) && (null == n2 || !(c2.getSymbolWidth() > n2.getWidth() || c2.getSymbolHeight() > n2.getHeight())) && t3 <= c2.dataCapacity))
          return c2;
      }
    } catch (t4) {
      i2 = { error: t4 };
    } finally {
      try {
        u2 && !u2.done && (a2 = s2.return) && a2.call(s2);
      } finally {
        if (i2)
          throw i2.error;
      }
    }
    if (o2)
      throw new Error("Can't find a symbol arrangement that matches the message. Data codewords: " + t3);
    return null;
  }, t2.prototype.getHorizontalDataRegions = function() {
    switch (this.dataRegions) {
      case 1:
        return 1;
      case 2:
      case 4:
        return 2;
      case 16:
        return 4;
      case 36:
        return 6;
      default:
        throw new Error("Cannot handle this number of data regions");
    }
  }, t2.prototype.getVerticalDataRegions = function() {
    switch (this.dataRegions) {
      case 1:
      case 2:
        return 1;
      case 4:
        return 2;
      case 16:
        return 4;
      case 36:
        return 6;
      default:
        throw new Error("Cannot handle this number of data regions");
    }
  }, t2.prototype.getSymbolDataWidth = function() {
    return this.getHorizontalDataRegions() * this.matrixWidth;
  }, t2.prototype.getSymbolDataHeight = function() {
    return this.getVerticalDataRegions() * this.matrixHeight;
  }, t2.prototype.getSymbolWidth = function() {
    return this.getSymbolDataWidth() + 2 * this.getHorizontalDataRegions();
  }, t2.prototype.getSymbolHeight = function() {
    return this.getSymbolDataHeight() + 2 * this.getVerticalDataRegions();
  }, t2.prototype.getCodewordCount = function() {
    return this.dataCapacity + this.errorCodewords;
  }, t2.prototype.getInterleavedBlockCount = function() {
    return this.rsBlockData ? this.dataCapacity / this.rsBlockData : 1;
  }, t2.prototype.getDataCapacity = function() {
    return this.dataCapacity;
  }, t2.prototype.getErrorCodewords = function() {
    return this.errorCodewords;
  }, t2.prototype.getDataLengthForInterleavedBlock = function(t3) {
    return this.rsBlockData;
  }, t2.prototype.getErrorLengthForInterleavedBlock = function(t3) {
    return this.rsBlockError;
  }, t2;
}();
var $o = function(t2) {
  function e2() {
    return t2.call(this, false, 1558, 620, 22, 22, 36, -1, 62) || this;
  }
  return qo(e2, t2), e2.prototype.getInterleavedBlockCount = function() {
    return 10;
  }, e2.prototype.getDataLengthForInterleavedBlock = function(t3) {
    return t3 <= 8 ? 156 : 155;
  }, e2;
}(Jo);
var ti = [new Jo(false, 3, 5, 8, 8, 1), new Jo(false, 5, 7, 10, 10, 1), new Jo(true, 5, 7, 16, 6, 1), new Jo(false, 8, 10, 12, 12, 1), new Jo(true, 10, 11, 14, 6, 2), new Jo(false, 12, 12, 14, 14, 1), new Jo(true, 16, 14, 24, 10, 1), new Jo(false, 18, 14, 16, 16, 1), new Jo(false, 22, 18, 18, 18, 1), new Jo(true, 22, 18, 16, 10, 2), new Jo(false, 30, 20, 20, 20, 1), new Jo(true, 32, 24, 16, 14, 2), new Jo(false, 36, 24, 22, 22, 1), new Jo(false, 44, 28, 24, 24, 1), new Jo(true, 49, 28, 22, 14, 2), new Jo(false, 62, 36, 14, 14, 4), new Jo(false, 86, 42, 16, 16, 4), new Jo(false, 114, 48, 18, 18, 4), new Jo(false, 144, 56, 20, 20, 4), new Jo(false, 174, 68, 22, 22, 4), new Jo(false, 204, 84, 24, 24, 4, 102, 42), new Jo(false, 280, 112, 14, 14, 16, 140, 56), new Jo(false, 368, 144, 16, 16, 16, 92, 36), new Jo(false, 456, 192, 18, 18, 16, 114, 48), new Jo(false, 576, 224, 20, 20, 16, 144, 56), new Jo(false, 696, 272, 22, 22, 16, 174, 68), new Jo(false, 816, 336, 24, 24, 16, 136, 56), new Jo(false, 1050, 408, 18, 18, 36, 175, 68), new Jo(false, 1304, 496, 20, 20, 36, 163, 62), new $o()];
var ei = function() {
  function t2(t3) {
    this.msg = t3, this.pos = 0, this.skipAtEnd = 0;
    for (var e2 = t3.split("").map(function(t4) {
      return t4.charCodeAt(0);
    }), r2 = new Q(), n2 = 0, o2 = e2.length; n2 < o2; n2++) {
      var i2 = String.fromCharCode(255 & e2[n2]);
      if ("?" === i2 && "?" !== t3.charAt(n2))
        throw new Error("Message contains characters outside ISO-8859-1 encoding.");
      r2.append(i2);
    }
    this.msg = r2.toString(), this.shape = 0, this.codewords = new Q(), this.newEncoding = -1;
  }
  return t2.prototype.setSymbolShape = function(t3) {
    this.shape = t3;
  }, t2.prototype.setSizeConstraints = function(t3, e2) {
    this.minSize = t3, this.maxSize = e2;
  }, t2.prototype.getMessage = function() {
    return this.msg;
  }, t2.prototype.setSkipAtEnd = function(t3) {
    this.skipAtEnd = t3;
  }, t2.prototype.getCurrentChar = function() {
    return this.msg.charCodeAt(this.pos);
  }, t2.prototype.getCurrent = function() {
    return this.msg.charCodeAt(this.pos);
  }, t2.prototype.getCodewords = function() {
    return this.codewords;
  }, t2.prototype.writeCodewords = function(t3) {
    this.codewords.append(t3);
  }, t2.prototype.writeCodeword = function(t3) {
    this.codewords.append(t3);
  }, t2.prototype.getCodewordCount = function() {
    return this.codewords.length();
  }, t2.prototype.getNewEncoding = function() {
    return this.newEncoding;
  }, t2.prototype.signalEncoderChange = function(t3) {
    this.newEncoding = t3;
  }, t2.prototype.resetEncoderSignal = function() {
    this.newEncoding = -1;
  }, t2.prototype.hasMoreCharacters = function() {
    return this.pos < this.getTotalMessageCharCount();
  }, t2.prototype.getTotalMessageCharCount = function() {
    return this.msg.length - this.skipAtEnd;
  }, t2.prototype.getRemainingCharacters = function() {
    return this.getTotalMessageCharCount() - this.pos;
  }, t2.prototype.getSymbolInfo = function() {
    return this.symbolInfo;
  }, t2.prototype.updateSymbolInfo = function(t3) {
    void 0 === t3 && (t3 = this.getCodewordCount()), (null == this.symbolInfo || t3 > this.symbolInfo.getDataCapacity()) && (this.symbolInfo = Jo.lookup(t3, this.shape, this.minSize, this.maxSize, true));
  }, t2.prototype.resetSymbolInfo = function() {
    this.symbolInfo = null;
  }, t2;
}();
var ri = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ni = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return ri(e2, t2), e2.prototype.getEncodingMode = function() {
    return 3;
  }, e2.prototype.encode = function(t3) {
    for (var e3 = new Q(); t3.hasMoreCharacters(); ) {
      var r2 = t3.getCurrentChar();
      if (t3.pos++, this.encodeChar(r2, e3), e3.length() % 3 == 0) {
        if (this.writeNextTriplet(t3, e3), si.lookAheadTest(t3.getMessage(), t3.pos, this.getEncodingMode()) !== this.getEncodingMode()) {
          t3.signalEncoderChange(0);
          break;
        }
      }
    }
    this.handleEOD(t3, e3);
  }, e2.prototype.encodeChar = function(t3, e3) {
    switch (t3) {
      case 13:
        e3.append(0);
        break;
      case "*".charCodeAt(0):
        e3.append(1);
        break;
      case ">".charCodeAt(0):
        e3.append(2);
        break;
      case " ".charCodeAt(0):
        e3.append(3);
        break;
      default:
        t3 >= "0".charCodeAt(0) && t3 <= "9".charCodeAt(0) ? e3.append(t3 - 48 + 4) : t3 >= "A".charCodeAt(0) && t3 <= "Z".charCodeAt(0) ? e3.append(t3 - 65 + 14) : si.illegalCharacter(q.getCharAt(t3));
    }
    return 1;
  }, e2.prototype.handleEOD = function(t3, e3) {
    t3.updateSymbolInfo();
    var r2 = t3.getSymbolInfo().getDataCapacity() - t3.getCodewordCount(), n2 = e3.length();
    t3.pos -= n2, (t3.getRemainingCharacters() > 1 || r2 > 1 || t3.getRemainingCharacters() !== r2) && t3.writeCodeword(254), t3.getNewEncoding() < 0 && t3.signalEncoderChange(0);
  }, e2;
}(Zo);
var oi = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var ii = function(t2) {
  function e2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return oi(e2, t2), e2.prototype.getEncodingMode = function() {
    return 2;
  }, e2.prototype.encodeChar = function(t3, e3) {
    if (t3 === " ".charCodeAt(0))
      return e3.append(3), 1;
    if (t3 >= "0".charCodeAt(0) && t3 <= "9".charCodeAt(0))
      return e3.append(t3 - 48 + 4), 1;
    if (t3 >= "a".charCodeAt(0) && t3 <= "z".charCodeAt(0))
      return e3.append(t3 - 97 + 14), 1;
    if (t3 < " ".charCodeAt(0))
      return e3.append(0), e3.append(t3), 2;
    if (t3 <= "/".charCodeAt(0))
      return e3.append(1), e3.append(t3 - 33), 2;
    if (t3 <= "@".charCodeAt(0))
      return e3.append(1), e3.append(t3 - 58 + 15), 2;
    if (t3 >= "[".charCodeAt(0) && t3 <= "_".charCodeAt(0))
      return e3.append(1), e3.append(t3 - 91 + 22), 2;
    if (t3 === "`".charCodeAt(0))
      return e3.append(2), e3.append(0), 2;
    if (t3 <= "Z".charCodeAt(0))
      return e3.append(2), e3.append(t3 - 65 + 1), 2;
    if (t3 <= 127)
      return e3.append(2), e3.append(t3 - 123 + 27), 2;
    e3.append("1");
    var r2 = 2;
    return r2 += this.encodeChar(t3 - 128, e3);
  }, e2;
}(Zo);
var ai = function() {
  function t2() {
  }
  return t2.randomize253State = function(t3) {
    var e2 = 129 + (149 * t3 % 253 + 1);
    return e2 <= 254 ? e2 : e2 - 254;
  }, t2.encodeHighLevel = function(t3, e2, r2, n2, o2) {
    void 0 === e2 && (e2 = 0), void 0 === r2 && (r2 = null), void 0 === n2 && (n2 = null), void 0 === o2 && (o2 = false);
    var i2 = new Zo(), a2 = [new jo(), i2, new ii(), new ni(), new Ko(), new Yo()], s2 = new ei(t3);
    s2.setSymbolShape(e2), s2.setSizeConstraints(r2, n2), t3.startsWith(Wo) && t3.endsWith("") ? (s2.writeCodeword(236), s2.setSkipAtEnd(2), s2.pos += 7) : t3.startsWith(zo) && t3.endsWith("") && (s2.writeCodeword(237), s2.setSkipAtEnd(2), s2.pos += 7);
    var u2 = 0;
    for (o2 && (i2.encodeMaximal(s2), u2 = s2.getNewEncoding(), s2.resetEncoderSignal()); s2.hasMoreCharacters(); )
      a2[u2].encode(s2), s2.getNewEncoding() >= 0 && (u2 = s2.getNewEncoding(), s2.resetEncoderSignal());
    var c2 = s2.getCodewordCount();
    s2.updateSymbolInfo();
    var f3 = s2.getSymbolInfo().getDataCapacity();
    c2 < f3 && 0 !== u2 && 5 !== u2 && 4 !== u2 && s2.writeCodeword("\xFE");
    var h2 = s2.getCodewords();
    for (h2.length() < f3 && h2.append(129); h2.length() < f3; )
      h2.append(this.randomize253State(h2.length() + 1));
    return s2.getCodewords().toString();
  }, t2.lookAheadTest = function(t3, e2, r2) {
    var n2 = this.lookAheadTestIntern(t3, e2, r2);
    if (3 === r2 && 3 === n2) {
      for (var o2 = Math.min(e2 + 3, t3.length), i2 = e2; i2 < o2; i2++)
        if (!this.isNativeX12(t3.charCodeAt(i2)))
          return 0;
    } else if (4 === r2 && 4 === n2) {
      for (o2 = Math.min(e2 + 4, t3.length), i2 = e2; i2 < o2; i2++)
        if (!this.isNativeEDIFACT(t3.charCodeAt(i2)))
          return 0;
    }
    return n2;
  }, t2.lookAheadTestIntern = function(t3, e2, r2) {
    if (e2 >= t3.length)
      return r2;
    var n2;
    0 === r2 ? n2 = [0, 1, 1, 1, 1, 1.25] : (n2 = [1, 2, 2, 2, 2, 2.25])[r2] = 0;
    for (var o2 = 0, i2 = new Uint8Array(6), a2 = []; ; ) {
      if (e2 + o2 === t3.length) {
        k.fill(i2, 0), k.fill(a2, 0);
        var s2 = this.findMinimums(n2, a2, x.MAX_VALUE, i2), u2 = this.getMinimumCount(i2);
        if (a2[0] === s2)
          return 0;
        if (1 === u2) {
          if (i2[5] > 0)
            return 5;
          if (i2[4] > 0)
            return 4;
          if (i2[2] > 0)
            return 2;
          if (i2[3] > 0)
            return 3;
        }
        return 1;
      }
      var c2 = t3.charCodeAt(e2 + o2);
      if (o2++, this.isDigit(c2) ? n2[0] += 0.5 : this.isExtendedASCII(c2) ? (n2[0] = Math.ceil(n2[0]), n2[0] += 2) : (n2[0] = Math.ceil(n2[0]), n2[0]++), this.isNativeC40(c2) ? n2[1] += 2 / 3 : this.isExtendedASCII(c2) ? n2[1] += 8 / 3 : n2[1] += 4 / 3, this.isNativeText(c2) ? n2[2] += 2 / 3 : this.isExtendedASCII(c2) ? n2[2] += 8 / 3 : n2[2] += 4 / 3, this.isNativeX12(c2) ? n2[3] += 2 / 3 : this.isExtendedASCII(c2) ? n2[3] += 13 / 3 : n2[3] += 10 / 3, this.isNativeEDIFACT(c2) ? n2[4] += 3 / 4 : this.isExtendedASCII(c2) ? n2[4] += 4.25 : n2[4] += 3.25, this.isSpecialB256(c2) ? n2[5] += 4 : n2[5]++, o2 >= 4) {
        if (k.fill(i2, 0), k.fill(a2, 0), this.findMinimums(n2, a2, x.MAX_VALUE, i2), a2[0] < this.min(a2[5], a2[1], a2[2], a2[3], a2[4]))
          return 0;
        if (a2[5] < a2[0] || a2[5] + 1 < this.min(a2[1], a2[2], a2[3], a2[4]))
          return 5;
        if (a2[4] + 1 < this.min(a2[5], a2[1], a2[2], a2[3], a2[0]))
          return 4;
        if (a2[2] + 1 < this.min(a2[5], a2[1], a2[4], a2[3], a2[0]))
          return 2;
        if (a2[3] + 1 < this.min(a2[5], a2[1], a2[4], a2[2], a2[0]))
          return 3;
        if (a2[1] + 1 < this.min(a2[0], a2[5], a2[4], a2[2])) {
          if (a2[1] < a2[3])
            return 1;
          if (a2[1] === a2[3]) {
            for (var f3 = e2 + o2 + 1; f3 < t3.length; ) {
              var h2 = t3.charCodeAt(f3);
              if (this.isX12TermSep(h2))
                return 3;
              if (!this.isNativeX12(h2))
                break;
              f3++;
            }
            return 1;
          }
        }
      }
    }
  }, t2.min = function(t3, e2, r2, n2, o2) {
    var i2 = Math.min(t3, Math.min(e2, Math.min(r2, n2)));
    return void 0 === o2 ? i2 : Math.min(i2, o2);
  }, t2.findMinimums = function(t3, e2, r2, n2) {
    for (var o2 = 0; o2 < 6; o2++) {
      var i2 = e2[o2] = Math.ceil(t3[o2]);
      r2 > i2 && (r2 = i2, k.fill(n2, 0)), r2 === i2 && (n2[o2] = n2[o2] + 1);
    }
    return r2;
  }, t2.getMinimumCount = function(t3) {
    for (var e2 = 0, r2 = 0; r2 < 6; r2++)
      e2 += t3[r2];
    return e2 || 0;
  }, t2.isDigit = function(t3) {
    return t3 >= "0".charCodeAt(0) && t3 <= "9".charCodeAt(0);
  }, t2.isExtendedASCII = function(t3) {
    return t3 >= 128 && t3 <= 255;
  }, t2.isNativeC40 = function(t3) {
    return t3 === " ".charCodeAt(0) || t3 >= "0".charCodeAt(0) && t3 <= "9".charCodeAt(0) || t3 >= "A".charCodeAt(0) && t3 <= "Z".charCodeAt(0);
  }, t2.isNativeText = function(t3) {
    return t3 === " ".charCodeAt(0) || t3 >= "0".charCodeAt(0) && t3 <= "9".charCodeAt(0) || t3 >= "a".charCodeAt(0) && t3 <= "z".charCodeAt(0);
  }, t2.isNativeX12 = function(t3) {
    return this.isX12TermSep(t3) || t3 === " ".charCodeAt(0) || t3 >= "0".charCodeAt(0) && t3 <= "9".charCodeAt(0) || t3 >= "A".charCodeAt(0) && t3 <= "Z".charCodeAt(0);
  }, t2.isX12TermSep = function(t3) {
    return 13 === t3 || t3 === "*".charCodeAt(0) || t3 === ">".charCodeAt(0);
  }, t2.isNativeEDIFACT = function(t3) {
    return t3 >= " ".charCodeAt(0) && t3 <= "^".charCodeAt(0);
  }, t2.isSpecialB256 = function(t3) {
    return false;
  }, t2.determineConsecutiveDigitCount = function(t3, e2) {
    void 0 === e2 && (e2 = 0);
    for (var r2 = t3.length, n2 = e2; n2 < r2 && this.isDigit(t3.charCodeAt(n2)); )
      n2++;
    return n2 - e2;
  }, t2.illegalCharacter = function(t3) {
    var e2 = x.toHexString(t3.charCodeAt(0));
    throw e2 = "0000".substring(0, 4 - e2.length) + e2, new Error("Illegal character: " + t3 + " (0x" + e2 + ")");
  }, t2;
}();
var si = ai;
var ui = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ci = function() {
  function t2(t3) {
    this.charset = t3, this.name = t3.name;
  }
  return t2.prototype.canEncode = function(t3) {
    try {
      return null != K.encode(t3, this.charset);
    } catch (t4) {
      return false;
    }
  }, t2;
}();
var fi = function() {
  function t2(t3, e2, r2) {
    var n2, o2, i2, a2, s2, u2;
    this.ENCODERS = ["IBM437", "ISO-8859-2", "ISO-8859-3", "ISO-8859-4", "ISO-8859-5", "ISO-8859-6", "ISO-8859-7", "ISO-8859-8", "ISO-8859-9", "ISO-8859-10", "ISO-8859-11", "ISO-8859-13", "ISO-8859-14", "ISO-8859-15", "ISO-8859-16", "windows-1250", "windows-1251", "windows-1252", "windows-1256", "Shift_JIS"].map(function(t4) {
      return new ci(Uo.forName(t4));
    }), this.encoders = [];
    var c2 = [];
    c2.push(new ci(Xo.ISO_8859_1));
    for (var f3 = null != e2 && e2.name.startsWith("UTF"), h2 = 0; h2 < t3.length; h2++) {
      var l2 = false;
      try {
        for (var d2 = (n2 = void 0, ui(c2)), p2 = d2.next(); !p2.done; p2 = d2.next()) {
          var g2 = p2.value, y2 = t3.charAt(h2);
          if (y2.charCodeAt(0) === r2 || g2.canEncode(y2)) {
            l2 = true;
            break;
          }
        }
      } catch (t4) {
        n2 = { error: t4 };
      } finally {
        try {
          p2 && !p2.done && (o2 = d2.return) && o2.call(d2);
        } finally {
          if (n2)
            throw n2.error;
        }
      }
      if (!l2)
        try {
          for (var w2 = (i2 = void 0, ui(this.ENCODERS)), v2 = w2.next(); !v2.done; v2 = w2.next()) {
            if ((g2 = v2.value).canEncode(t3.charAt(h2))) {
              c2.push(g2), l2 = true;
              break;
            }
          }
        } catch (t4) {
          i2 = { error: t4 };
        } finally {
          try {
            v2 && !v2.done && (a2 = w2.return) && a2.call(w2);
          } finally {
            if (i2)
              throw i2.error;
          }
        }
      l2 || (f3 = true);
    }
    if (1 !== c2.length || f3) {
      this.encoders = [];
      var _2 = 0;
      try {
        for (var A2 = ui(c2), C2 = A2.next(); !C2.done; C2 = A2.next()) {
          g2 = C2.value;
          this.encoders[_2++] = g2;
        }
      } catch (t4) {
        s2 = { error: t4 };
      } finally {
        try {
          C2 && !C2.done && (u2 = A2.return) && u2.call(A2);
        } finally {
          if (s2)
            throw s2.error;
        }
      }
    } else
      this.encoders = [c2[0]];
    var m2 = -1;
    if (null != e2) {
      for (h2 = 0; h2 < this.encoders.length; h2++)
        if (null != this.encoders[h2] && e2.name === this.encoders[h2].name) {
          m2 = h2;
          break;
        }
    }
    this.priorityEncoderIndex = m2;
  }
  return t2.prototype.length = function() {
    return this.encoders.length;
  }, t2.prototype.getCharsetName = function(t3) {
    if (!(t3 < this.length()))
      throw new Error("index must be less than length");
    return this.encoders[t3].name;
  }, t2.prototype.getCharset = function(t3) {
    if (!(t3 < this.length()))
      throw new Error("index must be less than length");
    return this.encoders[t3].charset;
  }, t2.prototype.getECIValue = function(t3) {
    return this.encoders[t3].charset.getValueIdentifier();
  }, t2.prototype.getPriorityEncoderIndex = function() {
    return this.priorityEncoderIndex;
  }, t2.prototype.canEncode = function(t3, e2) {
    if (!(e2 < this.length()))
      throw new Error("index must be less than length");
    return true;
  }, t2.prototype.encode = function(t3, e2) {
    if (!(e2 < this.length()))
      throw new Error("index must be less than length");
    return K.encode(q.getCharAt(t3), this.encoders[e2].name);
  }, t2;
}();
var hi = function() {
  function t2(t3, e2, r2) {
    this.fnc1 = r2;
    var n2 = new fi(t3, e2, r2);
    if (1 === n2.length())
      for (var o2 = 0; o2 < this.bytes.length; o2++) {
        var i2 = t3.charAt(o2).charCodeAt(0);
        this.bytes[o2] = i2 === r2 ? 1e3 : i2;
      }
    else
      this.bytes = this.encodeMinimally(t3, n2, r2);
  }
  return t2.prototype.getFNC1Character = function() {
    return this.fnc1;
  }, t2.prototype.length = function() {
    return this.bytes.length;
  }, t2.prototype.haveNCharacters = function(t3, e2) {
    if (t3 + e2 - 1 >= this.bytes.length)
      return false;
    for (var r2 = 0; r2 < e2; r2++)
      if (this.isECI(t3 + r2))
        return false;
    return true;
  }, t2.prototype.charAt = function(t3) {
    if (t3 < 0 || t3 >= this.length())
      throw new Error("" + t3);
    if (this.isECI(t3))
      throw new Error("value at " + t3 + " is not a character but an ECI");
    return this.isFNC1(t3) ? this.fnc1 : this.bytes[t3];
  }, t2.prototype.subSequence = function(t3, e2) {
    if (t3 < 0 || t3 > e2 || e2 > this.length())
      throw new Error("" + t3);
    for (var r2 = new Q(), n2 = t3; n2 < e2; n2++) {
      if (this.isECI(n2))
        throw new Error("value at " + n2 + " is not a character but an ECI");
      r2.append(this.charAt(n2));
    }
    return r2.toString();
  }, t2.prototype.isECI = function(t3) {
    if (t3 < 0 || t3 >= this.length())
      throw new Error("" + t3);
    return this.bytes[t3] > 255 && this.bytes[t3] <= 999;
  }, t2.prototype.isFNC1 = function(t3) {
    if (t3 < 0 || t3 >= this.length())
      throw new Error("" + t3);
    return 1e3 === this.bytes[t3];
  }, t2.prototype.getECIValue = function(t3) {
    if (t3 < 0 || t3 >= this.length())
      throw new Error("" + t3);
    if (!this.isECI(t3))
      throw new Error("value at " + t3 + " is not an ECI but a character");
    return this.bytes[t3] - 256;
  }, t2.prototype.addEdge = function(t3, e2, r2) {
    (null == t3[e2][r2.encoderIndex] || t3[e2][r2.encoderIndex].cachedTotalSize > r2.cachedTotalSize) && (t3[e2][r2.encoderIndex] = r2);
  }, t2.prototype.addEdges = function(t3, e2, r2, n2, o2, i2) {
    var a2 = t3.charAt(n2).charCodeAt(0), s2 = 0, u2 = e2.length();
    e2.getPriorityEncoderIndex() >= 0 && (a2 === i2 || e2.canEncode(a2, e2.getPriorityEncoderIndex())) && (u2 = (s2 = e2.getPriorityEncoderIndex()) + 1);
    for (var c2 = s2; c2 < u2; c2++)
      (a2 === i2 || e2.canEncode(a2, c2)) && this.addEdge(r2, n2 + 1, new li(a2, e2, c2, o2, i2));
  }, t2.prototype.encodeMinimally = function(t3, e2, r2) {
    var n2 = t3.length, o2 = new li[n2 + 1][e2.length()]();
    this.addEdges(t3, e2, o2, 0, null, r2);
    for (var i2 = 1; i2 <= n2; i2++) {
      for (var a2 = 0; a2 < e2.length(); a2++)
        null != o2[i2][a2] && i2 < n2 && this.addEdges(t3, e2, o2, i2, o2[i2][a2], r2);
      for (a2 = 0; a2 < e2.length(); a2++)
        o2[i2 - 1][a2] = null;
    }
    var s2 = -1, u2 = x.MAX_VALUE;
    for (a2 = 0; a2 < e2.length(); a2++)
      if (null != o2[n2][a2]) {
        var c2 = o2[n2][a2];
        c2.cachedTotalSize < u2 && (u2 = c2.cachedTotalSize, s2 = a2);
      }
    if (s2 < 0)
      throw new Error('Failed to encode "' + t3 + '"');
    for (var f3 = [], h2 = o2[n2][s2]; null != h2; ) {
      if (h2.isFNC1())
        f3.unshift(1e3);
      else {
        var l2 = e2.encode(h2.c, h2.encoderIndex);
        for (i2 = l2.length - 1; i2 >= 0; i2--)
          f3.unshift(255 & l2[i2]);
      }
      (null === h2.previous ? 0 : h2.previous.encoderIndex) !== h2.encoderIndex && f3.unshift(256 + e2.getECIValue(h2.encoderIndex)), h2 = h2.previous;
    }
    var d2 = [];
    for (i2 = 0; i2 < d2.length; i2++)
      d2[i2] = f3[i2];
    return d2;
  }, t2;
}();
var li = function() {
  function t2(t3, e2, r2, n2, o2) {
    this.c = t3, this.encoderSet = e2, this.encoderIndex = r2, this.previous = n2, this.fnc1 = o2, this.c = t3 === o2 ? 1e3 : t3;
    var i2 = this.isFNC1() ? 1 : e2.encode(t3, r2).length;
    (null === n2 ? 0 : n2.encoderIndex) !== r2 && (i2 += 3), null != n2 && (i2 += n2.cachedTotalSize), this.cachedTotalSize = i2;
  }
  return t2.prototype.isFNC1 = function() {
    return 1e3 === this.c;
  }, t2;
}();
var di = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
!function(t2) {
  t2[t2.ASCII = 0] = "ASCII", t2[t2.C40 = 1] = "C40", t2[t2.TEXT = 2] = "TEXT", t2[t2.X12 = 3] = "X12", t2[t2.EDF = 4] = "EDF", t2[t2.B256 = 5] = "B256";
}(Go || (Go = {})), function(t2) {
  function e2(e3, r2, n2, o2, i2) {
    var a2 = t2.call(this, e3, r2, n2) || this;
    return a2.shape = o2, a2.macroId = i2, a2;
  }
  di(e2, t2), e2.prototype.getMacroId = function() {
    return this.macroId;
  }, e2.prototype.getShapeHint = function() {
    return this.shape;
  };
}(hi);
var pi = function() {
  function t2() {
  }
  return t2.prototype.isCompact = function() {
    return this.compact;
  }, t2.prototype.setCompact = function(t3) {
    this.compact = t3;
  }, t2.prototype.getSize = function() {
    return this.size;
  }, t2.prototype.setSize = function(t3) {
    this.size = t3;
  }, t2.prototype.getLayers = function() {
    return this.layers;
  }, t2.prototype.setLayers = function(t3) {
    this.layers = t3;
  }, t2.prototype.getCodeWords = function() {
    return this.codeWords;
  }, t2.prototype.setCodeWords = function(t3) {
    this.codeWords = t3;
  }, t2.prototype.getMatrix = function() {
    return this.matrix;
  }, t2.prototype.setMatrix = function(t3) {
    this.matrix = t3;
  }, t2;
}();
var gi = function() {
  function t2() {
  }
  return t2.singletonList = function(t3) {
    return [t3];
  }, t2.min = function(t3, e2) {
    return t3.sort(e2)[0];
  }, t2;
}();
var yi = function() {
  function t2(t3) {
    this.previous = t3;
  }
  return t2.prototype.getPrevious = function() {
    return this.previous;
  }, t2;
}();
var wi = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var vi = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this, e3) || this;
    return o2.value = r2, o2.bitCount = n2, o2;
  }
  return wi(e2, t2), e2.prototype.appendTo = function(t3, e3) {
    t3.appendBits(this.value, this.bitCount);
  }, e2.prototype.add = function(t3, r2) {
    return new e2(this, t3, r2);
  }, e2.prototype.addBinaryShift = function(t3, r2) {
    return console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token"), new e2(this, t3, r2);
  }, e2.prototype.toString = function() {
    var t3 = this.value & (1 << this.bitCount) - 1;
    return t3 |= 1 << this.bitCount, "<" + x.toBinaryString(t3 | 1 << this.bitCount).substring(1) + ">";
  }, e2;
}(yi);
var _i = function() {
  var t2 = function(e2, r2) {
    return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
      t3.__proto__ = e3;
    } || function(t3, e3) {
      for (var r3 in e3)
        e3.hasOwnProperty(r3) && (t3[r3] = e3[r3]);
    }, t2(e2, r2);
  };
  return function(e2, r2) {
    function n2() {
      this.constructor = e2;
    }
    t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
  };
}();
var Ai = function(t2) {
  function e2(e3, r2, n2) {
    var o2 = t2.call(this, e3, 0, 0) || this;
    return o2.binaryShiftStart = r2, o2.binaryShiftByteCount = n2, o2;
  }
  return _i(e2, t2), e2.prototype.appendTo = function(t3, e3) {
    for (var r2 = 0; r2 < this.binaryShiftByteCount; r2++)
      (0 === r2 || 31 === r2 && this.binaryShiftByteCount <= 62) && (t3.appendBits(31, 5), this.binaryShiftByteCount > 62 ? t3.appendBits(this.binaryShiftByteCount - 31, 16) : 0 === r2 ? t3.appendBits(Math.min(this.binaryShiftByteCount, 31), 5) : t3.appendBits(this.binaryShiftByteCount - 31, 5)), t3.appendBits(e3[this.binaryShiftStart + r2], 8);
  }, e2.prototype.addBinaryShift = function(t3, r2) {
    return new e2(this, t3, r2);
  }, e2.prototype.toString = function() {
    return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
  }, e2;
}(vi);
function Ci(t2, e2, r2) {
  return new vi(t2, e2, r2);
}
var mi = ["UPPER", "LOWER", "DIGIT", "MIXED", "PUNCT"];
var Ei = new vi(null, 0, 0);
var Ii = [Int32Array.from([0, 327708, 327710, 327709, 656318]), Int32Array.from([590318, 0, 327710, 327709, 656318]), Int32Array.from([262158, 590300, 0, 590301, 932798]), Int32Array.from([327709, 327708, 656318, 0, 327710]), Int32Array.from([327711, 656380, 656382, 656381, 0])];
var Si = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Ti = function(t2) {
  var e2, r2;
  try {
    for (var n2 = Si(t2), o2 = n2.next(); !o2.done; o2 = n2.next()) {
      var i2 = o2.value;
      k.fill(i2, -1);
    }
  } catch (t3) {
    e2 = { error: t3 };
  } finally {
    try {
      o2 && !o2.done && (r2 = n2.return) && r2.call(n2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return t2[0][4] = 0, t2[1][4] = 0, t2[1][0] = 28, t2[3][4] = 0, t2[2][4] = 0, t2[2][0] = 15, t2;
}(k.createInt32Array(6, 6));
var Oi = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var bi = function() {
  function t2(t3, e2, r2, n2) {
    this.token = t3, this.mode = e2, this.binaryShiftByteCount = r2, this.bitCount = n2;
  }
  return t2.prototype.getMode = function() {
    return this.mode;
  }, t2.prototype.getToken = function() {
    return this.token;
  }, t2.prototype.getBinaryShiftByteCount = function() {
    return this.binaryShiftByteCount;
  }, t2.prototype.getBitCount = function() {
    return this.bitCount;
  }, t2.prototype.latchAndAppend = function(e2, r2) {
    var n2 = this.bitCount, o2 = this.token;
    if (e2 !== this.mode) {
      var i2 = Ii[this.mode][e2];
      o2 = Ci(o2, 65535 & i2, i2 >> 16), n2 += i2 >> 16;
    }
    var a2 = 2 === e2 ? 4 : 5;
    return new t2(o2 = Ci(o2, r2, a2), e2, 0, n2 + a2);
  }, t2.prototype.shiftAndAppend = function(e2, r2) {
    var n2 = this.token, o2 = 2 === this.mode ? 4 : 5;
    return n2 = Ci(n2, Ti[this.mode][e2], o2), new t2(n2 = Ci(n2, r2, 5), this.mode, 0, this.bitCount + o2 + 5);
  }, t2.prototype.addBinaryShiftChar = function(e2) {
    var r2 = this.token, n2 = this.mode, o2 = this.bitCount;
    if (4 === this.mode || 2 === this.mode) {
      var i2 = Ii[n2][0];
      r2 = Ci(r2, 65535 & i2, i2 >> 16), o2 += i2 >> 16, n2 = 0;
    }
    var a2 = 0 === this.binaryShiftByteCount || 31 === this.binaryShiftByteCount ? 18 : 62 === this.binaryShiftByteCount ? 9 : 8, s2 = new t2(r2, n2, this.binaryShiftByteCount + 1, o2 + a2);
    return 2078 === s2.binaryShiftByteCount && (s2 = s2.endBinaryShift(e2 + 1)), s2;
  }, t2.prototype.endBinaryShift = function(e2) {
    if (0 === this.binaryShiftByteCount)
      return this;
    var r2 = this.token;
    return new t2(r2 = function(t3, e3, r3) {
      return new Ai(t3, e3, r3);
    }(r2, e2 - this.binaryShiftByteCount, this.binaryShiftByteCount), this.mode, 0, this.bitCount);
  }, t2.prototype.isBetterThanOrEqualTo = function(e2) {
    var r2 = this.bitCount + (Ii[this.mode][e2.mode] >> 16);
    return this.binaryShiftByteCount < e2.binaryShiftByteCount ? r2 += t2.calculateBinaryShiftCost(e2) - t2.calculateBinaryShiftCost(this) : this.binaryShiftByteCount > e2.binaryShiftByteCount && e2.binaryShiftByteCount > 0 && (r2 += 10), r2 <= e2.bitCount;
  }, t2.prototype.toBitArray = function(t3) {
    for (var e2, r2, n2 = [], o2 = this.endBinaryShift(t3.length).token; null !== o2; o2 = o2.getPrevious())
      n2.unshift(o2);
    var i2 = new V();
    try {
      for (var a2 = Oi(n2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
        s2.value.appendTo(i2, t3);
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        s2 && !s2.done && (r2 = a2.return) && r2.call(a2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return i2;
  }, t2.prototype.toString = function() {
    return q.format("%s bits=%d bytes=%d", mi[this.mode], this.bitCount, this.binaryShiftByteCount);
  }, t2.calculateBinaryShiftCost = function(t3) {
    return t3.binaryShiftByteCount > 62 ? 21 : t3.binaryShiftByteCount > 31 ? 20 : t3.binaryShiftByteCount > 0 ? 10 : 0;
  }, t2.INITIAL_STATE = new t2(Ei, 0, 0, 0), t2;
}();
var Ri = function(t2) {
  var e2 = q.getCharCode(" "), r2 = q.getCharCode("."), n2 = q.getCharCode(",");
  t2[0][e2] = 1;
  for (var o2 = q.getCharCode("Z"), i2 = q.getCharCode("A"), a2 = i2; a2 <= o2; a2++)
    t2[0][a2] = a2 - i2 + 2;
  t2[1][e2] = 1;
  var s2 = q.getCharCode("z"), u2 = q.getCharCode("a");
  for (a2 = u2; a2 <= s2; a2++)
    t2[1][a2] = a2 - u2 + 2;
  t2[2][e2] = 1;
  var c2 = q.getCharCode("9"), f3 = q.getCharCode("0");
  for (a2 = f3; a2 <= c2; a2++)
    t2[2][a2] = a2 - f3 + 2;
  t2[2][n2] = 12, t2[2][r2] = 13;
  for (var h2 = ["\0", " ", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "\x1B", "", "", "", "", "@", "\\", "^", "_", "`", "|", "~", "\x7F"], l2 = 0; l2 < h2.length; l2++)
    t2[3][q.getCharCode(h2[l2])] = l2;
  var d2 = ["\0", "\r", "\0", "\0", "\0", "\0", "!", "'", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "[", "]", "{", "}"];
  for (l2 = 0; l2 < d2.length; l2++)
    q.getCharCode(d2[l2]) > 0 && (t2[4][q.getCharCode(d2[l2])] = l2);
  return t2;
}(k.createInt32Array(5, 256));
var Ni = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Di = function() {
  function t2(t3) {
    this.text = t3;
  }
  return t2.prototype.encode = function() {
    for (var e2 = q.getCharCode(" "), r2 = q.getCharCode("\n"), n2 = gi.singletonList(bi.INITIAL_STATE), o2 = 0; o2 < this.text.length; o2++) {
      var i2 = void 0, a2 = o2 + 1 < this.text.length ? this.text[o2 + 1] : 0;
      switch (this.text[o2]) {
        case q.getCharCode("\r"):
          i2 = a2 === r2 ? 2 : 0;
          break;
        case q.getCharCode("."):
          i2 = a2 === e2 ? 3 : 0;
          break;
        case q.getCharCode(","):
          i2 = a2 === e2 ? 4 : 0;
          break;
        case q.getCharCode(":"):
          i2 = a2 === e2 ? 5 : 0;
          break;
        default:
          i2 = 0;
      }
      i2 > 0 ? (n2 = t2.updateStateListForPair(n2, o2, i2), o2++) : n2 = this.updateStateListForChar(n2, o2);
    }
    return gi.min(n2, function(t3, e3) {
      return t3.getBitCount() - e3.getBitCount();
    }).toBitArray(this.text);
  }, t2.prototype.updateStateListForChar = function(e2, r2) {
    var n2, o2, i2 = [];
    try {
      for (var a2 = Ni(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
        var u2 = s2.value;
        this.updateStateForChar(u2, r2, i2);
      }
    } catch (t3) {
      n2 = { error: t3 };
    } finally {
      try {
        s2 && !s2.done && (o2 = a2.return) && o2.call(a2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    return t2.simplifyStates(i2);
  }, t2.prototype.updateStateForChar = function(t3, e2, r2) {
    for (var n2 = 255 & this.text[e2], o2 = Ri[t3.getMode()][n2] > 0, i2 = null, a2 = 0; a2 <= 4; a2++) {
      var s2 = Ri[a2][n2];
      if (s2 > 0) {
        if (null == i2 && (i2 = t3.endBinaryShift(e2)), !o2 || a2 === t3.getMode() || 2 === a2) {
          var u2 = i2.latchAndAppend(a2, s2);
          r2.push(u2);
        }
        if (!o2 && Ti[t3.getMode()][a2] >= 0) {
          var c2 = i2.shiftAndAppend(a2, s2);
          r2.push(c2);
        }
      }
    }
    if (t3.getBinaryShiftByteCount() > 0 || 0 === Ri[t3.getMode()][n2]) {
      var f3 = t3.addBinaryShiftChar(e2);
      r2.push(f3);
    }
  }, t2.updateStateListForPair = function(t3, e2, r2) {
    var n2, o2, i2 = [];
    try {
      for (var a2 = Ni(t3), s2 = a2.next(); !s2.done; s2 = a2.next()) {
        var u2 = s2.value;
        this.updateStateForPair(u2, e2, r2, i2);
      }
    } catch (t4) {
      n2 = { error: t4 };
    } finally {
      try {
        s2 && !s2.done && (o2 = a2.return) && o2.call(a2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    return this.simplifyStates(i2);
  }, t2.updateStateForPair = function(t3, e2, r2, n2) {
    var o2 = t3.endBinaryShift(e2);
    if (n2.push(o2.latchAndAppend(4, r2)), 4 !== t3.getMode() && n2.push(o2.shiftAndAppend(4, r2)), 3 === r2 || 4 === r2) {
      var i2 = o2.latchAndAppend(2, 16 - r2).latchAndAppend(2, 1);
      n2.push(i2);
    }
    if (t3.getBinaryShiftByteCount() > 0) {
      var a2 = t3.addBinaryShiftChar(e2).addBinaryShiftChar(e2 + 1);
      n2.push(a2);
    }
  }, t2.simplifyStates = function(t3) {
    var e2, r2, n2, o2, i2 = [];
    try {
      for (var a2 = Ni(t3), s2 = a2.next(); !s2.done; s2 = a2.next()) {
        var u2 = s2.value, c2 = true, f3 = function(t4) {
          if (t4.isBetterThanOrEqualTo(u2))
            return c2 = false, "break";
          u2.isBetterThanOrEqualTo(t4) && (i2 = i2.filter(function(e3) {
            return e3 !== t4;
          }));
        };
        try {
          for (var h2 = (n2 = void 0, Ni(i2)), l2 = h2.next(); !l2.done; l2 = h2.next()) {
            if ("break" === f3(l2.value))
              break;
          }
        } catch (t4) {
          n2 = { error: t4 };
        } finally {
          try {
            l2 && !l2.done && (o2 = h2.return) && o2.call(h2);
          } finally {
            if (n2)
              throw n2.error;
          }
        }
        c2 && i2.push(u2);
      }
    } catch (t4) {
      e2 = { error: t4 };
    } finally {
      try {
        s2 && !s2.done && (r2 = a2.return) && r2.call(a2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return i2;
  }, t2;
}();
var Mi = function(t2) {
  var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
  if (r2)
    return r2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
    } };
  throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
!function() {
  function t2() {
  }
  t2.encodeBytes = function(e2) {
    return t2.encode(e2, t2.DEFAULT_EC_PERCENT, t2.DEFAULT_AZTEC_LAYERS);
  }, t2.encode = function(e2, r2, n2) {
    var o2, i2, a2, s2, u2, c2 = new Di(e2).encode(), f3 = x.truncDivision(c2.getSize() * r2, 100) + 11, h2 = c2.getSize() + f3;
    if (n2 !== t2.DEFAULT_AZTEC_LAYERS) {
      if (o2 = n2 < 0, (i2 = Math.abs(n2)) > (o2 ? t2.MAX_NB_BITS_COMPACT : t2.MAX_NB_BITS))
        throw new T(q.format("Illegal value %s for layers", n2));
      var l2 = (a2 = t2.totalBitsInLayer(i2, o2)) - a2 % (s2 = t2.WORD_SIZE[i2]);
      if ((u2 = t2.stuffBits(c2, s2)).getSize() + f3 > l2)
        throw new T("Data to large for user specified layer");
      if (o2 && u2.getSize() > 64 * s2)
        throw new T("Data to large for user specified layer");
    } else {
      s2 = 0, u2 = null;
      for (var d2 = 0; ; d2++) {
        if (d2 > t2.MAX_NB_BITS)
          throw new T("Data too large for an Aztec code");
        if (i2 = (o2 = d2 <= 3) ? d2 + 1 : d2, !(h2 > (a2 = t2.totalBitsInLayer(i2, o2)))) {
          null != u2 && s2 === t2.WORD_SIZE[i2] || (s2 = t2.WORD_SIZE[i2], u2 = t2.stuffBits(c2, s2));
          l2 = a2 - a2 % s2;
          if (!(o2 && u2.getSize() > 64 * s2) && u2.getSize() + f3 <= l2)
            break;
        }
      }
    }
    var p2, g2 = t2.generateCheckWords(u2, a2, s2), y2 = u2.getSize() / s2, w2 = t2.generateModeMessage(o2, i2, y2), v2 = (o2 ? 11 : 14) + 4 * i2, _2 = new Int32Array(v2);
    if (o2) {
      p2 = v2;
      for (d2 = 0; d2 < _2.length; d2++)
        _2[d2] = d2;
    } else {
      p2 = v2 + 1 + 2 * x.truncDivision(x.truncDivision(v2, 2) - 1, 15);
      var A2 = x.truncDivision(v2, 2), C2 = x.truncDivision(p2, 2);
      for (d2 = 0; d2 < A2; d2++) {
        var m2 = d2 + x.truncDivision(d2, 15);
        _2[A2 - d2 - 1] = C2 - m2 - 1, _2[A2 + d2] = C2 + m2 + 1;
      }
    }
    for (var E2 = new J(p2), I2 = (d2 = 0, 0); d2 < i2; d2++) {
      for (var S2 = 4 * (i2 - d2) + (o2 ? 9 : 12), O2 = 0; O2 < S2; O2++)
        for (var b2 = 2 * O2, R2 = 0; R2 < 2; R2++)
          g2.get(I2 + b2 + R2) && E2.set(_2[2 * d2 + R2], _2[2 * d2 + O2]), g2.get(I2 + 2 * S2 + b2 + R2) && E2.set(_2[2 * d2 + O2], _2[v2 - 1 - 2 * d2 - R2]), g2.get(I2 + 4 * S2 + b2 + R2) && E2.set(_2[v2 - 1 - 2 * d2 - R2], _2[v2 - 1 - 2 * d2 - O2]), g2.get(I2 + 6 * S2 + b2 + R2) && E2.set(_2[v2 - 1 - 2 * d2 - O2], _2[2 * d2 + R2]);
      I2 += 8 * S2;
    }
    if (t2.drawModeMessage(E2, o2, p2, w2), o2)
      t2.drawBullsEye(E2, x.truncDivision(p2, 2), 5);
    else {
      t2.drawBullsEye(E2, x.truncDivision(p2, 2), 7);
      for (d2 = 0, O2 = 0; d2 < x.truncDivision(v2, 2) - 1; d2 += 15, O2 += 16)
        for (R2 = 1 & x.truncDivision(p2, 2); R2 < p2; R2 += 2)
          E2.set(x.truncDivision(p2, 2) - O2, R2), E2.set(x.truncDivision(p2, 2) + O2, R2), E2.set(R2, x.truncDivision(p2, 2) - O2), E2.set(R2, x.truncDivision(p2, 2) + O2);
    }
    var N10 = new pi();
    return N10.setCompact(o2), N10.setSize(p2), N10.setLayers(i2), N10.setCodeWords(y2), N10.setMatrix(E2), N10;
  }, t2.drawBullsEye = function(t3, e2, r2) {
    for (var n2 = 0; n2 < r2; n2 += 2)
      for (var o2 = e2 - n2; o2 <= e2 + n2; o2++)
        t3.set(o2, e2 - n2), t3.set(o2, e2 + n2), t3.set(e2 - n2, o2), t3.set(e2 + n2, o2);
    t3.set(e2 - r2, e2 - r2), t3.set(e2 - r2 + 1, e2 - r2), t3.set(e2 - r2, e2 - r2 + 1), t3.set(e2 + r2, e2 - r2), t3.set(e2 + r2, e2 - r2 + 1), t3.set(e2 + r2, e2 + r2 - 1);
  }, t2.generateModeMessage = function(e2, r2, n2) {
    var o2 = new V();
    return e2 ? (o2.appendBits(r2 - 1, 2), o2.appendBits(n2 - 1, 6), o2 = t2.generateCheckWords(o2, 28, 4)) : (o2.appendBits(r2 - 1, 5), o2.appendBits(n2 - 1, 11), o2 = t2.generateCheckWords(o2, 40, 4)), o2;
  }, t2.drawModeMessage = function(t3, e2, r2, n2) {
    var o2 = x.truncDivision(r2, 2);
    if (e2)
      for (var i2 = 0; i2 < 7; i2++) {
        var a2 = o2 - 3 + i2;
        n2.get(i2) && t3.set(a2, o2 - 5), n2.get(i2 + 7) && t3.set(o2 + 5, a2), n2.get(20 - i2) && t3.set(a2, o2 + 5), n2.get(27 - i2) && t3.set(o2 - 5, a2);
      }
    else
      for (i2 = 0; i2 < 10; i2++) {
        a2 = o2 - 5 + i2 + x.truncDivision(i2, 5);
        n2.get(i2) && t3.set(a2, o2 - 7), n2.get(i2 + 10) && t3.set(o2 + 7, a2), n2.get(29 - i2) && t3.set(a2, o2 + 7), n2.get(39 - i2) && t3.set(o2 - 7, a2);
      }
  }, t2.generateCheckWords = function(e2, r2, n2) {
    var o2, i2, a2 = e2.getSize() / n2, s2 = new To(t2.getGF(n2)), u2 = x.truncDivision(r2, n2), c2 = t2.bitsToWords(e2, n2, u2);
    s2.encode(c2, u2 - a2);
    var f3 = r2 % n2, h2 = new V();
    h2.appendBits(0, f3);
    try {
      for (var l2 = Mi(Array.from(c2)), d2 = l2.next(); !d2.done; d2 = l2.next()) {
        var p2 = d2.value;
        h2.appendBits(p2, n2);
      }
    } catch (t3) {
      o2 = { error: t3 };
    } finally {
      try {
        d2 && !d2.done && (i2 = l2.return) && i2.call(l2);
      } finally {
        if (o2)
          throw o2.error;
      }
    }
    return h2;
  }, t2.bitsToWords = function(t3, e2, r2) {
    var n2, o2, i2 = new Int32Array(r2);
    for (n2 = 0, o2 = t3.getSize() / e2; n2 < o2; n2++) {
      for (var a2 = 0, s2 = 0; s2 < e2; s2++)
        a2 |= t3.get(n2 * e2 + s2) ? 1 << e2 - s2 - 1 : 0;
      i2[n2] = a2;
    }
    return i2;
  }, t2.getGF = function(t3) {
    switch (t3) {
      case 4:
        return Tt.AZTEC_PARAM;
      case 6:
        return Tt.AZTEC_DATA_6;
      case 8:
        return Tt.AZTEC_DATA_8;
      case 10:
        return Tt.AZTEC_DATA_10;
      case 12:
        return Tt.AZTEC_DATA_12;
      default:
        throw new T("Unsupported word size " + t3);
    }
  }, t2.stuffBits = function(t3, e2) {
    for (var r2 = new V(), n2 = t3.getSize(), o2 = (1 << e2) - 2, i2 = 0; i2 < n2; i2 += e2) {
      for (var a2 = 0, s2 = 0; s2 < e2; s2++)
        (i2 + s2 >= n2 || t3.get(i2 + s2)) && (a2 |= 1 << e2 - 1 - s2);
      (a2 & o2) === o2 ? (r2.appendBits(a2 & o2, e2), i2--) : 0 == (a2 & o2) ? (r2.appendBits(1 | a2, e2), i2--) : r2.appendBits(a2, e2);
    }
    return r2;
  }, t2.totalBitsInLayer = function(t3, e2) {
    return ((e2 ? 88 : 112) + 16 * t3) * t3;
  }, t2.DEFAULT_EC_PERCENT = 33, t2.DEFAULT_AZTEC_LAYERS = 0, t2.MAX_NB_BITS = 32, t2.MAX_NB_BITS_COMPACT = 4, t2.WORD_SIZE = Int32Array.from([4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]);
}();
var Pi = function(t2) {
  return t2 instanceof Date;
};
var Bi = function(t2) {
  return null == t2;
};
var Li = function(t2) {
  return "object" == typeof t2;
};
var Fi = function(t2) {
  return !Bi(t2) && !Array.isArray(t2) && Li(t2) && !Pi(t2);
};
var ki = function(t2) {
  return Bi(t2) || !Li(t2);
};
function xi(t2, e2) {
  if (ki(t2) || ki(e2))
    return t2 === e2;
  if (Pi(t2) && Pi(e2))
    return t2.getTime() === e2.getTime();
  var r2 = Object.keys(t2), n2 = Object.keys(e2);
  if (r2.length !== n2.length)
    return false;
  for (var o2 = 0, i2 = r2; o2 < i2.length; o2++) {
    var a2 = i2[o2], s2 = t2[a2];
    if (!n2.includes(a2))
      return false;
    if ("ref" !== a2) {
      var u2 = e2[a2];
      if (Pi(s2) && Pi(u2) || Fi(s2) && Fi(u2) || Array.isArray(s2) && Array.isArray(u2) ? !xi(s2, u2) : s2 !== u2)
        return false;
    }
  }
  return true;
}
var Vi = new URL("../assets/scanner-beep.mp3", import.meta.url);
var Hi = function(t2) {
  var o2 = t2.onResult, s2 = t2.onError, f3 = t2.scanDelay, h2 = t2.hints, l2 = t2.deviceId, d2 = t2.stopDecoding, p2 = t2.audio, g2 = void 0 === p2 || p2, y2 = (0, import_react3.useRef)(false), w2 = (0, import_react3.useRef)(o2), v2 = (0, import_react3.useRef)(s2), _2 = (0, import_react3.useRef)(null), A2 = (0, import_react3.useRef)(new Audio(Vi.href)), C2 = (0, import_react3.useState)(t2.constraints), m2 = C2[0], E2 = C2[1], I2 = (0, import_react3.useMemo)(function() {
    return new Co(h2, f3);
  }, []), S2 = (0, import_react3.useCallback)(function(t3, e2) {
    if (t3 && (w2.current(t3), g2 && A2.current && A2.current.paused && A2.current.play().catch(function(t4) {
      return console.error("Error playing the sound", t4);
    })), e2) {
      if (e2 instanceof tt)
        return;
      if (e2 instanceof DOMException && "IndexSizeError" === e2.name)
        return;
      v2.current(e2);
    }
  }, []), T2 = (0, import_react3.useCallback)(function() {
    I2.reset();
  }, [I2]), O2 = (0, import_react3.useCallback)(function() {
    I2.stopAsyncDecode();
  }, [I2]), b2 = (0, import_react3.useCallback)(function() {
    return u(void 0, void 0, void 0, function() {
      var t3, e2;
      return c(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!_2.current)
              return [2];
            r2.label = 1;
          case 1:
            return r2.trys.push([1, 6, , 7]), l2 ? [4, I2.decodeFromVideoDevice(l2, _2.current, S2)] : [3, 3];
          case 2:
            return r2.sent(), [3, 5];
          case 3:
            return t3 = { audio: false, video: m2 }, [4, I2.decodeFromConstraints(t3, _2.current, S2)];
          case 4:
            r2.sent(), r2.label = 5;
          case 5:
            return [3, 7];
          case 6:
            return e2 = r2.sent(), v2.current(e2), [3, 7];
          case 7:
            return [2];
        }
      });
    });
  }, [I2, l2, m2, S2]);
  return (0, import_react3.useEffect)(function() {
    if (y2.current = true, !d2)
      return u(void 0, void 0, void 0, function() {
        return c(this, function(t3) {
          switch (t3.label) {
            case 0:
              return [4, b2()];
            case 1:
              return t3.sent(), y2.current || T2(), [2];
          }
        });
      }), function() {
        y2.current = false, T2();
      };
    O2();
  }, [b2, T2, d2]), (0, import_react3.useEffect)(function() {
    xi(t2.constraints, m2) || E2(t2.constraints);
  }, [t2.constraints]), (0, import_react3.useEffect)(function() {
    w2.current = o2;
  }, [o2]), (0, import_react3.useEffect)(function() {
    v2.current = s2;
  }, [s2]), { ref: _2, start: b2, stop: d2 };
};
var Ui = { width: "100%", paddingTop: "100%", overflow: "hidden", position: "relative" };
var Xi = { top: 0, left: 0, width: "100%", height: "100%", display: "block", overflow: "hidden", position: "absolute" };
var Gi = function(r2) {
  var n2 = r2.containerStyle, o2 = r2.videoStyle, i2 = r2.constraints, a2 = void 0 === i2 ? f : i2, h2 = r2.onResult, l2 = r2.onDecode, d2 = r2.onError, p2 = r2.viewFinder, y2 = r2.hideCount, w2 = void 0 === y2 || y2, v2 = r2.tracker, _2 = void 0 !== v2 && v2, A2 = r2.viewFinderBorder, C2 = r2.deviceId, m2 = r2.scanDelay, E2 = void 0 === m2 ? 100 : m2, I2 = r2.audio, S2 = void 0 === I2 || I2, T2 = function(t2, e2) {
    var r3 = {};
    for (var n3 in t2)
      Object.prototype.hasOwnProperty.call(t2, n3) && e2.indexOf(n3) < 0 && (r3[n3] = t2[n3]);
    if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
      var o3 = 0;
      for (n3 = Object.getOwnPropertySymbols(t2); o3 < n3.length; o3++)
        e2.indexOf(n3[o3]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, n3[o3]) && (r3[n3[o3]] = t2[n3[o3]]);
    }
    return r3;
  }(r2, ["containerStyle", "videoStyle", "constraints", "onResult", "onDecode", "onError", "viewFinder", "hideCount", "tracker", "viewFinderBorder", "deviceId", "scanDelay", "audio"]), O2 = (0, import_react3.useState)(0), b2 = O2[0], R2 = O2[1], N10 = (0, import_react3.useState)(), D2 = N10[0], M2 = N10[1];
  var P2 = Hi(s({ onResult: function(t2) {
    return u(this, void 0, void 0, function() {
      return c(this, function(e2) {
        return M2(t2), null == h2 || h2(t2), null == l2 || l2(t2.getText()), R2(function(t3) {
          return t3 + 1;
        }), [2];
      });
    });
  }, onError: function(t2) {
    null == d2 || d2(t2);
  }, constraints: a2, deviceId: C2, scanDelay: E2, audio: S2 }, T2)).ref;
  return import_react3.default.createElement("div", { style: s(s({}, Ui), n2) }, p2 ? import_react3.default.createElement(p2, null) : import_react3.default.createElement(g, { video: P2.current, result: D2, scanCount: b2, hideCount: w2, tracker: _2, border: A2, constraints: a2, deviceId: C2, scanDelay: E2 }), import_react3.default.createElement("video", { ref: P2, muted: true, playsInline: true, style: s(s({}, Xi), o2) }));
};

// src/components/CreateChessGame.tsx
var import_url_parse = __toESM(require_url_parse(), 1);
var import_agent_explorer_plugin2 = __toESM(require_agent_explorer_plugin(), 1);

// node_modules/.pnpm/@veramo+utils@6.0.0/node_modules/@veramo/utils/build/types/utility-types.js
var SupportedKeyTypes;
(function(SupportedKeyTypes2) {
  SupportedKeyTypes2["Secp256r1"] = "Secp256r1";
  SupportedKeyTypes2["Secp256k1"] = "Secp256k1";
  SupportedKeyTypes2["Ed25519"] = "Ed25519";
  SupportedKeyTypes2["X25519"] = "X25519";
})(SupportedKeyTypes || (SupportedKeyTypes = {}));

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length4) {
  if (!length4) {
    length4 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length4);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name3) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode13(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size2 - length4;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length4;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode16(string3) {
    var buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name3} character`);
  }
  return {
    encode: encode13,
    decodeUnsafe,
    decode: decode16
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii2 = 0; ii2 < aa.byteLength; ii2++) {
    if (aa[ii2] !== bb[ii2]) {
      return false;
    }
  }
  return true;
};
var coerce = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b2) => new TextDecoder().decode(b2);

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name3, prefix, baseEncode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name3, prefix, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec = class {
  constructor(name3, prefix, baseEncode, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name3, prefix, baseEncode);
    this.decoder = new Decoder(name3, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name3, prefix, encode: encode13, decode: decode16 }) => new Codec(name3, prefix, encode13, decode16);
var baseX = ({ prefix, name: name3, alphabet: alphabet4 }) => {
  const { encode: encode13, decode: decode16 } = base_x_default(alphabet4, name3);
  return from({
    prefix,
    name: name3,
    encode: encode13,
    decode: (text) => coerce(decode16(text))
  });
};
var decode = (string3, alphabet4, bitsPerChar, name3) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet4.length; ++i2) {
    codes[alphabet4[i2]] = i2;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string3[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name3} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name3, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from({
    prefix,
    name: name3,
    encode(input) {
      return encode(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet4, bitsPerChar, name3);
    }
  });
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString(buf),
  decode: (str) => fromString(str)
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
  p2[i2] = c2;
  return p2;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
  p2[c2.codePointAt(0)] = i2;
  return p2;
}, []);
function encode2(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode2,
  decode: decode2
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var varint_exports = {};
__export(varint_exports, {
  decode: () => decode4,
  encodeTo: () => encodeTo,
  encodingLength: () => encodingLength
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode3;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
var decode3 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf.length;
  do {
    if (counter >= l2) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf[counter++];
    res += shift < 28 ? (b2 & REST$1) << shift : (b2 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode3,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode4 = (data, offset = 0) => {
  const code4 = varint_default.decode(data, offset);
  return [
    code4,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code4, digest3) => {
  const size2 = digest3.byteLength;
  const sizeOffset = encodingLength(code4);
  const digestOffset = sizeOffset + encodingLength(size2);
  const bytes2 = new Uint8Array(digestOffset + size2);
  encodeTo(code4, bytes2, 0);
  encodeTo(size2, bytes2, sizeOffset);
  bytes2.set(digest3, digestOffset);
  return new Digest(code4, size2, digest3, bytes2);
};
var decode5 = (multihash) => {
  const bytes2 = coerce(multihash);
  const [code4, sizeOffset] = decode4(bytes2);
  const [size2, digestOffset] = decode4(bytes2.subarray(sizeOffset));
  const digest3 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest(code4, size2, digest3, bytes2);
};
var equals2 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals(a2.bytes, b2.bytes);
  }
};
var Digest = class {
  constructor(code4, size2, digest3, bytes2) {
    this.code = code4;
    this.size = size2;
    this.digest = digest3;
    this.bytes = bytes2;
  }
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name3, code: code4, encode: encode13 }) => new Hasher(name3, code4, encode13);
var Hasher = class {
  constructor(name3, code4, encode13) {
    this.name = name3;
    this.code = code4;
    this.encode = encode13;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest3) => create(this.code, digest3));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha = (name3) => async (data) => new Uint8Array(await crypto.subtle.digest(name3, data));
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code = 0;
var name = "identity";
var encode4 = coerce;
var digest = (input) => create(code, encode4(input));
var identity2 = {
  code,
  name,
  encode: encode4,
  digest
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version2, code4, multihash, bytes2) {
    this.code = code4;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code4, multihash } = this;
        if (code4 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code4, digest: digest3 } = this.multihash;
        const multihash = create(code4, digest3);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base5) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes2, _baseCache, base5 || base58btc.encoder);
      default:
        return toStringV1(bytes2, _baseCache, base5 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code4, multihash, bytes: bytes2 } = value;
      return new _CID(version2, code4, multihash, bytes2 || encodeCID(version2, code4, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code4 } = value;
      const digest3 = decode5(multihash);
      return _CID.create(version2, code4, digest3);
    } else {
      return null;
    }
  }
  static create(version2, code4, digest3) {
    if (typeof code4 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code4 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version2, code4, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID(version2, code4, digest3.bytes);
        return new _CID(version2, code4, digest3, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest3) {
    return _CID.create(0, DAG_PB_CODE, digest3);
  }
  static createV1(code4, digest3) {
    return _CID.create(1, code4, digest3);
  }
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest3 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest3) : _CID.createV1(specs.codec, digest3);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length4] = decode4(initialBytes.subarray(offset));
      offset += length4;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size2
    };
  }
  static parse(source, base5) {
    const [prefix, bytes2] = parseCIDtoBytes(source, base5);
    const cid = _CID.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base5) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base5 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base5 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base5 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base5 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base5.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes2, cache3, base5) => {
  const { prefix } = base5;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base5.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes2).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes2, cache3, base5) => {
  const { prefix } = base5;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes2);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version2, code4, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code4);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes2, 0);
  encodeTo(code4, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message2) => {
  if (range.test(version)) {
    console.warn(message2);
  } else {
    throw new Error(message2);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_browser_exports,
  ...identity_exports2
};

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name3, prefix, encode13, decode16) {
  return {
    name: name3,
    prefix,
    encoder: {
      name: name3,
      prefix,
      encode: encode13
    },
    decoder: { decode: decode16 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string3 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string3 += String.fromCharCode(buf[i2]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string3, encoding = "utf8") {
  const base5 = bases_default[encoding];
  if (!base5) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string3, "utf-8"));
  }
  return base5.decoder.decode(`${base5.prefix}${string3}`);
}

// node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base5 = bases_default[encoding];
  if (!base5) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base5.encoder.encode(array).substring(1);
}

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_assert.js
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function isBytes(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function bytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes2(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!isBytes2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    if (!isBytes2(a2))
      throw new Error("Uint8Array expected");
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad);
    pad += a2.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 || (to2 = new this.constructor());
    to2.set(...this.get());
    const { blockLen, buffer, length: length4, finished, destroyed, pos } = this;
    to2.length = length4;
    to2.pos = pos;
    to2.finished = finished;
    to2.destroyed = destroyed;
    if (length4 % blockLen)
      to2.buffer.set(buffer);
    return to2;
  }
};

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h: h2, l: l2 } = fromBig(lst[i2], le2);
    [Ah[i2], Al[i2]] = [h2, l2];
  }
  return [Ah, Al];
}
var toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
var shrSH = (h2, _l, s2) => h2 >>> s2;
var shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
var rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
var rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
var rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
var rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
var rotr32H = (_h, l2) => l2;
var rotr32L = (h2, _l) => h2;
var rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
var rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
var rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
var rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha5122 = /* @__PURE__ */ wrapConstructor(() => new SHA512());

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  isBytes: () => isBytes3,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes3(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!isBytes3(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i2 = 0; i2 < bytes2.length; i2++) {
    hex += hexes[bytes2[i2]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai2 = 0, hi2 = 0; ai2 < al; ai2++, hi2 += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi2));
    const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi2] + hex[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array[ai2] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!isBytes3(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e2}`);
    }
  } else if (isBytes3(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    if (!isBytes3(a2))
      throw new Error("Uint8Array expected");
    sum += a2.length;
  }
  let res = new Uint8Array(sum);
  let pad = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad);
    pad += a2.length;
  }
  return res;
}
function equalBytes(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b2[i2];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n;
}
var bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n : _0n) << BigInt(pos);
};
var bitMask = (n2) => (_2n << BigInt(n2 - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v2.fill(1);
    k2.fill(0);
    i2 = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed = u8n()) => {
    k2 = h2(u8fr([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr([1]), seed);
    v2 = h2();
  };
  const gen2 = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl = v2.slice();
      out.push(sl);
      len += v2.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod2(a2, b2) {
  const result = a2 % b2;
  return result >= _0n2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod2(number2, modulo);
  let b2 = modulo;
  let x2 = _0n2, y2 = _1n2, u2 = _1n2, v2 = _0n2;
  while (a2 !== _0n2) {
    const q2 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q2;
    const n2 = y2 - v2 * q2;
    b2 = a2, a2 = r2, x2 = u2, y2 = v2, u2 = m2, v2 = n2;
  }
  const gcd2 = b2;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod2(x2, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n2) / _2n2;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n2, S2 = 0; Q2 % _2n2 === _0n2; Q2 /= _2n2, S2++)
    ;
  for (Z2 = _2n2; Z2 < P2 && pow(Z2, legendreC, P2) !== P2 - _1n2; Z2++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n2) / _4n;
    return function tonelliFast(Fp4, n2) {
      const root = Fp4.pow(n2, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n2) / _2n2;
  return function tonelliSlow(Fp4, n2) {
    if (Fp4.pow(n2, legendreC) === Fp4.neg(Fp4.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp4.pow(Fp4.mul(Fp4.ONE, Z2), Q2);
    let x2 = Fp4.pow(n2, Q1div2);
    let b2 = Fp4.pow(n2, Q2);
    while (!Fp4.eql(b2, Fp4.ONE)) {
      if (Fp4.eql(b2, Fp4.ZERO))
        return Fp4.ZERO;
      let m2 = 1;
      for (let t2 = Fp4.sqr(b2); m2 < r2; m2++) {
        if (Fp4.eql(t2, Fp4.ONE))
          break;
        t2 = Fp4.sqr(t2);
      }
      const ge2 = Fp4.pow(g2, _1n2 << BigInt(r2 - m2 - 1));
      g2 = Fp4.sqr(ge2);
      x2 = Fp4.mul(x2, ge2);
      b2 = Fp4.mul(b2, g2);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n) {
    const p1div4 = (P2 + _1n2) / _4n;
    return function sqrt3mod4(Fp4, n2) {
      const root = Fp4.pow(n2, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp4, n2) {
      const n22 = Fp4.mul(n2, _2n2);
      const v2 = Fp4.pow(n22, c1);
      const nv = Fp4.mul(n2, v2);
      const i2 = Fp4.mul(Fp4.mul(nv, _2n2), v2);
      const root = Fp4.mul(nv, Fp4.sub(i2, Fp4.ONE));
      if (!Fp4.eql(Fp4.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _16n === _9n) {
  }
  return tonelliShanks(P2);
}
var isNegativeLE = (num, modulo) => (mod2(num, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f3, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f3.ONE;
  if (power === _1n2)
    return num;
  let p2 = f3.ONE;
  let d2 = num;
  while (power > _0n2) {
    if (power & _1n2)
      p2 = f3.mul(p2, d2);
    d2 = f3.sqr(d2);
    power >>= _1n2;
  }
  return p2;
}
function FpInvertBatch(f3, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f3.is0(num))
      return acc;
    tmp[i2] = acc;
    return f3.mul(acc, num);
  }, f3.ONE);
  const inverted = f3.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f3.is0(num))
      return acc;
    tmp[i2] = f3.mul(acc, tmp[i2]);
    return f3.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f3 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f3, num, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f3, n2)),
    invertBatch: (lst) => FpInvertBatch(f3, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f3);
}
function FpSqrtEven(Fp4, elm) {
  if (!Fp4.isOdd)
    throw new Error(`Field doesn't have isOdd`);
  const root = Fp4.sqrt(elm);
  return Fp4.isOdd(root) ? Fp4.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length4 = getFieldBytesLength(fieldOrder);
  return length4 + Math.ceil(length4 / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod2(num, fieldOrder - _1n2) + _1n2;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c2, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p2 = c2.ZERO;
      let d2 = elm;
      while (n2 > _0n3) {
        if (n2 & _1n3)
          p2 = p2.add(d2);
        d2 = d2.double();
        n2 >>= _1n3;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base5 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base5 = p2;
        points.push(base5);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base5 = base5.add(p2);
          points.push(base5);
        }
        p2 = base5.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f3 = c2.BASE;
      const mask = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p2, f: f3 };
    },
    wNAFCached(P2, precomputesMap, n2, transform) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/edwards.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp4, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n3 << BigInt(nByteLength * 8) - _1n4;
  const modP = Fp4.create;
  const uvRatio2 = CURVE.uvRatio || ((u2, v2) => {
    try {
      return { isValid: true, value: Fp4.sqrt(u2 * Fp4.inv(v2)) };
    } catch (e2) {
      return { isValid: false, value: _0n4 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  const inBig = (n2) => typeof n2 === "bigint" && _0n4 < n2;
  const inRange = (n2, max) => inBig(n2) && inBig(max) && n2 < max;
  const in0MaskRange = (n2) => n2 === _0n4 || inRange(n2, MASK);
  function assertInRange(n2, max) {
    if (inRange(n2, max))
      return n2;
    throw new Error(`Expected valid scalar < ${max}, got ${typeof n2} ${n2}`);
  }
  function assertGE0(n2) {
    return n2 === _0n4 ? n2 : assertInRange(n2, CURVE_ORDER);
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function isPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  class Point2 {
    constructor(ex, ey, ez, et2) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et2;
      if (!in0MaskRange(ex))
        throw new Error("x required");
      if (!in0MaskRange(ey))
        throw new Error("y required");
      if (!in0MaskRange(ez))
        throw new Error("z required");
      if (!in0MaskRange(et2))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p2) {
      if (p2 instanceof Point2)
        throw new Error("extended point not allowed");
      const { x: x2, y: y2 } = p2 || {};
      if (!in0MaskRange(x2) || !in0MaskRange(y2))
        throw new Error("invalid affine point");
      return new Point2(x2, y2, _1n4, modP(x2 * y2));
    }
    static normalizeZ(points) {
      const toInv = Fp4.invertBatch(points.map((p2) => p2.ez));
      return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      const { a: a2, d: d2 } = CURVE;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = this;
      const X22 = modP(X2 * X2);
      const Y22 = modP(Y2 * Y2);
      const Z22 = modP(Z2 * Z2);
      const Z4 = modP(Z22 * Z22);
      const aX2 = modP(X22 * a2);
      const left = modP(Z22 * modP(aX2 + Y22));
      const right = modP(Z4 + modP(d2 * modP(X22 * Y22)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X2 * Y2);
      const ZT = modP(Z2 * T2);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
    }
    // Compare one point to another.
    equals(other) {
      isPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a2 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A2 = modP(X1 * X1);
      const B2 = modP(Y1 * Y1);
      const C2 = modP(_2n3 * modP(Z1 * Z1));
      const D2 = modP(a2 * A2);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A2 - B2);
      const G3 = D2 + B2;
      const F2 = G3 - C2;
      const H2 = D2 - B2;
      const X3 = modP(E2 * F2);
      const Y3 = modP(G3 * H2);
      const T3 = modP(E2 * H2);
      const Z3 = modP(F2 * G3);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      isPoint(other);
      const { a: a2, d: d2 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      if (a2 === BigInt(-1)) {
        const A3 = modP((Y1 - X1) * (Y2 + X2));
        const B3 = modP((Y1 + X1) * (Y2 - X2));
        const F3 = modP(B3 - A3);
        if (F3 === _0n4)
          return this.double();
        const C3 = modP(Z1 * _2n3 * T2);
        const D3 = modP(T1 * _2n3 * Z2);
        const E3 = D3 + C3;
        const G4 = B3 + A3;
        const H3 = D3 - C3;
        const X32 = modP(E3 * F3);
        const Y32 = modP(G4 * H3);
        const T32 = modP(E3 * H3);
        const Z32 = modP(F3 * G4);
        return new Point2(X32, Y32, Z32, T32);
      }
      const A2 = modP(X1 * X2);
      const B2 = modP(Y1 * Y2);
      const C2 = modP(T1 * d2 * T2);
      const D2 = modP(Z1 * Z2);
      const E2 = modP((X1 + Y1) * (X2 + Y2) - A2 - B2);
      const F2 = D2 - C2;
      const G3 = D2 + C2;
      const H2 = modP(B2 - a2 * A2);
      const X3 = modP(E2 * F2);
      const Y3 = modP(G3 * H2);
      const T3 = modP(E2 * H2);
      const Z3 = modP(F2 * G3);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, Point2.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const { p: p2, f: f3 } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
      return Point2.normalizeZ([p2, f3])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      let n2 = assertGE0(scalar);
      if (n2 === _0n4)
        return I2;
      if (this.equals(I2) || n2 === _1n4)
        return this;
      if (this.equals(G2))
        return this.wNAF(n2).p;
      return wnaf.unsafeLadder(this, n2);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      const { ex: x2, ey: y2, ez: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? _8n2 : Fp4.inv(z2);
      const ax = modP(x2 * iz);
      const ay = modP(y2 * iz);
      const zz = modP(z2 * iz);
      if (is0)
        return { x: _0n4, y: _1n4 };
      if (zz !== _1n4)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d: d2, a: a2 } = CURVE;
      const len = Fp4.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y2 = bytesToNumberLE(normed);
      if (y2 === _0n4) {
      } else {
        if (zip215)
          assertInRange(y2, MASK);
        else
          assertInRange(y2, Fp4.ORDER);
      }
      const y22 = modP(y2 * y2);
      const u2 = modP(y22 - _1n4);
      const v2 = modP(d2 * y22 - a2);
      let { isValid, value: x2 } = uvRatio2(u2, v2);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n4 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point2.fromAffine({ x: x2, y: y2 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x2, y: y2 } = this.toAffine();
      const bytes2 = numberToBytesLE(y2, Fp4.BYTES);
      bytes2[bytes2.length - 1] |= x2 & _1n4 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n4, _1n4, _1n4, _0n4);
  const { BASE: G2, ZERO: I2 } = Point2;
  const wnaf = wNAF(Point2, nByteLength * 8);
  function modN(a2) {
    return mod2(a2, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE(hash2));
  }
  function getExtendedPublicKey(key) {
    const len = nByteLength;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G2.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r2 = hashDomainToScalar(options.context, prefix, msg);
    const R2 = G2.multiply(r2).toRawBytes();
    const k2 = hashDomainToScalar(options.context, R2, pointBytes, msg);
    const s2 = modN(r2 + k2 * scalar);
    assertGE0(s2);
    const res = concatBytes2(R2, numberToBytesLE(s2, Fp4.BYTES));
    return ensureBytes("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp4.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const s2 = bytesToNumberLE(sig.slice(len, 2 * len));
    let A2, R2, SB;
    try {
      A2 = Point2.fromHex(publicKey, zip215);
      R2 = Point2.fromHex(sig.slice(0, len), zip215);
      SB = G2.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A2.isSmallOrder())
      return false;
    const k2 = hashDomainToScalar(context, R2.toRawBytes(), A2.toRawBytes(), msg);
    const RkA = R2.add(A2.multiplyUnsafe(k2));
    return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
  }
  G2._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp4.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign,
    verify,
    ExtendedPoint: Point2,
    utils
  };
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _5n2 = BigInt(5);
var _10n = BigInt(10);
var _20n = BigInt(20);
var _40n = BigInt(40);
var _80n = BigInt(80);
function ed25519_pow_2_252_3(x2) {
  const P2 = ED25519_P;
  const x22 = x2 * x2 % P2;
  const b2 = x22 * x2 % P2;
  const b4 = pow2(b2, _2n4, P2) * b2 % P2;
  const b5 = pow2(b4, _1n5, P2) * x2 % P2;
  const b10 = pow2(b5, _5n2, P2) * b5 % P2;
  const b20 = pow2(b10, _10n, P2) * b10 % P2;
  const b40 = pow2(b20, _20n, P2) * b20 % P2;
  const b80 = pow2(b40, _40n, P2) * b40 % P2;
  const b160 = pow2(b80, _80n, P2) * b80 % P2;
  const b240 = pow2(b160, _80n, P2) * b80 % P2;
  const b250 = pow2(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow2(b250, _2n4, P2) * x2 % P2;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u2, v2) {
  const P2 = ED25519_P;
  const v3 = mod2(v2 * v2 * v2, P2);
  const v7 = mod2(v3 * v3 * v2, P2);
  const pow3 = ed25519_pow_2_252_3(u2 * v7).pow_p_5_8;
  let x2 = mod2(u2 * v3 * pow3, P2);
  const vx2 = mod2(v2 * x2 * x2, P2);
  const root1 = x2;
  const root2 = mod2(x2 * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod2(-u2, P2);
  const noRoot = vx2 === mod2(-u2 * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE(x2, P2))
    x2 = mod2(-x2, P2);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
var Fp = Field(ED25519_P, void 0, true);
var ed25519Defaults = {
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field p over which we'll do calculations; 2n**255n - 19n
  Fp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: BigInt(8),
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha5122,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
};
var ed25519 = /* @__PURE__ */ twistedEdwards(ed25519Defaults);
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = /* @__PURE__ */ twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
});
var ed25519ph = /* @__PURE__ */ twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain,
  prehash: sha5122
});
var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
var ELL2_C2 = Fp.pow(_2n4, ELL2_C1);
var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
var ELL2_J = BigInt(486662);
var ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664)));
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/.pnpm/did-jwt@8.0.4/node_modules/did-jwt/lib/index.module.js
var import_multibase = __toESM(require_src2(), 1);

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
var Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha2562 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp4, a: a2 } = opts;
  if (endo) {
    if (!Fp4.eql(a2, Fp4.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E2 } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!isBytes3(data))
      throw new Error("ui8a expected");
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s: s2 };
  },
  hexFromSig(sig) {
    const slice = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s2 = slice(h2(sig.s));
    const r2 = slice(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r2.length / 2;
    const sl = h2(shl);
    const rl = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl}${r2}02${sl}${s2}`;
  }
};
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp4 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp4.toBytes(a2.x), Fp4.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp4.fromBytes(tail.subarray(0, Fp4.BYTES));
    const y2 = Fp4.fromBytes(tail.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp4.sqr(x2);
    const x3 = Fp4.mul(x22, x2);
    return Fp4.add(Fp4.add(x3, Fp4.mul(x2, a2)), b2);
  }
  if (!Fp4.eql(Fp4.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n6 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod2(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp4.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp4.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp4.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp4.isValid(x2) || !Fp4.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp4.eql(i2, Fp4.ZERO);
      if (is0(x2) && is0(y2))
        return Point2.ZERO;
      return new Point2(x2, y2, Fp4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp4.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp4.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y2 } = this.toAffine();
      if (!Fp4.isValid(x2) || !Fp4.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp4.sqr(y2);
      const right = weierstrassEquation(x2);
      if (!Fp4.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp4.isOdd)
        return !Fp4.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp4.eql(Fp4.mul(X1, Z2), Fp4.mul(X2, Z1));
      const U2 = Fp4.eql(Fp4.mul(Y1, Z2), Fp4.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp4.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp4.mul(b2, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
      let t0 = Fp4.mul(X1, X1);
      let t1 = Fp4.mul(Y1, Y1);
      let t2 = Fp4.mul(Z1, Z1);
      let t3 = Fp4.mul(X1, Y1);
      t3 = Fp4.add(t3, t3);
      Z3 = Fp4.mul(X1, Z1);
      Z3 = Fp4.add(Z3, Z3);
      X3 = Fp4.mul(a2, Z3);
      Y3 = Fp4.mul(b3, t2);
      Y3 = Fp4.add(X3, Y3);
      X3 = Fp4.sub(t1, Y3);
      Y3 = Fp4.add(t1, Y3);
      Y3 = Fp4.mul(X3, Y3);
      X3 = Fp4.mul(t3, X3);
      Z3 = Fp4.mul(b3, Z3);
      t2 = Fp4.mul(a2, t2);
      t3 = Fp4.sub(t0, t2);
      t3 = Fp4.mul(a2, t3);
      t3 = Fp4.add(t3, Z3);
      Z3 = Fp4.add(t0, t0);
      t0 = Fp4.add(Z3, t0);
      t0 = Fp4.add(t0, t2);
      t0 = Fp4.mul(t0, t3);
      Y3 = Fp4.add(Y3, t0);
      t2 = Fp4.mul(Y1, Z1);
      t2 = Fp4.add(t2, t2);
      t0 = Fp4.mul(t2, t3);
      X3 = Fp4.sub(X3, t0);
      Z3 = Fp4.mul(t2, t1);
      Z3 = Fp4.add(Z3, Z3);
      Z3 = Fp4.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp4.ZERO, Y3 = Fp4.ZERO, Z3 = Fp4.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp4.mul(CURVE.b, _3n2);
      let t0 = Fp4.mul(X1, X2);
      let t1 = Fp4.mul(Y1, Y2);
      let t2 = Fp4.mul(Z1, Z2);
      let t3 = Fp4.add(X1, Y1);
      let t4 = Fp4.add(X2, Y2);
      t3 = Fp4.mul(t3, t4);
      t4 = Fp4.add(t0, t1);
      t3 = Fp4.sub(t3, t4);
      t4 = Fp4.add(X1, Z1);
      let t5 = Fp4.add(X2, Z2);
      t4 = Fp4.mul(t4, t5);
      t5 = Fp4.add(t0, t2);
      t4 = Fp4.sub(t4, t5);
      t5 = Fp4.add(Y1, Z1);
      X3 = Fp4.add(Y2, Z2);
      t5 = Fp4.mul(t5, X3);
      X3 = Fp4.add(t1, t2);
      t5 = Fp4.sub(t5, X3);
      Z3 = Fp4.mul(a2, t4);
      X3 = Fp4.mul(b3, t2);
      Z3 = Fp4.add(X3, Z3);
      X3 = Fp4.sub(t1, Z3);
      Z3 = Fp4.add(t1, Z3);
      Y3 = Fp4.mul(X3, Z3);
      t1 = Fp4.add(t0, t0);
      t1 = Fp4.add(t1, t0);
      t2 = Fp4.mul(a2, t2);
      t4 = Fp4.mul(b3, t4);
      t1 = Fp4.add(t1, t2);
      t2 = Fp4.sub(t0, t2);
      t2 = Fp4.mul(a2, t2);
      t4 = Fp4.add(t4, t2);
      t0 = Fp4.mul(t1, t4);
      Y3 = Fp4.add(Y3, t0);
      t0 = Fp4.mul(t5, t4);
      X3 = Fp4.mul(t3, X3);
      X3 = Fp4.sub(X3, t0);
      t0 = Fp4.mul(t3, t1);
      Z3 = Fp4.mul(t5, Z3);
      Z3 = Fp4.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp4.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I2 = Point2.ZERO;
      if (n2 === _0n6)
        return I2;
      assertGE(n2);
      if (n2 === _1n6)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n6 || k2 > _0n6) {
        if (k1 & _1n6)
          k1p = k1p.add(d2);
        if (k2 & _1n6)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n6;
        k2 >>= _1n6;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f3 } = this.wNAF(n2);
        point = p2;
        fake = f3;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G2 = Point2.BASE;
      const mul = (P2, a3) => a3 === _0n6 || a3 === _1n6 || !P2.equals(G2) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul(this, a2).add(mul(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y2, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp4.ONE : Fp4.inv(z2);
      const ax = Fp4.mul(x2, iz);
      const ay = Fp4.mul(y2, iz);
      const zz = Fp4.mul(z2, iz);
      if (is0)
        return { x: Fp4.ZERO, y: Fp4.ZERO };
      if (!Fp4.eql(zz, Fp4.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n6)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n6)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp4.ONE);
  Point2.ZERO = new Point2(Fp4.ZERO, Fp4.ONE, Fp4.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts2(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp4, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp4.BYTES + 1;
  const uncompressedLen = 2 * Fp4.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n6 < num && num < Fp4.ORDER;
  }
  function modN(a2) {
    return mod2(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a2 = point.toAffine();
      const x2 = Fp4.toBytes(a2.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp4.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3 = Fp4.sqrt(y2);
        const isYOdd = (y3 & _1n6) === _1n6;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp4.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp4.fromBytes(tail.subarray(0, Fp4.BYTES));
        const y2 = Fp4.fromBytes(tail.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n6;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b2, from6, to2) => bytesToNumberBE(b2.slice(from6, to2));
  class Signature {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l2 * 2);
      return new Signature(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r2, s: s2 } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r2, s2);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp4.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir2 = invN(radj);
      const u1 = modN(-h2 * ir2);
      const u2 = modN(s2 * ir2);
      const Q2 = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length4 = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length4), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point2.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n6 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null) {
      const e2 = ent === true ? randomBytes2(Fp4.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik = invN(k2);
      const q2 = Point2.BASE.multiply(k2).toAffine();
      const r2 = modN(q2.x);
      if (r2 === _0n6)
        return;
      const s2 = modN(ik * modN(m2 + r2 * d2));
      if (s2 === _0n6)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n6);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg === "string" || isBytes3(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r3, s: s3 } = sg;
        _sig = new Signature(r3, s3);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s2);
    const u1 = modN(h2 * is);
    const u2 = modN(r2 * is);
    const R2 = Point2.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R2)
      return false;
    const v2 = modN(R2.x);
    return v2 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message2) => new HMAC(hash2, key).update(message2).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create4 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create4(defHash), create: create4 });
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n7 = BigInt(1);
var _2n6 = BigInt(2);
var divNearest = (a2, b2) => (a2 + b2 / _2n6) / b2;
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2(b3, _3n3, P2) * b3 % P2;
  const b9 = pow2(b6, _3n3, P2) * b3 % P2;
  const b11 = pow2(b9, _2n6, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n3, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n6, P2);
  if (!Fp2.eql(Fp2.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
var Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k2, n2);
      const c2 = divNearest(-b1 * k2, n2);
      let k1 = mod2(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod2(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha2562);
var _0n7 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/p256.js
var Fp3 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var CURVE_A = Fp3.create(BigInt("-3"));
var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: CURVE_A,
  // Equation params: a, b
  b: CURVE_B,
  Fp: Fp3,
  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
  // Curve order, total count of valid points in the field
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  // Base (generator) point (x, y)
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha2562);

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_2, i2) => i2);
var Pi2 = /* @__PURE__ */ Id.map((i2) => (9 * i2 + 5) % 16);
var idxL = [Id];
var idxR = [Pi2];
for (let i2 = 0; i2 < 4; i2++)
  for (let j2 of [idxL, idxR])
    j2.push(j2[i2].map((k2) => Rho[k2]));
var shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => new Uint8Array(i2));
var shiftsL = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
var shiftsR = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j2) => shifts[i2][j2]));
var Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr2 = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f2(group, x2, y2, z2) {
  if (group === 0)
    return x2 ^ y2 ^ z2;
  else if (group === 1)
    return x2 & y2 | ~x2 & z2;
  else if (group === 2)
    return (x2 | ~y2) ^ z2;
  else if (group === 3)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
var BUF = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar2 = al, bl = this.h1 | 0, br2 = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr2 = dl, el = this.h4 | 0, er2 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr2[group];
      const rl = idxL[group], rr2 = idxR[group];
      const sl = shiftsL[group], sr2 = shiftsR[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + f2(group, bl, cl, dl) + BUF[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr2 = rotl(ar2 + f2(rGroup, br2, cr2, dr2) + BUF[rr2[i2]] + hbr, sr2[i2]) + er2 | 0;
        ar2 = er2, er2 = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br2, br2 = tr2;
      }
    }
    this.set(this.h1 + cl + dr2 | 0, this.h2 + dl + er2 | 0, this.h3 + el + ar2 | 0, this.h4 + al + br2 | 0, this.h0 + bl + cr2 | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n8 = /* @__PURE__ */ BigInt(0);
var _1n8 = /* @__PURE__ */ BigInt(1);
var _2n7 = /* @__PURE__ */ BigInt(2);
var _7n = /* @__PURE__ */ BigInt(7);
var _256n = /* @__PURE__ */ BigInt(256);
var _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R2 = _1n8, x2 = 1, y2 = 0; round < 24; round++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x2));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t2 = _0n8;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n8 ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n7)
      t2 ^= _1n8 << (_1n8 << /* @__PURE__ */ BigInt(j2)) - _1n8;
  }
  _SHA3_IOTA.push(t2);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
var rotlH = (h2, l2, s2) => s2 > 32 ? rotlBH(h2, l2, s2) : rotlSH(h2, l2, s2);
var rotlL = (h2, l2, s2) => s2 > 32 ? rotlBL(h2, l2, s2) : rotlSL(h2, l2, s2);
function keccakP(s2, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x2 + y2] ^= Th;
        s2[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s2[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round];
    s2[1] ^= SHA3_IOTA_L[round];
  }
  B2.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to2) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to2 || (to2 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to2.state32.set(this.state32);
    to2.pos = this.pos;
    to2.posOut = this.posOut;
    to2.finished = this.finished;
    to2.rounds = rounds;
    to2.suffix = suffix;
    to2.outputLen = outputLen;
    to2.enableXOF = enableXOF;
    to2.destroyed = this.destroyed;
    return to2;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

// node_modules/.pnpm/did-jwt@8.0.4/node_modules/did-jwt/lib/index.module.js
var import_canonicalize = __toESM(require_canonicalize(), 1);

// node_modules/.pnpm/@scure+base@1.1.6/node_modules/@scure/base/lib/esm/index.js
// @__NO_SIDE_EFFECTS__
function assertNumber(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`Wrong integer: ${n2}`);
}
function isBytes4(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a2) => a2;
  const wrap = (a2, b2) => (c2) => a2(b2(c2));
  const encode13 = args.map((x2) => x2.encode).reduceRight(wrap, id);
  const decode16 = args.map((x2) => x2.decode).reduce(wrap, id);
  return { encode: encode13, decode: decode16 };
}
// @__NO_SIDE_EFFECTS__
function alphabet2(alphabet4) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i2) => {
        /* @__PURE__ */ assertNumber(i2);
        if (i2 < 0 || i2 >= alphabet4.length)
          throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet4.length})`);
        return alphabet4[i2];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet4.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet4}`);
        return index;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from6) => {
      if (!Array.isArray(from6) || from6.length && typeof from6[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i2 of from6)
        if (typeof i2 !== "string")
          throw new Error(`join.encode: non-string input=${i2}`);
      return from6.join(separator);
    },
    decode: (to2) => {
      if (typeof to2 !== "string")
        throw new Error("join.decode input should be string");
      return to2.split(separator);
    }
  };
}
var gcd = /* @__NO_SIDE_EFFECTS__ */ (a2, b2) => !b2 ? a2 : /* @__PURE__ */ gcd(b2, a2 % b2);
var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from6, to2) => from6 + (to2 - /* @__PURE__ */ gcd(from6, to2));
// @__NO_SIDE_EFFECTS__
function convertRadix2(data, from6, to2, padding) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from6 <= 0 || from6 > 32)
    throw new Error(`convertRadix2: wrong from=${from6}`);
  if (to2 <= 0 || to2 > 32)
    throw new Error(`convertRadix2: wrong to=${to2}`);
  if (/* @__PURE__ */ radix2carry(from6, to2) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from6} to=${to2} carryBits=${/* @__PURE__ */ radix2carry(from6, to2)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to2 - 1;
  const res = [];
  for (const n2 of data) {
    /* @__PURE__ */ assertNumber(n2);
    if (n2 >= 2 ** from6)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from6}`);
    carry = carry << from6 | n2;
    if (pos + from6 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from6}`);
    pos += from6;
    for (; pos >= to2; pos -= to2)
      res.push((carry >> pos - to2 & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to2 - pos & mask;
  if (!padding && pos >= from6)
    throw new Error("Excess padding");
  if (!padding && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding && pos > 0)
    res.push(carry >>> 0);
  return res;
}
// @__NO_SIDE_EFFECTS__
function radix2(bits, revPadding = false) {
  /* @__PURE__ */ assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes4(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function unsafeWrapper(fn2) {
  if (typeof fn2 !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn2.apply(null, args);
    } catch (e2) {
    }
  };
}
var BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
// @__NO_SIDE_EFFECTS__
function bech32Polymod(pre) {
  const b2 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b2 >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
// @__NO_SIDE_EFFECTS__
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c2 = prefix.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = /* @__PURE__ */ bech32Polymod(chk) ^ c2 >> 5;
  }
  chk = /* @__PURE__ */ bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = /* @__PURE__ */ bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v2 of words)
    chk = /* @__PURE__ */ bech32Polymod(chk) ^ v2;
  for (let i2 = 0; i2 < 6; i2++)
    chk = /* @__PURE__ */ bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(/* @__PURE__ */ convertRadix2([chk % 2 ** 30], 30, 5, false));
}
// @__NO_SIDE_EFFECTS__
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = /* @__PURE__ */ radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = /* @__PURE__ */ unsafeWrapper(fromWords);
  function encode13(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    if (prefix.length === 0)
      throw new TypeError(`Invalid prefix length ${prefix.length}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = /* @__PURE__ */ bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode16(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = /* @__PURE__ */ bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = /* @__PURE__ */ unsafeWrapper(decode16);
  function decodeToBytes(str) {
    const { prefix, words } = decode16(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode: encode13, decode: decode16, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = /* @__PURE__ */ genBech32("bech32");

// node_modules/.pnpm/did-jwt@8.0.4/node_modules/did-jwt/lib/index.module.js
var u8a = {
  toString: toString2,
  fromString: fromString2,
  concat
};
function bytesToBase64url(b2) {
  return u8a.toString(b2, "base64url");
}
function base64ToBytes(s2) {
  const inputBase64Url = s2.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return u8a.fromString(inputBase64Url, "base64url");
}
function base58ToBytes(s2) {
  return u8a.fromString(s2, "base58btc");
}
function bytesToBase58(b2) {
  return u8a.toString(b2, "base58btc");
}
var VM_TO_KEY_TYPE = {
  Secp256k1SignatureVerificationKey2018: "Secp256k1",
  Secp256k1VerificationKey2018: "Secp256k1",
  EcdsaSecp256k1VerificationKey2019: "Secp256k1",
  EcdsaPublicKeySecp256k1: "Secp256k1",
  EcdsaSecp256k1RecoveryMethod2020: "Secp256k1",
  EcdsaSecp256r1VerificationKey2019: "P-256",
  Ed25519VerificationKey2018: "Ed25519",
  Ed25519VerificationKey2020: "Ed25519",
  ED25519SignatureVerification: "Ed25519",
  X25519KeyAgreementKey2019: "X25519",
  X25519KeyAgreementKey2020: "X25519",
  ConditionalProof2022: void 0,
  JsonWebKey2020: void 0,
  Multikey: void 0
  // key type must be extracted from the multicodec
};
var supportedCodecs = {
  "ed25519-pub": 237,
  "x25519-pub": 236,
  "secp256k1-pub": 231,
  "bls12_381-g1-pub": 234,
  "bls12_381-g2-pub": 235,
  "p256-pub": 4608
};
var CODEC_TO_KEY_TYPE = {
  "bls12_381-g1-pub": "Bls12381G1",
  "bls12_381-g2-pub": "Bls12381G2",
  "ed25519-pub": "Ed25519",
  "p256-pub": "P-256",
  "secp256k1-pub": "Secp256k1",
  "x25519-pub": "X25519"
};
function extractPublicKeyBytes(pk) {
  if (pk.publicKeyBase58) {
    return {
      keyBytes: base58ToBytes(pk.publicKeyBase58),
      keyType: VM_TO_KEY_TYPE[pk.type]
    };
  } else if (pk.publicKeyBase64) {
    return {
      keyBytes: base64ToBytes(pk.publicKeyBase64),
      keyType: VM_TO_KEY_TYPE[pk.type]
    };
  } else if (pk.publicKeyHex) {
    return {
      keyBytes: hexToBytes2(pk.publicKeyHex),
      keyType: VM_TO_KEY_TYPE[pk.type]
    };
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "secp256k1" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
    return {
      keyBytes: secp256k1.ProjectivePoint.fromAffine({
        x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),
        y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))
      }).toRawBytes(false),
      keyType: "Secp256k1"
    };
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "P-256" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
    return {
      keyBytes: p256.ProjectivePoint.fromAffine({
        x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),
        y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))
      }).toRawBytes(false),
      keyType: "P-256"
    };
  } else if (pk.publicKeyJwk && pk.publicKeyJwk.kty === "OKP" && ["Ed25519", "X25519"].includes(pk.publicKeyJwk.crv ?? "") && pk.publicKeyJwk.x) {
    return {
      keyBytes: base64ToBytes(pk.publicKeyJwk.x),
      keyType: pk.publicKeyJwk.crv
    };
  } else if (pk.publicKeyMultibase) {
    const {
      keyBytes,
      keyType
    } = multibaseToBytes(pk.publicKeyMultibase);
    return {
      keyBytes,
      keyType: keyType ?? VM_TO_KEY_TYPE[pk.type]
    };
  }
  return {
    keyBytes: new Uint8Array()
  };
}
function multibaseToBytes(s2) {
  const bytes2 = (0, import_multibase.decode)(s2);
  if ([32, 33, 48, 64, 65, 96].includes(bytes2.length)) {
    return {
      keyBytes: bytes2
    };
  }
  try {
    const [codec, length4] = varint_exports.decode(bytes2);
    const possibleCodec = Object.entries(supportedCodecs).filter(([, code4]) => code4 === codec)?.[0][0] ?? "";
    return {
      keyBytes: bytes2.slice(length4),
      keyType: CODEC_TO_KEY_TYPE[possibleCodec]
    };
  } catch (e2) {
    return {
      keyBytes: bytes2
    };
  }
}
function hexToBytes2(s2, minLength) {
  let input = s2.startsWith("0x") ? s2.substring(2) : s2;
  if (input.length % 2 !== 0) {
    input = `0${input}`;
  }
  if (minLength) {
    const paddedLength = Math.max(input.length, minLength * 2);
    input = input.padStart(paddedLength, "00");
  }
  return u8a.fromString(input.toLowerCase(), "base16");
}
function bytesToHex2(b2) {
  return u8a.toString(b2, "base16");
}
function bytesToBigInt(b2) {
  return BigInt(`0x` + u8a.toString(b2, "base16"));
}
function stringToBytes(s2) {
  return u8a.fromString(s2, "utf-8");
}
function toJose({
  r: r2,
  s: s2,
  recoveryParam
}, recoverable) {
  const jose = new Uint8Array(recoverable ? 65 : 64);
  jose.set(u8a.fromString(r2, "base16"), 0);
  jose.set(u8a.fromString(s2, "base16"), 32);
  if (recoverable) {
    if (typeof recoveryParam === "undefined") {
      throw new Error("Signer did not return a recoveryParam");
    }
    jose[64] = recoveryParam;
  }
  return bytesToBase64url(jose);
}
function fromJose(signature) {
  const signatureBytes = base64ToBytes(signature);
  if (signatureBytes.length < 64 || signatureBytes.length > 65) {
    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`);
  }
  const r2 = bytesToHex2(signatureBytes.slice(0, 32));
  const s2 = bytesToHex2(signatureBytes.slice(32, 64));
  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : void 0;
  return {
    r: r2,
    s: s2,
    recoveryParam
  };
}
function sha2563(payload) {
  const data = typeof payload === "string" ? fromString2(payload) : payload;
  return sha2562(data);
}
var keccak = keccak_256;
function toEthereumAddress(hexPublicKey) {
  const hashInput = fromString2(hexPublicKey.slice(2), "base16");
  return `0x${toString2(keccak(hashInput).slice(-20), "base16")}`;
}
function instanceOfEcdsaSignature(object) {
  return typeof object === "object" && "r" in object && "s" in object;
}
function ES256SignerAlg() {
  return function sign(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature) {
        if (instanceOfEcdsaSignature(signature)) {
          return toJose(signature);
        } else {
          return signature;
        }
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
function ES256KSignerAlg(recoverable) {
  return function sign(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature) {
        if (instanceOfEcdsaSignature(signature)) {
          return toJose(signature, recoverable);
        } else {
          if (recoverable && typeof fromJose(signature).recoveryParam === "undefined") {
            throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`);
          }
          return signature;
        }
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
function Ed25519SignerAlg() {
  return function sign(payload, signer) {
    try {
      return Promise.resolve(signer(payload)).then(function(signature) {
        if (!instanceOfEcdsaSignature(signature)) {
          return signature;
        } else {
          throw new Error("invalid_config: expected a signer function that returns a string instead of signature object");
        }
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
var algorithms$1 = {
  ES256: ES256SignerAlg(),
  ES256K: ES256KSignerAlg(),
  // This is a non-standard algorithm but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/146
  "ES256K-R": ES256KSignerAlg(true),
  // This is actually incorrect but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/130
  Ed25519: Ed25519SignerAlg(),
  EdDSA: Ed25519SignerAlg()
};
function publicKeyToAddress$1(publicKey, otherAddress) {
  const version2 = bytesToHex2(base58ToBytes(otherAddress).slice(0, 1));
  const publicKeyBuffer = hexToBytes2(publicKey);
  const publicKeyHash = ripemd160(sha2563(publicKeyBuffer));
  const step1 = version2 + bytesToHex2(publicKeyHash);
  const step2 = sha2563(hexToBytes2(step1));
  const step3 = sha2563(step2);
  const checksum = bytesToHex2(step3).substring(0, 8);
  const step4 = step1 + checksum;
  return bytesToBase58(hexToBytes2(step4));
}
function publicKeyToAddress(publicKey, prefix) {
  const publicKeyBuffer = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes();
  const hash2 = ripemd160(sha2563(publicKeyBuffer));
  const words = bech32.toWords(hash2);
  return bech32.encode(prefix, words).replace(prefix, "");
}
function verifyBlockchainAccountId(publicKey, blockchainAccountId) {
  if (blockchainAccountId) {
    const chain2 = blockchainAccountId.split(":");
    switch (chain2[0]) {
      case "bip122":
        chain2[chain2.length - 1] = publicKeyToAddress$1(publicKey, chain2[chain2.length - 1]);
        break;
      case "cosmos":
        chain2[chain2.length - 1] = publicKeyToAddress(publicKey, chain2[1]);
        break;
      case "eip155":
        chain2[chain2.length - 1] = toEthereumAddress(publicKey);
        break;
      default:
        return false;
    }
    return chain2.join(":").toLowerCase() === blockchainAccountId.toLowerCase();
  }
  return false;
}
function toSignatureObject(signature, recoverable = false) {
  const rawSig = base64ToBytes(signature);
  if (rawSig.length !== (recoverable ? 65 : 64)) {
    throw new Error("wrong signature length");
  }
  const r2 = bytesToHex2(rawSig.slice(0, 32));
  const s2 = bytesToHex2(rawSig.slice(32, 64));
  const sigObj = {
    r: r2,
    s: s2
  };
  if (recoverable) {
    sigObj.recoveryParam = rawSig[64];
  }
  return sigObj;
}
function toSignatureObject2(signature, recoverable = false) {
  const bytes2 = base64ToBytes(signature);
  if (bytes2.length !== (recoverable ? 65 : 64)) {
    throw new Error("wrong signature length");
  }
  return {
    compact: bytes2.slice(0, 64),
    recovery: bytes2[64]
  };
}
function verifyES256(data, signature, authenticators) {
  const hash2 = sha2563(data);
  const sig = p256.Signature.fromCompact(toSignatureObject2(signature).compact);
  const fullPublicKeys = authenticators.filter((a2) => !a2.ethereumAddress && !a2.blockchainAccountId);
  const signer = fullPublicKeys.find((pk) => {
    try {
      const {
        keyBytes
      } = extractPublicKeyBytes(pk);
      return p256.verify(sig, hash2, keyBytes);
    } catch (err) {
      return false;
    }
  });
  if (!signer)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
function verifyES256K(data, signature, authenticators) {
  const hash2 = sha2563(data);
  const signatureNormalized = secp256k1.Signature.fromCompact(base64ToBytes(signature)).normalizeS();
  const fullPublicKeys = authenticators.filter((a2) => {
    return !a2.ethereumAddress && !a2.blockchainAccountId;
  });
  const blockchainAddressKeys = authenticators.filter((a2) => {
    return a2.ethereumAddress || a2.blockchainAccountId;
  });
  let signer = fullPublicKeys.find((pk) => {
    try {
      const {
        keyBytes
      } = extractPublicKeyBytes(pk);
      return secp256k1.verify(signatureNormalized, hash2, keyBytes);
    } catch (err) {
      return false;
    }
  });
  if (!signer && blockchainAddressKeys.length > 0) {
    signer = verifyRecoverableES256K(data, signature, blockchainAddressKeys);
  }
  if (!signer)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
function verifyRecoverableES256K(data, signature, authenticators) {
  const signatures = [];
  if (signature.length > 86) {
    signatures.push(toSignatureObject2(signature, true));
  } else {
    const so2 = toSignatureObject2(signature, false);
    signatures.push({
      ...so2,
      recovery: 0
    });
    signatures.push({
      ...so2,
      recovery: 1
    });
  }
  const hash2 = sha2563(data);
  const checkSignatureAgainstSigner = (sigObj) => {
    const signature2 = secp256k1.Signature.fromCompact(sigObj.compact).addRecoveryBit(sigObj.recovery || 0);
    const recoveredPublicKey = signature2.recoverPublicKey(hash2);
    const recoveredAddress = toEthereumAddress(recoveredPublicKey.toHex(false)).toLowerCase();
    const recoveredPublicKeyHex = recoveredPublicKey.toHex(false);
    const recoveredCompressedPublicKeyHex = recoveredPublicKey.toHex(true);
    return authenticators.find((a2) => {
      const {
        keyBytes
      } = extractPublicKeyBytes(a2);
      const keyHex = bytesToHex2(keyBytes);
      return keyHex === recoveredPublicKeyHex || keyHex === recoveredCompressedPublicKeyHex || a2.ethereumAddress?.toLowerCase() === recoveredAddress || a2.blockchainAccountId?.split("@eip155")?.[0].toLowerCase() === recoveredAddress || // CAIP-2
      verifyBlockchainAccountId(recoveredPublicKeyHex, a2.blockchainAccountId);
    });
  };
  for (const signature2 of signatures) {
    const verificationMethod = checkSignatureAgainstSigner(signature2);
    if (verificationMethod)
      return verificationMethod;
  }
  throw new Error("invalid_signature: Signature invalid for JWT");
}
function verifyEd25519(data, signature, authenticators) {
  const clear = stringToBytes(data);
  const signatureBytes = base64ToBytes(signature);
  const signer = authenticators.find((a2) => {
    const {
      keyBytes,
      keyType
    } = extractPublicKeyBytes(a2);
    if (keyType === "Ed25519") {
      return ed25519.verify(signatureBytes, clear, keyBytes);
    } else {
      return false;
    }
  });
  if (!signer)
    throw new Error("invalid_signature: Signature invalid for JWT");
  return signer;
}
var algorithms = {
  ES256: verifyES256,
  ES256K: verifyES256K,
  // This is a non-standard algorithm but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/146
  "ES256K-R": verifyRecoverableES256K,
  // This is actually incorrect but retained for backwards compatibility
  // see https://github.com/decentralized-identity/did-jwt/issues/130
  Ed25519: verifyEd25519,
  EdDSA: verifyEd25519
};
function VerifierAlgorithm(alg) {
  const impl = algorithms[alg];
  if (!impl)
    throw new Error(`not_supported: Unsupported algorithm ${alg}`);
  return impl;
}
VerifierAlgorithm.toSignatureObject = toSignatureObject;
var JWT_ERROR = {
  /**
   * Thrown when a JWT payload schema is unexpected or when validity period does not match
   */
  INVALID_JWT: "invalid_jwt",
  /**
   * Thrown when the verifier audience does not match the one set in the JWT payload
   */
  INVALID_AUDIENCE: "invalid_config",
  /**
   * Thrown when none of the public keys of the issuer match the signature of the JWT.
   *
   * This is equivalent to `NO_SUITABLE_KEYS` when the `proofPurpose` is NOT specified.
   */
  INVALID_SIGNATURE: "invalid_signature",
  /**
   * Thrown when the DID document of the issuer does not have any keys that match the signature for the given
   * `proofPurpose`.
   *
   * This is equivalent to `invalid_signature`, when a `proofPurpose` is specified.
   */
  NO_SUITABLE_KEYS: "no_suitable_keys",
  /**
   * Thrown when the `alg` of the JWT or the encoding of the key is not supported
   */
  NOT_SUPPORTED: "not_supported",
  /**
   * Thrown when the DID resolver is unable to resolve the issuer DID.
   */
  RESOLVER_ERROR: "resolver_error"
};
var _iteratorSymbol$1 = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

// node_modules/.pnpm/did-jwt-vc@4.0.4/node_modules/did-jwt-vc/lib/index.module.js
var VC_ERROR = {
  /**
   * Thrown when the credential or presentation being verified does not conform to the data model defined by
   * {@link https://www.w3.org/TR/vc-data-model/ | the spec}
   */
  SCHEMA_ERROR: "schema_error",
  /**
   * Thrown when the input is not a JWT string
   */
  FORMAT_ERROR: "format_error",
  /**
   * Thrown when verifying a presentation where `challenge` and/or `domain` don't match the expected values.
   */
  AUTH_ERROR: "auth_error"
};
var VC_JWT_ERROR = {
  ...VC_ERROR,
  ...JWT_ERROR
};

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/vendor/base-x.js
function base3(ALPHABET, name3) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode13(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size2 - length4;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length4;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode16(string3) {
    var buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name3} character`);
  }
  return {
    encode: encode13,
    decodeUnsafe,
    decode: decode16
  };
}
var src2 = base3;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bytes.js
var empty2 = new Uint8Array(0);
var equals4 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii2 = 0; ii2 < aa.byteLength; ii2++) {
    if (aa[ii2] !== bb[ii2]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString3 = (str) => new TextEncoder().encode(str);
var toString3 = (b2) => new TextDecoder().decode(b2);

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base.js
var Encoder2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name3, prefix, baseEncode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name3, prefix, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder2 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or3 = (left, right) => new ComposedDecoder2(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name3, prefix, baseEncode, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name3, prefix, baseEncode);
    this.decoder = new Decoder2(name3, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from3 = ({ name: name3, prefix, encode: encode13, decode: decode16 }) => new Codec2(name3, prefix, encode13, decode16);
var baseX2 = ({ prefix, name: name3, alphabet: alphabet4 }) => {
  const { encode: encode13, decode: decode16 } = base_x_default2(alphabet4, name3);
  return from3({
    prefix,
    name: name3,
    encode: encode13,
    /**
     * @param {string} text
     */
    decode: (text) => coerce2(decode16(text))
  });
};
var decode7 = (string3, alphabet4, bitsPerChar, name3) => {
  const codes = {};
  for (let i2 = 0; i2 < alphabet4.length; ++i2) {
    codes[alphabet4[i2]] = i2;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string3[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name3} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode6 = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46482 = ({ name: name3, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from3({
    prefix,
    name: name3,
    encode(input) {
      return encode6(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode7(input, alphabet4, bitsPerChar, name3);
    }
  });
};

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base32.js
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/vendor/varint.js
var encode_12 = encode7;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode7(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode7.bytes = offset - oldOffset + 1;
  return out;
}
var decode8 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf.length;
  do {
    if (counter >= l2) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf[counter++];
    res += shift < 28 ? (b2 & REST$12) << shift : (b2 & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode8,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/varint.js
var decode9 = (data, offset = 0) => {
  const code4 = varint_default2.decode(data, offset);
  return [code4, varint_default2.decode.bytes];
};
var encodeTo2 = (int, target, offset = 0) => {
  varint_default2.encode(int, target, offset);
  return target;
};
var encodingLength2 = (int) => {
  return varint_default2.encodingLength(int);
};

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/hashes/digest.js
var create2 = (code4, digest3) => {
  const size2 = digest3.byteLength;
  const sizeOffset = encodingLength2(code4);
  const digestOffset = sizeOffset + encodingLength2(size2);
  const bytes2 = new Uint8Array(digestOffset + size2);
  encodeTo2(code4, bytes2, 0);
  encodeTo2(size2, bytes2, sizeOffset);
  bytes2.set(digest3, digestOffset);
  return new Digest2(code4, size2, digest3, bytes2);
};
var decode10 = (multihash) => {
  const bytes2 = coerce2(multihash);
  const [code4, sizeOffset] = decode9(bytes2);
  const [size2, digestOffset] = decode9(bytes2.subarray(sizeOffset));
  const digest3 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code4, size2, digest3, bytes2);
};
var equals5 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b2
    );
    return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals4(a2.bytes, data.bytes);
  }
};
var Digest2 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code4, size2, digest3, bytes2) {
    this.code = code4;
    this.size = size2;
    this.digest = digest3;
    this.bytes = bytes2;
  }
};

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/cid.js
var format = (link, base5) => {
  const { bytes: bytes2, version: version2 } = link;
  switch (version2) {
    case 0:
      return toStringV02(
        bytes2,
        baseCache(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base5 || base58btc2.encoder
      );
    default:
      return toStringV12(
        bytes2,
        baseCache(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base5 || base322.encoder
      );
  }
};
var cache = /* @__PURE__ */ new WeakMap();
var baseCache = (cid) => {
  const baseCache3 = cache.get(cid);
  if (baseCache3 == null) {
    const baseCache4 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache4);
    return baseCache4;
  }
  return baseCache3;
};
var CID2 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   */
  constructor(version2, code4, multihash, bytes2) {
    this.code = code4;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code4, multihash } = this;
        if (code4 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code4, digest: digest3 } = this.multihash;
        const multihash = create2(code4, digest3);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals5(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base5) {
    return format(this, base5);
  }
  /**
   * @returns {API.LinkJSON<this>}
   */
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version2, code: code4, multihash, bytes: bytes2 } = value;
      return new _CID(
        version2,
        code4,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes2 || encodeCID2(version2, code4, multihash.bytes)
      );
    } else if (value[cidSymbol2] === true) {
      const { version: version2, multihash, code: code4 } = value;
      const digest3 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode10(multihash)
      );
      return _CID.create(version2, code4, digest3);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version2, code4, digest3) {
    if (typeof code4 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest3.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version2) {
      case 0: {
        if (code4 !== DAG_PB_CODE2) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`
          );
        } else {
          return new _CID(version2, code4, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID2(version2, code4, digest3.bytes);
        return new _CID(version2, code4, digest3, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest3) {
    return _CID.create(0, DAG_PB_CODE2, digest3);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code4, digest3) {
    return _CID.create(1, code4, digest3);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest3 = new Digest2(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest3
    ) : _CID.createV1(specs.codec, digest3);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length4] = decode9(initialBytes.subarray(offset));
      offset += length4;
      return i2;
    };
    let version2 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE2
    );
    if (
      /** @type {number} */
      version2 === 18
    ) {
      version2 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return { version: version2, codec, multihashCode, digestSize, multihashSize, size: size2 };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base5) {
    const [prefix, bytes2] = parseCIDtoBytes2(source, base5);
    const cid = _CID.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes2 = (source, base5) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base5 || base58btc2;
      return [
        /** @type {Prefix} */
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base5 || base58btc2;
      return [
        /** @type {Prefix} */
        base58btc2.prefix,
        decoder.decode(source)
      ];
    }
    case base322.prefix: {
      const decoder = base5 || base322;
      return [
        /** @type {Prefix} */
        base322.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base5 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base5.decode(source)
      ];
    }
  }
};
var toStringV02 = (bytes2, cache3, base5) => {
  const { prefix } = base5;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base5.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes2).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV12 = (bytes2, cache3, base5) => {
  const { prefix } = base5;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes2);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
var encodeCID2 = (version2, code4, multihash) => {
  const codeOffset = encodingLength2(version2);
  const hashOffset = codeOffset + encodingLength2(code4);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version2, bytes2, 0);
  encodeTo2(code4, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

// node_modules/.pnpm/@ipld+dag-pb@4.0.6/node_modules/@ipld/dag-pb/src/pb-decode.js
var textDecoder2 = new TextDecoder();

// node_modules/.pnpm/@ipld+dag-pb@4.0.6/node_modules/@ipld/dag-pb/src/pb-encode.js
var textEncoder2 = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;

// node_modules/.pnpm/@ipld+dag-pb@4.0.6/node_modules/@ipld/dag-pb/src/util.js
var textEncoder3 = new TextEncoder();

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/bytes.js
var empty3 = new Uint8Array(0);
function equals6(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii2 = 0; ii2 < aa.byteLength; ii2++) {
    if (aa[ii2] !== bb[ii2]) {
      return false;
    }
  }
  return true;
}
function coerce3(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/vendor/varint.js
var encode_13 = encode8;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode8(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode8.bytes = offset - oldOffset + 1;
  return out;
}
var decode11 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf.length;
  do {
    if (counter >= l2) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf[counter++];
    res += shift < 28 ? (b2 & REST$13) << shift : (b2 & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode11,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/varint.js
function decode12(data, offset = 0) {
  const code4 = varint_default3.decode(data, offset);
  return [code4, varint_default3.decode.bytes];
}
function encodeTo3(int, target, offset = 0) {
  varint_default3.encode(int, target, offset);
  return target;
}
function encodingLength3(int) {
  return varint_default3.encodingLength(int);
}

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/hashes/digest.js
function create3(code4, digest3) {
  const size2 = digest3.byteLength;
  const sizeOffset = encodingLength3(code4);
  const digestOffset = sizeOffset + encodingLength3(size2);
  const bytes2 = new Uint8Array(digestOffset + size2);
  encodeTo3(code4, bytes2, 0);
  encodeTo3(size2, bytes2, sizeOffset);
  bytes2.set(digest3, digestOffset);
  return new Digest3(code4, size2, digest3, bytes2);
}
function decode13(multihash) {
  const bytes2 = coerce3(multihash);
  const [code4, sizeOffset] = decode12(bytes2);
  const [size2, digestOffset] = decode12(bytes2.subarray(sizeOffset));
  const digest3 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest3.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code4, size2, digest3, bytes2);
}
function equals7(a2, b2) {
  if (a2 === b2) {
    return true;
  } else {
    const data = b2;
    return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals6(a2.bytes, data.bytes);
  }
}
var Digest3 = class {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code4, size2, digest3, bytes2) {
    this.code = code4;
    this.size = size2;
    this.digest = digest3;
    this.bytes = bytes2;
  }
};

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/vendor/base-x.js
function base4(ALPHABET, name3) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode13(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size2 - length4;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length4;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode16(string3) {
    var buffer = decodeUnsafe(string3);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name3} character`);
  }
  return {
    encode: encode13,
    decodeUnsafe,
    decode: decode16
  };
}
var src3 = base4;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/bases/base.js
var Encoder3 = class {
  name;
  prefix;
  baseEncode;
  constructor(name3, prefix, baseEncode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name3, prefix, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder3 = class {
  decoders;
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or4(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or4(left, right) {
  return new ComposedDecoder3({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec3 = class {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name3, prefix, baseEncode, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name3, prefix, baseEncode);
    this.decoder = new Decoder3(name3, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from4({ name: name3, prefix, encode: encode13, decode: decode16 }) {
  return new Codec3(name3, prefix, encode13, decode16);
}
function baseX3({ name: name3, prefix, alphabet: alphabet4 }) {
  const { encode: encode13, decode: decode16 } = base_x_default3(alphabet4, name3);
  return from4({
    prefix,
    name: name3,
    encode: encode13,
    decode: (text) => coerce3(decode16(text))
  });
}
function decode14(string3, alphabet4, bitsPerChar, name3) {
  const codes = {};
  for (let i2 = 0; i2 < alphabet4.length; ++i2) {
    codes[alphabet4[i2]] = i2;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value = codes[string3[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name3} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode9(data, alphabet4, bitsPerChar) {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet4[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46483({ name: name3, prefix, bitsPerChar, alphabet: alphabet4 }) {
  return from4({
    prefix,
    name: name3,
    encode(input) {
      return encode9(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode14(input, alphabet4, bitsPerChar, name3);
    }
  });
}

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/bases/base32.js
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/bases/base58.js
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@13.1.0/node_modules/multiformats/dist/src/cid.js
function format2(link, base5) {
  const { bytes: bytes2, version: version2 } = link;
  switch (version2) {
    case 0:
      return toStringV03(bytes2, baseCache2(link), base5 ?? base58btc3.encoder);
    default:
      return toStringV13(bytes2, baseCache2(link), base5 ?? base323.encoder);
  }
}
var cache2 = /* @__PURE__ */ new WeakMap();
function baseCache2(cid) {
  const baseCache3 = cache2.get(cid);
  if (baseCache3 == null) {
    const baseCache4 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache4);
    return baseCache4;
  }
  return baseCache3;
}
var CID3 = class _CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version2, code4, multihash, bytes2) {
    this.code = code4;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code4, multihash } = this;
        if (code4 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code4, digest: digest3 } = this.multihash;
        const multihash = create3(code4, digest3);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals7(self2.multihash, unknown.multihash);
  }
  toString(base5) {
    return format2(this, base5);
  }
  toJSON() {
    return { "/": format2(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = input;
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version2, code: code4, multihash, bytes: bytes2 } = value;
      return new _CID(version2, code4, multihash, bytes2 ?? encodeCID3(version2, code4, multihash.bytes));
    } else if (value[cidSymbol3] === true) {
      const { version: version2, multihash, code: code4 } = value;
      const digest3 = decode13(multihash);
      return _CID.create(version2, code4, digest3);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version2, code4, digest3) {
    if (typeof code4 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest3.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version2) {
      case 0: {
        if (code4 !== DAG_PB_CODE3) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
        } else {
          return new _CID(version2, code4, digest3, digest3.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID3(version2, code4, digest3.bytes);
        return new _CID(version2, code4, digest3, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest3) {
    return _CID.create(0, DAG_PB_CODE3, digest3);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code4, digest3) {
    return _CID.create(1, code4, digest3);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest3 = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest3) : _CID.createV1(specs.codec, digest3);
    return [cid, bytes2.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length4] = decode12(initialBytes.subarray(offset));
      offset += length4;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE3;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return { version: version2, codec, multihashCode, digestSize, multihashSize, size: size2 };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base5) {
    const [prefix, bytes2] = parseCIDtoBytes3(source, base5);
    const cid = _CID.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes3(source, base5) {
  switch (source[0]) {
    case "Q": {
      const decoder = base5 ?? base58btc3;
      return [
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base5 ?? base58btc3;
      return [base58btc3.prefix, decoder.decode(source)];
    }
    case base323.prefix: {
      const decoder = base5 ?? base323;
      return [base323.prefix, decoder.decode(source)];
    }
    default: {
      if (base5 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base5.decode(source)];
    }
  }
}
function toStringV03(bytes2, cache3, base5) {
  const { prefix } = base5;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base5.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes2).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV13(bytes2, cache3, base5) {
  const { prefix } = base5;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base5.encode(bytes2);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
function encodeCID3(version2, code4, multihash) {
  const codeOffset = encodingLength3(version2);
  const hashOffset = codeOffset + encodingLength3(code4);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version2, bytes2, 0);
  encodeTo3(code4, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
}
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/.pnpm/ipfs-unixfs@11.1.0/node_modules/ipfs-unixfs/dist/src/index.js
var import_err_code = __toESM(require_err_code(), 1);

// node_modules/.pnpm/protons-runtime@5.0.3_uint8arraylist@2.4.3/node_modules/protons-runtime/dist/src/utils.js
var import_reader = __toESM(require_reader(), 1);
var import_reader_buffer = __toESM(require_reader_buffer(), 1);
var import_minimal = __toESM(require_minimal(), 1);
var import_writer = __toESM(require_writer(), 1);
var import_writer_buffer = __toESM(require_writer_buffer(), 1);
function configure() {
  import_minimal.default._configure();
  import_reader.default._configure(import_reader_buffer.default);
  import_writer.default._configure(import_writer_buffer.default);
}
configure();
var methods = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader(buf) {
  return patchReader(new import_reader.default(buf));
}
function patchWriter(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer() {
  return patchWriter(import_writer.default.create());
}

// node_modules/.pnpm/protons-runtime@5.0.3_uint8arraylist@2.4.3/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf, codec) {
  const r2 = reader(buf instanceof Uint8Array ? buf : buf.subarray());
  return codec.decode(r2);
}

// node_modules/.pnpm/protons-runtime@5.0.3_uint8arraylist@2.4.3/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message2, codec) {
  const w2 = writer();
  codec.encode(message2, w2, {
    lengthDelimited: false
  });
  return w2.finish();
}

// node_modules/.pnpm/protons-runtime@5.0.3_uint8arraylist@2.4.3/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec2(name3, type, encode13, decode16) {
  return {
    name: name3,
    type,
    encode: encode13,
    decode: decode16
  };
}

// node_modules/.pnpm/protons-runtime@5.0.3_uint8arraylist@2.4.3/node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v2) {
  function findValue(val) {
    if (v2[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v2[val];
  }
  const encode13 = function enumEncode(val, writer2) {
    const enumValue = findValue(val);
    writer2.int32(enumValue);
  };
  const decode16 = function enumDecode(reader2) {
    const val = reader2.int32();
    return findValue(val);
  };
  return createCodec2("enum", CODEC_TYPES.VARINT, encode13, decode16);
}

// node_modules/.pnpm/protons-runtime@5.0.3_uint8arraylist@2.4.3/node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode13, decode16) {
  return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode13, decode16);
}

// node_modules/.pnpm/ipfs-unixfs@11.1.0/node_modules/ipfs-unixfs/dist/src/unixfs.js
var Data;
(function(Data2) {
  let DataType;
  (function(DataType2) {
    DataType2["Raw"] = "Raw";
    DataType2["Directory"] = "Directory";
    DataType2["File"] = "File";
    DataType2["Metadata"] = "Metadata";
    DataType2["Symlink"] = "Symlink";
    DataType2["HAMTShard"] = "HAMTShard";
  })(DataType = Data2.DataType || (Data2.DataType = {}));
  let __DataTypeValues;
  (function(__DataTypeValues2) {
    __DataTypeValues2[__DataTypeValues2["Raw"] = 0] = "Raw";
    __DataTypeValues2[__DataTypeValues2["Directory"] = 1] = "Directory";
    __DataTypeValues2[__DataTypeValues2["File"] = 2] = "File";
    __DataTypeValues2[__DataTypeValues2["Metadata"] = 3] = "Metadata";
    __DataTypeValues2[__DataTypeValues2["Symlink"] = 4] = "Symlink";
    __DataTypeValues2[__DataTypeValues2["HAMTShard"] = 5] = "HAMTShard";
  })(__DataTypeValues || (__DataTypeValues = {}));
  (function(DataType2) {
    DataType2.codec = () => {
      return enumeration(__DataTypeValues);
    };
  })(DataType = Data2.DataType || (Data2.DataType = {}));
  let _codec;
  Data2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          Data2.DataType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (obj.filesize != null) {
          w2.uint32(24);
          w2.uint64(obj.filesize);
        }
        if (obj.blocksizes != null) {
          for (const value of obj.blocksizes) {
            w2.uint32(32);
            w2.uint64(value);
          }
        }
        if (obj.hashType != null) {
          w2.uint32(40);
          w2.uint64(obj.hashType);
        }
        if (obj.fanout != null) {
          w2.uint32(48);
          w2.uint64(obj.fanout);
        }
        if (obj.mode != null) {
          w2.uint32(56);
          w2.uint32(obj.mode);
        }
        if (obj.mtime != null) {
          w2.uint32(66);
          UnixTime.codec().encode(obj.mtime, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          blocksizes: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = Data2.DataType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            case 3:
              obj.filesize = reader2.uint64();
              break;
            case 4:
              obj.blocksizes.push(reader2.uint64());
              break;
            case 5:
              obj.hashType = reader2.uint64();
              break;
            case 6:
              obj.fanout = reader2.uint64();
              break;
            case 7:
              obj.mode = reader2.uint32();
              break;
            case 8:
              obj.mtime = UnixTime.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Data2.encode = (obj) => {
    return encodeMessage(obj, Data2.codec());
  };
  Data2.decode = (buf) => {
    return decodeMessage(buf, Data2.codec());
  };
})(Data || (Data = {}));
var UnixTime;
(function(UnixTime2) {
  let _codec;
  UnixTime2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Seconds != null) {
          w2.uint32(8);
          w2.int64(obj.Seconds);
        }
        if (obj.FractionalNanoseconds != null) {
          w2.uint32(21);
          w2.fixed32(obj.FractionalNanoseconds);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Seconds = reader2.int64();
              break;
            case 2:
              obj.FractionalNanoseconds = reader2.fixed32();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  UnixTime2.encode = (obj) => {
    return encodeMessage(obj, UnixTime2.codec());
  };
  UnixTime2.decode = (buf) => {
    return decodeMessage(buf, UnixTime2.codec());
  };
})(UnixTime || (UnixTime = {}));
var Metadata;
(function(Metadata2) {
  let _codec;
  Metadata2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.MimeType != null) {
          w2.uint32(10);
          w2.string(obj.MimeType);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.MimeType = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata2.encode = (obj) => {
    return encodeMessage(obj, Metadata2.codec());
  };
  Metadata2.decode = (buf) => {
    return decodeMessage(buf, Metadata2.codec());
  };
})(Metadata || (Metadata = {}));

// node_modules/.pnpm/ipfs-unixfs@11.1.0/node_modules/ipfs-unixfs/dist/src/index.js
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);

// node_modules/.pnpm/@veramo+utils@6.0.0/node_modules/@veramo/utils/build/did-utils.js
var import_debug = __toESM(require_browser(), 1);

// node_modules/.pnpm/uint8arrays@4.0.6/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array2(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/.pnpm/uint8arrays@4.0.6/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe2(size2 = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array2(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}

// node_modules/.pnpm/uint8arrays@4.0.6/node_modules/uint8arrays/dist/src/concat.js
function concat2(arrays, length4) {
  if (length4 == null) {
    length4 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe2(length4);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output2);
}

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
var base102 = baseX2({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162 = rfc46482({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc46482({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base22
});
var base22 = rfc46482({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = (
  /** @type {string[]} */
  alphabet3.reduce(
    (p2, c2, i2) => {
      p2[i2] = c2;
      return p2;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes2 = (
  /** @type {number[]} */
  alphabet3.reduce(
    (p2, c2, i2) => {
      p2[
        /** @type {number} */
        c2.codePointAt(0)
      ] = i2;
      return p2;
    },
    /** @type {number[]} */
    []
  )
);
function encode11(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars2[c2];
    return p2;
  }, "");
}
function decode15(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji2 = from3({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode11,
  decode: decode15
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base642,
  base64pad: () => base64pad2,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad2
});
var base642 = rfc46482({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46482({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46482({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46482({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82 = rfc46482({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
var identity3 = from3({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString3(buf),
  decode: (str) => fromString3(str)
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/codecs/json.js
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});
var code3 = 0;
var name2 = "identity";
var encode12 = coerce2;
var digest2 = (input) => create2(code3, encode12(input));
var identity4 = { code: code3, name: name2, encode: encode12, digest: digest2 };

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2564,
  sha512: () => sha5123
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/hashes/hasher.js
var from5 = ({ name: name3, code: code4, encode: encode13 }) => new Hasher2(name3, code4, encode13);
var Hasher2 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name3, code4, encode13) {
    this.name = name3;
    this.code = code4;
    this.encode = encode13;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest3) => create2(this.code, digest3));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2 = (name3) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name3, data))
);
var sha2564 = from5({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5123 = from5({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/.pnpm/multiformats@12.1.1/node_modules/multiformats/src/basics.js
var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

// node_modules/.pnpm/uint8arrays@4.0.6/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec3(name3, prefix, encode13, decode16) {
  return {
    name: name3,
    prefix,
    encoder: {
      name: name3,
      prefix,
      encode: encode13
    },
    decoder: {
      decode: decode16
    }
  };
}
var string2 = createCodec3("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii2 = createCodec3("ascii", "a", (buf) => {
  let string3 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string3 += String.fromCharCode(buf[i2]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe2(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases2.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases2
};
var bases_default2 = BASES2;

// node_modules/.pnpm/uint8arrays@4.0.6/node_modules/uint8arrays/dist/src/from-string.js
function fromString4(string3, encoding = "utf8") {
  const base5 = bases_default2[encoding];
  if (base5 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array2(globalThis.Buffer.from(string3, "utf-8"));
  }
  return base5.decoder.decode(`${base5.prefix}${string3}`);
}

// node_modules/.pnpm/uint8arrays@4.0.6/node_modules/uint8arrays/dist/src/to-string.js
function toString4(array, encoding = "utf8") {
  const base5 = bases_default2[encoding];
  if (base5 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base5.encoder.encode(array).substring(1);
}

// node_modules/.pnpm/@veramo+utils@6.0.0/node_modules/@veramo/utils/build/encodings.js
var u8a2 = { toString: toString4, fromString: fromString4, concatArrays: concat2 };
function decodeBase64url(s2) {
  return u8a2.toString(base64ToBytes(s2));
}

// node_modules/.pnpm/@veramo+utils@6.0.0/node_modules/@veramo/utils/build/did-utils.js
var debug = (0, import_debug.default)("veramo:utils");

// src/components/CreateChessGame.tsx
var import_uuid = __toESM(require_uuid(), 1);
var import_react_router_dom = __toESM(require_react_router_dom(), 1);

// src/constants.ts
var CHESS_INVITE_MESSAGE_TYPE = "https://didcomm.org/chess/1.0/invite";
var CHESS_MOVE_MESSAGE_TYPE = "https://didcomm.org/chess/1.0/move";

// src/components/CreateChessGame.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var CreateChessGame = ({ onOk, initialIssuer }) => {
  const { notification: notification2 } = import_antd.App.useApp();
  const token = import_antd.theme.useToken();
  const navigate = (0, import_react_router_dom.useNavigate)();
  const { agent } = (0, import_veramo_react.useVeramo)();
  const [isSaving, setIsSaving] = (0, import_react4.useState)(false);
  const [form] = import_antd.Form.useForm();
  const [options, setOptions] = (0, import_react4.useState)([]);
  const [opponent, setOpponent] = (0, import_react4.useState)("");
  const [showQrCodeScanner, setShowQrCodeScanner] = (0, import_react4.useState)(false);
  const searchResult = async (query) => {
    const response = await agent?.discoverDid({ query });
    const dids = response?.results.map((r2) => r2.matches.map((m2) => m2.did)).flat() ?? [];
    console.log("dids: ", dids);
    const selectOptions = [];
    new Set(dids).forEach((did) => {
      selectOptions.push({
        value: did,
        label: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between"
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: (0, import_agent_explorer_plugin2.shortId)(did) })
          }
        )
      });
    });
    return selectOptions;
  };
  const handleSearch = async (value) => {
    setOptions(value ? await searchResult(value) : []);
  };
  const handleQrCodeResult = async (result) => {
    const parsed = (0, import_url_parse.default)(result, true);
    if (parsed?.query?._oob) {
      const decoded = decodeBase64url(parsed?.query?._oob);
      try {
        const message2 = JSON.parse(decoded);
        if (message2.from && message2.type === "https://didcomm.org/out-of-band/2.0/invitation") {
          setOpponent(message2.from);
        }
      } catch (e2) {
        console.log(e2);
      }
    } else {
      setOpponent("");
    }
  };
  const handleCreatePost = async (issuerDID, issuerAgent) => {
    setIsSaving(true);
    try {
      const identifier = await issuerAgent?.didManagerGet({ did: issuerDID });
      const usableProofs = await issuerAgent?.listUsableProofFormats(identifier);
      const proofFormat = usableProofs?.includes("jwt") ? "jwt" : usableProofs[0];
      const credential = await agent?.createVerifiableCredential({
        save: true,
        proofFormat,
        credential: {
          "@context": ["https://www.w3.org/2018/credentials/v1"],
          type: ["VerifiableCredential", "ChessGameInvite"],
          issuer: { id: issuerDID },
          issuanceDate: (/* @__PURE__ */ new Date()).toISOString(),
          credentialSubject: {
            white: issuerDID,
            black: opponent
          }
        }
      });
      console.log("credential: ", credential);
      if (credential) {
        const credhash = await agent?.dataStoreSaveVerifiableCredential({ verifiableCredential: credential });
        console.log("credhash: ", credhash);
        const shareMessage = {
          type: CHESS_INVITE_MESSAGE_TYPE,
          from: issuerDID,
          created_time: (/* @__PURE__ */ new Date()).getTime(),
          to: opponent,
          id: (0, import_uuid.v4)(),
          thid: credhash,
          body: { content: "Lets play chess!" },
          attachments: [{
            media_type: "credential+ld+json",
            data: { json: credential }
          }]
        };
        const packedMessage = await issuerAgent.packDIDCommMessage({
          message: shareMessage,
          packing: "authcrypt"
        });
        const res = await issuerAgent.sendDIDCommMessage({
          packedMessage,
          messageId: shareMessage.id,
          recipientDidUrl: opponent
        });
        await issuerAgent.dataStoreSaveMessage({ message: {
          type: shareMessage.type,
          from: issuerDID,
          to: opponent,
          id: shareMessage.id,
          threadId: shareMessage.thid,
          data: { content: shareMessage.body.content },
          attachments: shareMessage.attachments
        } });
        notification2.success({
          message: "Message sent"
        });
        navigate(`/chess/games/${credhash}`);
      }
    } catch (e2) {
      console.error(e2);
    }
    setIsSaving(false);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_antd.Col, { children: [
    !showQrCodeScanner && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_antd.Row, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_antd.AutoComplete,
        {
          popupMatchSelectWidth: true,
          options,
          onSelect: (e2) => setOpponent(e2),
          onSearch: handleSearch,
          style: { flex: 1 },
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_antd.Input,
            {
              value: opponent,
              placeholder: "Enter a DID",
              onChange: (e2) => setOpponent(e2.target.value),
              style: {
                flex: 1,
                paddingTop: 10,
                paddingBottom: 10
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_antd.Button, { onClick: () => setShowQrCodeScanner(true), size: "large", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(QrcodeOutlined_default2, {}) })
    ] }),
    showQrCodeScanner && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_antd.Col, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      Gi,
      {
        onDecode: (result) => {
          setShowQrCodeScanner(false);
          setTimeout(() => {
            handleQrCodeResult(result);
          }, 125);
        },
        onError: (error) => {
          notification2.error({ message: error.message });
        }
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_agent_explorer_plugin.ActionButton,
      {
        title: "Create Game and Send to Opponent:",
        disabled: !opponent || isSaving,
        onAction: handleCreatePost
      }
    )
  ] });
};

// src/components/Games.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var Games = () => {
  const { notification: notification2 } = import_antd2.App.useApp();
  const [drawerOpen, setDrawerOpen] = (0, import_react5.useState)(false);
  const [pageSize, setPageSize] = import_react5.default.useState(10);
  const [page, setPage] = import_react5.default.useState(1);
  const navigate = (0, import_react_router_dom2.useNavigate)();
  const { agent } = (0, import_veramo_react2.useVeramo)();
  const { data: credentialsCount } = (0, import_react_query.useQuery)(
    ["credentialsCount", { agentId: agent?.context.name }],
    () => agent?.dataStoreORMGetVerifiableCredentialsCount({
      where: [{ column: "type", value: ["VerifiableCredential,ChessGameInvite"] }]
    })
  );
  const { data: credentials, isLoading, refetch } = (0, import_react_query.useQuery)(
    ["witness-polls", { agentId: agent?.context.name }],
    () => agent?.dataStoreORMGetVerifiableCredentials({
      where: [{ column: "type", value: ["VerifiableCredential,ChessGameInvite"] }],
      order: [{ column: "issuanceDate", direction: "DESC" }]
    })
  );
  const handleNewPost = async (hash2) => {
    console.log("handle new post.");
    notification2.success({
      message: "Poll created"
    });
    setDrawerOpen(false);
    await refetch();
    navigate(`/witness/poll/${hash2}`);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
    import_pro_components.PageContainer,
    {
      extra: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          import_antd2.Button,
          {
            icon: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(PlusOutlined_default2, {}),
            type: "primary",
            title: "Compose new post",
            onClick: () => setDrawerOpen(true),
            children: "Compose"
          },
          "add"
        )
      ],
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          import_antd2.List,
          {
            itemLayout: "vertical",
            size: "large",
            pagination: {
              position: "both",
              pageSize,
              current: page,
              total: credentialsCount,
              showSizeChanger: true,
              onChange(page2, pageSize2) {
                setPage(page2);
                setPageSize(pageSize2);
              }
            },
            dataSource: credentials,
            renderItem: (item) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { style: { marginTop: "20px", marginBottom: "20px", height: "500px", width: "500px" }, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_agent_explorer_plugin3.VerifiableCredentialComponent, { credential: item }) })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          import_antd2.Drawer,
          {
            title: "Create new Game",
            placement: "right",
            onClose: () => setDrawerOpen(false),
            open: drawerOpen,
            width: 800,
            destroyOnClose: true,
            children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(CreateChessGame, { onOk: handleNewPost })
          }
        )
      ]
    }
  );
};

// src/components/ChessGame.tsx
var React9 = __toESM(require_react(), 1);
var import_antd3 = __toESM(require_antd(), 1);
var import_veramo_react3 = __toESM(require_veramo_react(), 1);
var import_react_query2 = __toESM(require_react_query(), 1);
var import_chess = __toESM(require_chess(), 1);

// node_modules/.pnpm/react-chessboard@4.5.0_@types+react@18.2.21_react-dom@18.2.0_react@18.2.0/node_modules/react-chessboard/dist/index.esm.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
var DndContext = (0, import_react6.createContext)({
  dragDropManager: void 0
});
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  var constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  var typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function warning3(message2) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message2);
  }
  try {
    throw new Error(message2);
  } catch (e2) {
  }
}
function isCrushed() {
}
if (typeof isCrushed.name === "string" && isCrushed.name !== "isCrushed") {
  warning3('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
}
function invariant(condition, format3, ...args) {
  if (isProduction()) {
    if (format3 === void 0) {
      throw new Error("invariant requires an error message argument");
    }
  }
  if (!condition) {
    let error;
    if (format3 === void 0) {
      error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    } else {
      let argIndex = 0;
      error = new Error(format3.replace(/%s/g, function() {
        return args[argIndex++];
      }));
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
}
function isProduction() {
  return typeof process !== "undefined" && false;
}
function get(obj, path, defaultValue) {
  return path.split(".").reduce(
    (a2, c2) => a2 && a2[c2] ? a2[c2] : defaultValue || null,
    obj
  );
}
function without$1(items, item) {
  return items.filter(
    (i2) => i2 !== item
  );
}
function isObject(input) {
  return typeof input === "object";
}
function xor3(itemsA, itemsB) {
  const map = /* @__PURE__ */ new Map();
  const insertItem = (item) => {
    map.set(item, map.has(item) ? map.get(item) + 1 : 1);
  };
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  map.forEach((count, key) => {
    if (count === 1) {
      result.push(key);
    }
  });
  return result;
}
function intersection(itemsA, itemsB) {
  return itemsA.filter(
    (t2) => itemsB.indexOf(t2) > -1
  );
}
var INIT_COORDS = "dnd-core/INIT_COORDS";
var BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
var PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
var HOVER = "dnd-core/HOVER";
var DROP = "dnd-core/DROP";
var END_DRAG = "dnd-core/END_DRAG";
function setClientOffset(clientOffset, sourceClientOffset) {
  return {
    type: INIT_COORDS,
    payload: {
      sourceClientOffset: sourceClientOffset || null,
      clientOffset: clientOffset || null
    }
  };
}
var ResetCoordinatesAction = {
  type: INIT_COORDS,
  payload: {
    clientOffset: null,
    sourceClientOffset: null
  }
};
function createBeginDrag(manager) {
  return function beginDrag(sourceIds = [], options = {
    publishSource: true
  }) {
    const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    manager.dispatch(setClientOffset(clientOffset));
    verifyInvariants$1(sourceIds, monitor, registry);
    const sourceId = getDraggableSource(sourceIds, monitor);
    if (sourceId == null) {
      manager.dispatch(ResetCoordinatesAction);
      return;
    }
    let sourceClientOffset = null;
    if (clientOffset) {
      if (!getSourceClientOffset2) {
        throw new Error("getSourceClientOffset must be defined");
      }
      verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
      sourceClientOffset = getSourceClientOffset2(sourceId);
    }
    manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
    const source = registry.getSource(sourceId);
    const item = source.beginDrag(monitor, sourceId);
    if (item == null) {
      return void 0;
    }
    verifyItemIsObject(item);
    registry.pinSource(sourceId);
    const itemType = registry.getSourceType(sourceId);
    return {
      type: BEGIN_DRAG,
      payload: {
        itemType,
        item,
        sourceId,
        clientOffset: clientOffset || null,
        sourceClientOffset: sourceClientOffset || null,
        isSourcePublic: !!publishSource
      }
    };
  };
}
function verifyInvariants$1(sourceIds, monitor, registry) {
  invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
  sourceIds.forEach(function(sourceId) {
    invariant(registry.getSource(sourceId), "Expected sourceIds to be registered.");
  });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
  invariant(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
}
function verifyItemIsObject(item) {
  invariant(isObject(item), "Item must be an object.");
}
function getDraggableSource(sourceIds, monitor) {
  let sourceId = null;
  for (let i2 = sourceIds.length - 1; i2 >= 0; i2--) {
    if (monitor.canDragSource(sourceIds[i2])) {
      sourceId = sourceIds[i2];
      break;
    }
  }
  return sourceId;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    });
  }
  return target;
}
function createDrop(manager) {
  return function drop(options = {}) {
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    verifyInvariants(monitor);
    const targetIds = getDroppableTargets(monitor);
    targetIds.forEach((targetId, index) => {
      const dropResult = determineDropResult(targetId, index, registry, monitor);
      const action = {
        type: DROP,
        payload: {
          dropResult: _objectSpread$4({}, options, dropResult)
        }
      };
      manager.dispatch(action);
    });
  };
}
function verifyInvariants(monitor) {
  invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
}
function determineDropResult(targetId, index, registry, monitor) {
  const target = registry.getTarget(targetId);
  let dropResult = target ? target.drop(monitor, targetId) : void 0;
  verifyDropResultType(dropResult);
  if (typeof dropResult === "undefined") {
    dropResult = index === 0 ? {} : monitor.getDropResult();
  }
  return dropResult;
}
function verifyDropResultType(dropResult) {
  invariant(typeof dropResult === "undefined" || isObject(dropResult), "Drop result must either be an object or undefined.");
}
function getDroppableTargets(monitor) {
  const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
  targetIds.reverse();
  return targetIds;
}
function createEndDrag(manager) {
  return function endDrag() {
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    verifyIsDragging(monitor);
    const sourceId = monitor.getSourceId();
    if (sourceId != null) {
      const source = registry.getSource(sourceId, true);
      source.endDrag(monitor, sourceId);
      registry.unpinSource();
    }
    return {
      type: END_DRAG
    };
  };
}
function verifyIsDragging(monitor) {
  invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
}
function matchesType(targetType, draggedItemType) {
  if (draggedItemType === null) {
    return targetType === null;
  }
  return Array.isArray(targetType) ? targetType.some(
    (t2) => t2 === draggedItemType
  ) : targetType === draggedItemType;
}
function createHover(manager) {
  return function hover(targetIdsArg, { clientOffset } = {}) {
    verifyTargetIdsIsArray(targetIdsArg);
    const targetIds = targetIdsArg.slice(0);
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    const draggedItemType = monitor.getItemType();
    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
    checkInvariants(targetIds, monitor, registry);
    hoverAllTargets(targetIds, monitor, registry);
    return {
      type: HOVER,
      payload: {
        targetIds,
        clientOffset: clientOffset || null
      }
    };
  };
}
function verifyTargetIdsIsArray(targetIdsArg) {
  invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
}
function checkInvariants(targetIds, monitor, registry) {
  invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call hover after drop.");
  for (let i2 = 0; i2 < targetIds.length; i2++) {
    const targetId = targetIds[i2];
    invariant(targetIds.lastIndexOf(targetId) === i2, "Expected targetIds to be unique in the passed array.");
    const target = registry.getTarget(targetId);
    invariant(target, "Expected targetIds to be registered.");
  }
}
function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
  for (let i2 = targetIds.length - 1; i2 >= 0; i2--) {
    const targetId = targetIds[i2];
    const targetType = registry.getTargetType(targetId);
    if (!matchesType(targetType, draggedItemType)) {
      targetIds.splice(i2, 1);
    }
  }
}
function hoverAllTargets(targetIds, monitor, registry) {
  targetIds.forEach(function(targetId) {
    const target = registry.getTarget(targetId);
    target.hover(monitor, targetId);
  });
}
function createPublishDragSource(manager) {
  return function publishDragSource() {
    const monitor = manager.getMonitor();
    if (monitor.isDragging()) {
      return {
        type: PUBLISH_DRAG_SOURCE
      };
    }
    return;
  };
}
function createDragDropActions(manager) {
  return {
    beginDrag: createBeginDrag(manager),
    publishDragSource: createPublishDragSource(manager),
    hover: createHover(manager),
    drop: createDrop(manager),
    endDrag: createEndDrag(manager)
  };
}
var DragDropManagerImpl = class {
  receiveBackend(backend) {
    this.backend = backend;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const manager = this;
    const { dispatch } = this.store;
    function bindActionCreator(actionCreator) {
      return (...args) => {
        const action = actionCreator.apply(manager, args);
        if (typeof action !== "undefined") {
          dispatch(action);
        }
      };
    }
    const actions = createDragDropActions(this);
    return Object.keys(actions).reduce((boundActions, key) => {
      const action = actions[key];
      boundActions[key] = bindActionCreator(action);
      return boundActions;
    }, {});
  }
  dispatch(action) {
    this.store.dispatch(action);
  }
  constructor(store, monitor) {
    this.isSetUp = false;
    this.handleRefCountChange = () => {
      const shouldSetUp = this.store.getState().refCount > 0;
      if (this.backend) {
        if (shouldSetUp && !this.isSetUp) {
          this.backend.setup();
          this.isSetUp = true;
        } else if (!shouldSetUp && this.isSetUp) {
          this.backend.teardown();
          this.isSetUp = false;
        }
      }
    };
    this.store = store;
    this.monitor = monitor;
    store.subscribe(this.handleRefCountChange);
  }
};
function add2(a2, b2) {
  return {
    x: a2.x + b2.x,
    y: a2.y + b2.y
  };
}
function subtract(a2, b2) {
  return {
    x: a2.x - b2.x,
    y: a2.y - b2.y
  };
}
function getSourceClientOffset(state) {
  const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;
  if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
    return null;
  }
  return subtract(add2(clientOffset, initialSourceClientOffset), initialClientOffset);
}
function getDifferenceFromInitialOffset(state) {
  const { clientOffset, initialClientOffset } = state;
  if (!clientOffset || !initialClientOffset) {
    return null;
  }
  return subtract(clientOffset, initialClientOffset);
}
var NONE = [];
var ALL = [];
NONE.__IS_NONE__ = true;
ALL.__IS_ALL__ = true;
function areDirty(dirtyIds, handlerIds) {
  if (dirtyIds === NONE) {
    return false;
  }
  if (dirtyIds === ALL || typeof handlerIds === "undefined") {
    return true;
  }
  const commonIds = intersection(handlerIds, dirtyIds);
  return commonIds.length > 0;
}
var DragDropMonitorImpl = class {
  subscribeToStateChange(listener, options = {}) {
    const { handlerIds } = options;
    invariant(typeof listener === "function", "listener must be a function.");
    invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
    let prevStateId = this.store.getState().stateId;
    const handleChange = () => {
      const state = this.store.getState();
      const currentStateId = state.stateId;
      try {
        const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
        if (!canSkipListener) {
          listener();
        }
      } finally {
        prevStateId = currentStateId;
      }
    };
    return this.store.subscribe(handleChange);
  }
  subscribeToOffsetChange(listener) {
    invariant(typeof listener === "function", "listener must be a function.");
    let previousState = this.store.getState().dragOffset;
    const handleChange = () => {
      const nextState = this.store.getState().dragOffset;
      if (nextState === previousState) {
        return;
      }
      previousState = nextState;
      listener();
    };
    return this.store.subscribe(handleChange);
  }
  canDragSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (this.isDragging()) {
      return false;
    }
    return source.canDrag(this, sourceId);
  }
  canDropOnTarget(targetId) {
    if (!targetId) {
      return false;
    }
    const target = this.registry.getTarget(targetId);
    invariant(target, `Expected to find a valid target. targetId=${targetId}`);
    if (!this.isDragging() || this.didDrop()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
  }
  isDragging() {
    return Boolean(this.getItemType());
  }
  isDraggingSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId, true);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (!this.isDragging() || !this.isSourcePublic()) {
      return false;
    }
    const sourceType = this.registry.getSourceType(sourceId);
    const draggedItemType = this.getItemType();
    if (sourceType !== draggedItemType) {
      return false;
    }
    return source.isDragging(this, sourceId);
  }
  isOverTarget(targetId, options = {
    shallow: false
  }) {
    if (!targetId) {
      return false;
    }
    const { shallow } = options;
    if (!this.isDragging()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    if (draggedItemType && !matchesType(targetType, draggedItemType)) {
      return false;
    }
    const targetIds = this.getTargetIds();
    if (!targetIds.length) {
      return false;
    }
    const index = targetIds.indexOf(targetId);
    if (shallow) {
      return index === targetIds.length - 1;
    } else {
      return index > -1;
    }
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return Boolean(this.store.getState().dragOperation.isSourcePublic);
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return getSourceClientOffset(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
  }
  constructor(store, registry) {
    this.store = store;
    this.registry = registry;
  }
};
var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
function makeRequestCallFromTimer(callback) {
  return function requestCall() {
    const timeoutHandle = setTimeout(handleTimer, 0);
    const intervalHandle = setInterval(handleTimer, 50);
    function handleTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      callback();
    }
  };
}
function makeRequestCallFromMutationObserver(callback) {
  let toggle = 1;
  const observer = new BrowserMutationObserver(callback);
  const node = document.createTextNode("");
  observer.observe(node, {
    characterData: true
  });
  return function requestCall() {
    toggle = -toggle;
    node.data = toggle;
  };
}
var makeRequestCall = typeof BrowserMutationObserver === "function" ? (
  // reliably everywhere they are implemented.
  // They are implemented in all modern browsers.
  //
  // - Android 4-4.3
  // - Chrome 26-34
  // - Firefox 14-29
  // - Internet Explorer 11
  // - iPad Safari 6-7.1
  // - iPhone Safari 7-7.1
  // - Safari 6-7
  makeRequestCallFromMutationObserver
) : (
  // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
  // 11-12, and in web workers in many engines.
  // Although message channels yield to any queued rendering and IO tasks, they
  // would be better than imposing the 4ms delay of timers.
  // However, they do not work reliably in Internet Explorer or Safari.
  // Internet Explorer 10 is the only browser that has setImmediate but does
  // not have MutationObservers.
  // Although setImmediate yields to the browser's renderer, it would be
  // preferrable to falling back to setTimeout since it does not have
  // the minimum 4ms penalty.
  // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
  // Desktop to a lesser extent) that renders both setImmediate and
  // MessageChannel useless for the purposes of ASAP.
  // https://github.com/kriskowal/q/issues/396
  // Timers are implemented universally.
  // We fall back to timers in workers in most engines, and in foreground
  // contexts in the following browsers.
  // However, note that even this simple case requires nuances to operate in a
  // broad spectrum of browsers.
  //
  // - Firefox 3-13
  // - Internet Explorer 6-9
  // - iPad Safari 4.3
  // - Lynx 2.8.7
  makeRequestCallFromTimer
);
var AsapQueue = class {
  // Use the fastest means possible to execute a task in its own turn, with
  // priority over other events including IO, animation, reflow, and redraw
  // events in browsers.
  //
  // An exception thrown by a task will permanently interrupt the processing of
  // subsequent tasks. The higher level `asap` function ensures that if an
  // exception is thrown by a task, that the task queue will continue flushing as
  // soon as possible, but if you use `rawAsap` directly, you are responsible to
  // either ensure that no exceptions are thrown from your task, or to manually
  // call `rawAsap.requestFlush` if an exception is thrown.
  enqueueTask(task) {
    const { queue: q2, requestFlush } = this;
    if (!q2.length) {
      requestFlush();
      this.flushing = true;
    }
    q2[q2.length] = task;
  }
  constructor() {
    this.queue = [];
    this.pendingErrors = [];
    this.flushing = false;
    this.index = 0;
    this.capacity = 1024;
    this.flush = () => {
      const { queue: q2 } = this;
      while (this.index < q2.length) {
        const currentIndex = this.index;
        this.index++;
        q2[currentIndex].call();
        if (this.index > this.capacity) {
          for (let scan = 0, newLength = q2.length - this.index; scan < newLength; scan++) {
            q2[scan] = q2[scan + this.index];
          }
          q2.length -= this.index;
          this.index = 0;
        }
      }
      q2.length = 0;
      this.index = 0;
      this.flushing = false;
    };
    this.registerPendingError = (err) => {
      this.pendingErrors.push(err);
      this.requestErrorThrow();
    };
    this.requestFlush = makeRequestCall(this.flush);
    this.requestErrorThrow = makeRequestCallFromTimer(() => {
      if (this.pendingErrors.length) {
        throw this.pendingErrors.shift();
      }
    });
  }
};
var RawTask = class {
  call() {
    try {
      this.task && this.task();
    } catch (error) {
      this.onError(error);
    } finally {
      this.task = null;
      this.release(this);
    }
  }
  constructor(onError, release) {
    this.onError = onError;
    this.release = release;
    this.task = null;
  }
};
var TaskFactory = class {
  create(task) {
    const tasks = this.freeTasks;
    const t1 = tasks.length ? tasks.pop() : new RawTask(
      this.onError,
      (t2) => tasks[tasks.length] = t2
    );
    t1.task = task;
    return t1;
  }
  constructor(onError) {
    this.onError = onError;
    this.freeTasks = [];
  }
};
var asapQueue = new AsapQueue();
var taskFactory = new TaskFactory(asapQueue.registerPendingError);
function asap(task) {
  asapQueue.enqueueTask(taskFactory.create(task));
}
var ADD_SOURCE = "dnd-core/ADD_SOURCE";
var ADD_TARGET = "dnd-core/ADD_TARGET";
var REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
var REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
function addSource(sourceId) {
  return {
    type: ADD_SOURCE,
    payload: {
      sourceId
    }
  };
}
function addTarget(targetId) {
  return {
    type: ADD_TARGET,
    payload: {
      targetId
    }
  };
}
function removeSource(sourceId) {
  return {
    type: REMOVE_SOURCE,
    payload: {
      sourceId
    }
  };
}
function removeTarget(targetId) {
  return {
    type: REMOVE_TARGET,
    payload: {
      targetId
    }
  };
}
function validateSourceContract(source) {
  invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
  invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
  invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
}
function validateTargetContract(target) {
  invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
  invariant(typeof target.hover === "function", "Expected hover to be a function.");
  invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
}
function validateType(type, allowArray) {
  if (allowArray && Array.isArray(type)) {
    type.forEach(
      (t2) => validateType(t2, false)
    );
    return;
  }
  invariant(typeof type === "string" || typeof type === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var HandlerRole;
(function(HandlerRole2) {
  HandlerRole2["SOURCE"] = "SOURCE";
  HandlerRole2["TARGET"] = "TARGET";
})(HandlerRole || (HandlerRole = {}));
var nextUniqueId = 0;
function getNextUniqueId() {
  return nextUniqueId++;
}
function getNextHandlerId(role) {
  const id = getNextUniqueId().toString();
  switch (role) {
    case HandlerRole.SOURCE:
      return `S${id}`;
    case HandlerRole.TARGET:
      return `T${id}`;
    default:
      throw new Error(`Unknown Handler Role: ${role}`);
  }
}
function parseRoleFromHandlerId(handlerId) {
  switch (handlerId[0]) {
    case "S":
      return HandlerRole.SOURCE;
    case "T":
      return HandlerRole.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${handlerId}`);
  }
}
function mapContainsValue(map, searchValue) {
  const entries = map.entries();
  let isDone = false;
  do {
    const { done, value: [, value] } = entries.next();
    if (value === searchValue) {
      return true;
    }
    isDone = !!done;
  } while (!isDone);
  return false;
}
var HandlerRegistryImpl = class {
  addSource(type, source) {
    validateType(type);
    validateSourceContract(source);
    const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
    this.store.dispatch(addSource(sourceId));
    return sourceId;
  }
  addTarget(type, target) {
    validateType(type, true);
    validateTargetContract(target);
    const targetId = this.addHandler(HandlerRole.TARGET, type, target);
    this.store.dispatch(addTarget(targetId));
    return targetId;
  }
  containsHandler(handler) {
    return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
  }
  getSource(sourceId, includePinned = false) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    const isPinned = includePinned && sourceId === this.pinnedSourceId;
    const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
    return source;
  }
  getTarget(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.dropTargets.get(targetId);
  }
  getSourceType(sourceId) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    return this.types.get(sourceId);
  }
  getTargetType(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.types.get(targetId);
  }
  isSourceId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.SOURCE;
  }
  isTargetId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.TARGET;
  }
  removeSource(sourceId) {
    invariant(this.getSource(sourceId), "Expected an existing source.");
    this.store.dispatch(removeSource(sourceId));
    asap(() => {
      this.dragSources.delete(sourceId);
      this.types.delete(sourceId);
    });
  }
  removeTarget(targetId) {
    invariant(this.getTarget(targetId), "Expected an existing target.");
    this.store.dispatch(removeTarget(targetId));
    this.dropTargets.delete(targetId);
    this.types.delete(targetId);
  }
  pinSource(sourceId) {
    const source = this.getSource(sourceId);
    invariant(source, "Expected an existing source.");
    this.pinnedSourceId = sourceId;
    this.pinnedSource = source;
  }
  unpinSource() {
    invariant(this.pinnedSource, "No source is pinned at the time.");
    this.pinnedSourceId = null;
    this.pinnedSource = null;
  }
  addHandler(role, type, handler) {
    const id = getNextHandlerId(role);
    this.types.set(id, type);
    if (role === HandlerRole.SOURCE) {
      this.dragSources.set(id, handler);
    } else if (role === HandlerRole.TARGET) {
      this.dropTargets.set(id, handler);
    }
    return id;
  }
  constructor(store) {
    this.types = /* @__PURE__ */ new Map();
    this.dragSources = /* @__PURE__ */ new Map();
    this.dropTargets = /* @__PURE__ */ new Map();
    this.pinnedSourceId = null;
    this.pinnedSource = null;
    this.store = store;
  }
};
var strictEquality = (a2, b2) => a2 === b2;
function areCoordsEqual(offsetA, offsetB) {
  if (!offsetA && !offsetB) {
    return true;
  } else if (!offsetA || !offsetB) {
    return false;
  } else {
    return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
  }
}
function areArraysEqual(a2, b2, isEqual = strictEquality) {
  if (a2.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a2.length; ++i2) {
    if (!isEqual(a2[i2], b2[i2])) {
      return false;
    }
  }
  return true;
}
function reduce$5(_state = NONE, action) {
  switch (action.type) {
    case HOVER:
      break;
    case ADD_SOURCE:
    case ADD_TARGET:
    case REMOVE_TARGET:
    case REMOVE_SOURCE:
      return NONE;
    case BEGIN_DRAG:
    case PUBLISH_DRAG_SOURCE:
    case END_DRAG:
    case DROP:
    default:
      return ALL;
  }
  const { targetIds = [], prevTargetIds = [] } = action.payload;
  const result = xor3(targetIds, prevTargetIds);
  const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
  if (!didChange) {
    return NONE;
  }
  const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
  const innermostTargetId = targetIds[targetIds.length - 1];
  if (prevInnermostTargetId !== innermostTargetId) {
    if (prevInnermostTargetId) {
      result.push(prevInnermostTargetId);
    }
    if (innermostTargetId) {
      result.push(innermostTargetId);
    }
  }
  return result;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    });
  }
  return target;
}
var initialState$1 = {
  initialSourceClientOffset: null,
  initialClientOffset: null,
  clientOffset: null
};
function reduce$4(state = initialState$1, action) {
  const { payload } = action;
  switch (action.type) {
    case INIT_COORDS:
    case BEGIN_DRAG:
      return {
        initialSourceClientOffset: payload.sourceClientOffset,
        initialClientOffset: payload.clientOffset,
        clientOffset: payload.clientOffset
      };
    case HOVER:
      if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
        return state;
      }
      return _objectSpread$3({}, state, {
        clientOffset: payload.clientOffset
      });
    case END_DRAG:
    case DROP:
      return initialState$1;
    default:
      return state;
  }
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    });
  }
  return target;
}
var initialState = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: false,
  isSourcePublic: null
};
function reduce$3(state = initialState, action) {
  const { payload } = action;
  switch (action.type) {
    case BEGIN_DRAG:
      return _objectSpread$2({}, state, {
        itemType: payload.itemType,
        item: payload.item,
        sourceId: payload.sourceId,
        isSourcePublic: payload.isSourcePublic,
        dropResult: null,
        didDrop: false
      });
    case PUBLISH_DRAG_SOURCE:
      return _objectSpread$2({}, state, {
        isSourcePublic: true
      });
    case HOVER:
      return _objectSpread$2({}, state, {
        targetIds: payload.targetIds
      });
    case REMOVE_TARGET:
      if (state.targetIds.indexOf(payload.targetId) === -1) {
        return state;
      }
      return _objectSpread$2({}, state, {
        targetIds: without$1(state.targetIds, payload.targetId)
      });
    case DROP:
      return _objectSpread$2({}, state, {
        dropResult: payload.dropResult,
        didDrop: true,
        targetIds: []
      });
    case END_DRAG:
      return _objectSpread$2({}, state, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: false,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return state;
  }
}
function reduce$2(state = 0, action) {
  switch (action.type) {
    case ADD_SOURCE:
    case ADD_TARGET:
      return state + 1;
    case REMOVE_SOURCE:
    case REMOVE_TARGET:
      return state - 1;
    default:
      return state;
  }
}
function reduce$1(state = 0) {
  return state + 1;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    });
  }
  return target;
}
function reduce(state = {}, action) {
  return {
    dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {
      type: action.type,
      payload: _objectSpread$1({}, action.payload, {
        prevTargetIds: get(state, "dragOperation.targetIds", [])
      })
    }),
    dragOffset: reduce$4(state.dragOffset, action),
    refCount: reduce$2(state.refCount, action),
    dragOperation: reduce$3(state.dragOperation, action),
    stateId: reduce$1(state.stateId)
  };
}
function createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {
  const store = makeStoreInstance(debugMode);
  const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
  const manager = new DragDropManagerImpl(store, monitor);
  const backend = backendFactory(manager, globalContext, backendOptions);
  manager.receiveBackend(backend);
  return manager;
}
function makeStoreInstance(debugMode) {
  const reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
  return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({
    name: "dnd-core",
    instanceId: "dnd-core"
  }));
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var refCount = 0;
var INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var DndProvider = /* @__PURE__ */ (0, import_react6.memo)(function DndProvider2(_param) {
  var { children } = _param, props = _objectWithoutProperties2(_param, [
    "children"
  ]);
  const [manager, isGlobalInstance] = getDndContextValue(props);
  (0, import_react6.useEffect)(() => {
    if (isGlobalInstance) {
      const context = getGlobalContext();
      ++refCount;
      return () => {
        if (--refCount === 0) {
          context[INSTANCE_SYM] = null;
        }
      };
    }
    return;
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(DndContext.Provider, {
    value: manager,
    children
  });
});
function getDndContextValue(props) {
  if ("manager" in props) {
    const manager2 = {
      dragDropManager: props.manager
    };
    return [
      manager2,
      false
    ];
  }
  const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
  const isGlobalInstance = !props.context;
  return [
    manager,
    isGlobalInstance
  ];
}
function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
  const ctx = context;
  if (!ctx[INSTANCE_SYM]) {
    ctx[INSTANCE_SYM] = {
      dragDropManager: createDragDropManager(backend, context, options, debugMode)
    };
  }
  return ctx[INSTANCE_SYM];
}
function getGlobalContext() {
  return typeof global !== "undefined" ? global : window;
}
var fastDeepEqual = function equal(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length4, i2, keys;
    if (Array.isArray(a2)) {
      length4 = a2.length;
      if (length4 != b2.length)
        return false;
      for (i2 = length4; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    keys = Object.keys(a2);
    length4 = keys.length;
    if (length4 !== Object.keys(b2).length)
      return false;
    for (i2 = length4; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
        return false;
    for (i2 = length4; i2-- !== 0; ) {
      var key = keys[i2];
      if (!equal(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react6.useLayoutEffect : import_react6.useEffect;
function useCollector(monitor, collect, onUpdate) {
  const [collected, setCollected] = (0, import_react6.useState)(
    () => collect(monitor)
  );
  const updateCollected = (0, import_react6.useCallback)(() => {
    const nextValue = collect(monitor);
    if (!fastDeepEqual(collected, nextValue)) {
      setCollected(nextValue);
      if (onUpdate) {
        onUpdate();
      }
    }
  }, [
    collected,
    monitor,
    onUpdate
  ]);
  useIsomorphicLayoutEffect(updateCollected);
  return [
    collected,
    updateCollected
  ];
}
function useMonitorOutput(monitor, collect, onCollect) {
  const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
  useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
    const handlerId = monitor.getHandlerId();
    if (handlerId == null) {
      return;
    }
    return monitor.subscribeToStateChange(updateCollected, {
      handlerIds: [
        handlerId
      ]
    });
  }, [
    monitor,
    updateCollected
  ]);
  return collected;
}
function useCollectedProps(collector, monitor, connector) {
  return useMonitorOutput(
    monitor,
    collector || (() => ({})),
    () => connector.reconnect()
  );
}
function useOptionalFactory(arg, deps) {
  const memoDeps = [
    ...deps || []
  ];
  if (deps == null && typeof arg !== "function") {
    memoDeps.push(arg);
  }
  return (0, import_react6.useMemo)(() => {
    return typeof arg === "function" ? arg() : arg;
  }, memoDeps);
}
function useConnectDragSource(connector) {
  return (0, import_react6.useMemo)(
    () => connector.hooks.dragSource(),
    [
      connector
    ]
  );
}
function useConnectDragPreview(connector) {
  return (0, import_react6.useMemo)(
    () => connector.hooks.dragPreview(),
    [
      connector
    ]
  );
}
var isCallingCanDrag = false;
var isCallingIsDragging = false;
var DragSourceMonitorImpl = class {
  receiveHandlerId(sourceId) {
    this.sourceId = sourceId;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingCanDrag = true;
      return this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      isCallingCanDrag = false;
    }
  }
  isDragging() {
    if (!this.sourceId) {
      return false;
    }
    invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingIsDragging = true;
      return this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      isCallingIsDragging = false;
    }
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  isDraggingSource(sourceId) {
    return this.internalMonitor.isDraggingSource(sourceId);
  }
  isOverTarget(targetId, options) {
    return this.internalMonitor.isOverTarget(targetId, options);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(listener) {
    return this.internalMonitor.subscribeToOffsetChange(listener);
  }
  canDragSource(sourceId) {
    return this.internalMonitor.canDragSource(sourceId);
  }
  canDropOnTarget(targetId) {
    return this.internalMonitor.canDropOnTarget(targetId);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.sourceId = null;
    this.internalMonitor = manager.getMonitor();
  }
};
var isCallingCanDrop = false;
var DropTargetMonitorImpl = class {
  receiveHandlerId(targetId) {
    this.targetId = targetId;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  canDrop() {
    if (!this.targetId) {
      return false;
    }
    invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      isCallingCanDrop = true;
      return this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      isCallingCanDrop = false;
    }
  }
  isOver(options) {
    if (!this.targetId) {
      return false;
    }
    return this.internalMonitor.isOverTarget(this.targetId, options);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.targetId = null;
    this.internalMonitor = manager.getMonitor();
  }
};
function registerTarget(type, target, manager) {
  const registry = manager.getRegistry();
  const targetId = registry.addTarget(type, target);
  return [
    targetId,
    () => registry.removeTarget(targetId)
  ];
}
function registerSource(type, source, manager) {
  const registry = manager.getRegistry();
  const sourceId = registry.addSource(type, source);
  return [
    sourceId,
    () => registry.removeSource(sourceId)
  ];
}
function shallowEqual(objA, objB, compare3, compareContext) {
  let compareResult = compare3 ? compare3.call(compareContext, objA, objB) : void 0;
  if (compareResult !== void 0) {
    return !!compareResult;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (let idx = 0; idx < keysA.length; idx++) {
    const key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    const valueA = objA[key];
    const valueB = objB[key];
    compareResult = compare3 ? compare3.call(compareContext, valueA, valueB, key) : void 0;
    if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
function isRef(obj) {
  return (
    // eslint-disable-next-line no-prototype-builtins
    obj !== null && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "current")
  );
}
function throwIfCompositeComponentElement(element) {
  if (typeof element.type === "string") {
    return;
  }
  const displayName = element.type.displayName || element.type.name || "the component";
  throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);
}
function wrapHookToRecognizeElement(hook) {
  return (elementOrNode = null, options = null) => {
    if (!(0, import_react6.isValidElement)(elementOrNode)) {
      const node = elementOrNode;
      hook(node, options);
      return node;
    }
    const element = elementOrNode;
    throwIfCompositeComponentElement(element);
    const ref = options ? (node) => hook(node, options) : hook;
    return cloneWithRef(element, ref);
  };
}
function wrapConnectorHooks(hooks) {
  const wrappedHooks = {};
  Object.keys(hooks).forEach((key) => {
    const hook = hooks[key];
    if (key.endsWith("Ref")) {
      wrappedHooks[key] = hooks[key];
    } else {
      const wrappedHook = wrapHookToRecognizeElement(hook);
      wrappedHooks[key] = () => wrappedHook;
    }
  });
  return wrappedHooks;
}
function setRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else {
    ref.current = node;
  }
}
function cloneWithRef(element, newRef) {
  const previousRef = element.ref;
  invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
  if (!previousRef) {
    return (0, import_react6.cloneElement)(element, {
      ref: newRef
    });
  } else {
    return (0, import_react6.cloneElement)(element, {
      ref: (node) => {
        setRef(previousRef, node);
        setRef(newRef, node);
      }
    });
  }
}
var SourceConnector = class {
  receiveHandlerId(newHandlerId) {
    if (this.handlerId === newHandlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(options) {
    this.dragSourceOptionsInternal = options;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(options) {
    this.dragPreviewOptionsInternal = options;
  }
  reconnect() {
    const didChange = this.reconnectDragSource();
    this.reconnectDragPreview(didChange);
  }
  reconnectDragSource() {
    const dragSource = this.dragSource;
    const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    if (didChange) {
      this.disconnectDragSource();
    }
    if (!this.handlerId) {
      return didChange;
    }
    if (!dragSource) {
      this.lastConnectedDragSource = dragSource;
      return didChange;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragSource = dragSource;
      this.lastConnectedDragSourceOptions = this.dragSourceOptions;
      this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
    }
    return didChange;
  }
  reconnectDragPreview(forceDidChange = false) {
    const dragPreview = this.dragPreview;
    const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    if (didChange) {
      this.disconnectDragPreview();
    }
    if (!this.handlerId) {
      return;
    }
    if (!dragPreview) {
      this.lastConnectedDragPreview = dragPreview;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragPreview = dragPreview;
      this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
      this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
    }
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    if (this.dragSourceUnsubscribe) {
      this.dragSourceUnsubscribe();
      this.dragSourceUnsubscribe = void 0;
    }
  }
  disconnectDragPreview() {
    if (this.dragPreviewUnsubscribe) {
      this.dragPreviewUnsubscribe();
      this.dragPreviewUnsubscribe = void 0;
      this.dragPreviewNode = null;
      this.dragPreviewRef = null;
    }
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null;
    this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null;
    this.dragPreviewRef = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dragSource: (node, options) => {
        this.clearDragSource();
        this.dragSourceOptions = options || null;
        if (isRef(node)) {
          this.dragSourceRef = node;
        } else {
          this.dragSourceNode = node;
        }
        this.reconnectDragSource();
      },
      dragPreview: (node, options) => {
        this.clearDragPreview();
        this.dragPreviewOptions = options || null;
        if (isRef(node)) {
          this.dragPreviewRef = node;
        } else {
          this.dragPreviewNode = node;
        }
        this.reconnectDragPreview();
      }
    });
    this.handlerId = null;
    this.dragSourceRef = null;
    this.dragSourceOptionsInternal = null;
    this.dragPreviewRef = null;
    this.dragPreviewOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDragSource = null;
    this.lastConnectedDragSourceOptions = null;
    this.lastConnectedDragPreview = null;
    this.lastConnectedDragPreviewOptions = null;
    this.backend = backend;
  }
};
var TargetConnector = class {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    if (didChange) {
      this.disconnectDropTarget();
    }
    const dropTarget = this.dropTarget;
    if (!this.handlerId) {
      return;
    }
    if (!dropTarget) {
      this.lastConnectedDropTarget = dropTarget;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDropTarget = dropTarget;
      this.lastConnectedDropTargetOptions = this.dropTargetOptions;
      this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
    }
  }
  receiveHandlerId(newHandlerId) {
    if (newHandlerId === this.handlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(options) {
    this.dropTargetOptionsInternal = options;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    if (this.unsubscribeDropTarget) {
      this.unsubscribeDropTarget();
      this.unsubscribeDropTarget = void 0;
    }
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null;
    this.dropTargetNode = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dropTarget: (node, options) => {
        this.clearDropTarget();
        this.dropTargetOptions = options;
        if (isRef(node)) {
          this.dropTargetRef = node;
        } else {
          this.dropTargetNode = node;
        }
        this.reconnect();
      }
    });
    this.handlerId = null;
    this.dropTargetRef = null;
    this.dropTargetOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDropTarget = null;
    this.lastConnectedDropTargetOptions = null;
    this.backend = backend;
  }
};
function useDragDropManager() {
  const { dragDropManager } = (0, import_react6.useContext)(DndContext);
  invariant(dragDropManager != null, "Expected drag drop context");
  return dragDropManager;
}
function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
  const manager = useDragDropManager();
  const connector = (0, import_react6.useMemo)(
    () => new SourceConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect(() => {
    connector.dragSourceOptions = dragSourceOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragSource();
  }, [
    connector,
    dragSourceOptions
  ]);
  useIsomorphicLayoutEffect(() => {
    connector.dragPreviewOptions = dragPreviewOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragPreview();
  }, [
    connector,
    dragPreviewOptions
  ]);
  return connector;
}
function useDragSourceMonitor() {
  const manager = useDragDropManager();
  return (0, import_react6.useMemo)(
    () => new DragSourceMonitorImpl(manager),
    [
      manager
    ]
  );
}
var DragSourceImpl = class {
  beginDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    let result = null;
    if (typeof spec.item === "object") {
      result = spec.item;
    } else if (typeof spec.item === "function") {
      result = spec.item(monitor);
    } else {
      result = {};
    }
    return result !== null && result !== void 0 ? result : null;
  }
  canDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (typeof spec.canDrag === "boolean") {
      return spec.canDrag;
    } else if (typeof spec.canDrag === "function") {
      return spec.canDrag(monitor);
    } else {
      return true;
    }
  }
  isDragging(globalMonitor, target) {
    const spec = this.spec;
    const monitor = this.monitor;
    const { isDragging } = spec;
    return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
  }
  endDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    const connector = this.connector;
    const { end } = spec;
    if (end) {
      end(monitor.getItem(), monitor);
    }
    connector.reconnect();
  }
  constructor(spec, monitor, connector) {
    this.spec = spec;
    this.monitor = monitor;
    this.connector = connector;
  }
};
function useDragSource(spec, monitor, connector) {
  const handler = (0, import_react6.useMemo)(
    () => new DragSourceImpl(spec, monitor, connector),
    [
      monitor,
      connector
    ]
  );
  (0, import_react6.useEffect)(() => {
    handler.spec = spec;
  }, [
    spec
  ]);
  return handler;
}
function useDragType(spec) {
  return (0, import_react6.useMemo)(() => {
    const result = spec.type;
    invariant(result != null, "spec.type must be defined");
    return result;
  }, [
    spec
  ]);
}
function useRegisteredDragSource(spec, monitor, connector) {
  const manager = useDragDropManager();
  const handler = useDragSource(spec, monitor, connector);
  const itemType = useDragType(spec);
  useIsomorphicLayoutEffect(function registerDragSource() {
    if (itemType != null) {
      const [handlerId, unregister] = registerSource(itemType, handler, manager);
      monitor.receiveHandlerId(handlerId);
      connector.receiveHandlerId(handlerId);
      return unregister;
    }
    return;
  }, [
    manager,
    monitor,
    connector,
    handler,
    itemType
  ]);
}
function useDrag(specArg, deps) {
  const spec = useOptionalFactory(specArg, deps);
  invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
  const monitor = useDragSourceMonitor();
  const connector = useDragSourceConnector(spec.options, spec.previewOptions);
  useRegisteredDragSource(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDragSource(connector),
    useConnectDragPreview(connector)
  ];
}
function useDragLayer(collect) {
  const dragDropManager = useDragDropManager();
  const monitor = dragDropManager.getMonitor();
  const [collected, updateCollected] = useCollector(monitor, collect);
  (0, import_react6.useEffect)(
    () => monitor.subscribeToOffsetChange(updateCollected)
  );
  (0, import_react6.useEffect)(
    () => monitor.subscribeToStateChange(updateCollected)
  );
  return collected;
}
function useConnectDropTarget(connector) {
  return (0, import_react6.useMemo)(
    () => connector.hooks.dropTarget(),
    [
      connector
    ]
  );
}
function useDropTargetConnector(options) {
  const manager = useDragDropManager();
  const connector = (0, import_react6.useMemo)(
    () => new TargetConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect(() => {
    connector.dropTargetOptions = options || null;
    connector.reconnect();
    return () => connector.disconnectDropTarget();
  }, [
    options
  ]);
  return connector;
}
function useDropTargetMonitor() {
  const manager = useDragDropManager();
  return (0, import_react6.useMemo)(
    () => new DropTargetMonitorImpl(manager),
    [
      manager
    ]
  );
}
function useAccept(spec) {
  const { accept } = spec;
  return (0, import_react6.useMemo)(() => {
    invariant(spec.accept != null, "accept must be defined");
    return Array.isArray(accept) ? accept : [
      accept
    ];
  }, [
    accept
  ]);
}
var DropTargetImpl = class {
  canDrop() {
    const spec = this.spec;
    const monitor = this.monitor;
    return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
  }
  hover() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.hover) {
      spec.hover(monitor.getItem(), monitor);
    }
  }
  drop() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.drop) {
      return spec.drop(monitor.getItem(), monitor);
    }
    return;
  }
  constructor(spec, monitor) {
    this.spec = spec;
    this.monitor = monitor;
  }
};
function useDropTarget(spec, monitor) {
  const dropTarget = (0, import_react6.useMemo)(
    () => new DropTargetImpl(spec, monitor),
    [
      monitor
    ]
  );
  (0, import_react6.useEffect)(() => {
    dropTarget.spec = spec;
  }, [
    spec
  ]);
  return dropTarget;
}
function useRegisteredDropTarget(spec, monitor, connector) {
  const manager = useDragDropManager();
  const dropTarget = useDropTarget(spec, monitor);
  const accept = useAccept(spec);
  useIsomorphicLayoutEffect(function registerDropTarget() {
    const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
    monitor.receiveHandlerId(handlerId);
    connector.receiveHandlerId(handlerId);
    return unregister;
  }, [
    manager,
    monitor,
    dropTarget,
    connector,
    accept.map(
      (a2) => a2.toString()
    ).join("|")
  ]);
}
function useDrop(specArg, deps) {
  const spec = useOptionalFactory(specArg, deps);
  const monitor = useDropTargetMonitor();
  const connector = useDropTargetConnector(spec.options);
  useRegisteredDropTarget(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDropTarget(connector)
  ];
}
function memoize(fn2) {
  let result = null;
  const memoized = () => {
    if (result == null) {
      result = fn2();
    }
    return result;
  };
  return memoized;
}
function without(items, item) {
  return items.filter(
    (i2) => i2 !== item
  );
}
function union(itemsA, itemsB) {
  const set = /* @__PURE__ */ new Set();
  const insertItem = (item) => set.add(item);
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  set.forEach(
    (key) => result.push(key)
  );
  return result;
}
var EnterLeaveCounter = class {
  enter(enteringNode) {
    const previousLength = this.entered.length;
    const isNodeEntered = (node) => this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));
    this.entered = union(this.entered.filter(isNodeEntered), [
      enteringNode
    ]);
    return previousLength === 0 && this.entered.length > 0;
  }
  leave(leavingNode) {
    const previousLength = this.entered.length;
    this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);
    return previousLength > 0 && this.entered.length === 0;
  }
  reset() {
    this.entered = [];
  }
  constructor(isNodeInDocument) {
    this.entered = [];
    this.isNodeInDocument = isNodeInDocument;
  }
};
var NativeDragSource = class {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((property) => {
      Object.defineProperty(this.item, property, {
        configurable: true,
        enumerable: true,
        get() {
          console.warn(`Browser doesn't allow reading "${property}" until the drop event.`);
          return null;
        }
      });
    });
  }
  loadDataTransfer(dataTransfer) {
    if (dataTransfer) {
      const newProperties = {};
      Object.keys(this.config.exposeProperties).forEach((property) => {
        const propertyFn = this.config.exposeProperties[property];
        if (propertyFn != null) {
          newProperties[property] = {
            value: propertyFn(dataTransfer, this.config.matchesTypes),
            configurable: true,
            enumerable: true
          };
        }
      });
      Object.defineProperties(this.item, newProperties);
    }
  }
  canDrag() {
    return true;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(monitor, handle) {
    return handle === monitor.getSourceId();
  }
  endDrag() {
  }
  constructor(config) {
    this.config = config;
    this.item = {};
    this.initializeExposedProperties();
  }
};
var FILE = "__NATIVE_FILE__";
var URL2 = "__NATIVE_URL__";
var TEXT = "__NATIVE_TEXT__";
var HTML = "__NATIVE_HTML__";
var NativeTypes = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  FILE,
  HTML,
  TEXT,
  URL: URL2
});
function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
  const result = typesToTry.reduce(
    (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),
    ""
  );
  return result != null ? result : defaultValue;
}
var nativeTypesConfig = {
  [FILE]: {
    exposeProperties: {
      files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),
      items: (dataTransfer) => dataTransfer.items,
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Files"
    ]
  },
  [HTML]: {
    exposeProperties: {
      html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Html",
      "text/html"
    ]
  },
  [URL2]: {
    exposeProperties: {
      urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, "").split("\n"),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Url",
      "text/uri-list"
    ]
  },
  [TEXT]: {
    exposeProperties: {
      text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Text",
      "text/plain"
    ]
  }
};
function createNativeDragSource(type, dataTransfer) {
  const config = nativeTypesConfig[type];
  if (!config) {
    throw new Error(`native type ${type} has no configuration`);
  }
  const result = new NativeDragSource(config);
  result.loadDataTransfer(dataTransfer);
  return result;
}
function matchNativeItemType(dataTransfer) {
  if (!dataTransfer) {
    return null;
  }
  const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
  return Object.keys(nativeTypesConfig).filter((nativeItemType) => {
    const typeConfig = nativeTypesConfig[nativeItemType];
    if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
      return false;
    }
    return typeConfig.matchesTypes.some(
      (t2) => dataTransferTypes.indexOf(t2) > -1
    );
  })[0] || null;
}
var isFirefox = memoize(
  () => /firefox/i.test(navigator.userAgent)
);
var isSafari = memoize(
  () => Boolean(window.safari)
);
var MonotonicInterpolant = class {
  interpolate(x2) {
    const { xs, ys, c1s, c2s, c3s } = this;
    let i2 = xs.length - 1;
    if (x2 === xs[i2]) {
      return ys[i2];
    }
    let low = 0;
    let high = c3s.length - 1;
    let mid;
    while (low <= high) {
      mid = Math.floor(0.5 * (low + high));
      const xHere = xs[mid];
      if (xHere < x2) {
        low = mid + 1;
      } else if (xHere > x2) {
        high = mid - 1;
      } else {
        return ys[mid];
      }
    }
    i2 = Math.max(0, high);
    const diff = x2 - xs[i2];
    const diffSq = diff * diff;
    return ys[i2] + c1s[i2] * diff + c2s[i2] * diffSq + c3s[i2] * diff * diffSq;
  }
  constructor(xs, ys) {
    const { length: length4 } = xs;
    const indexes = [];
    for (let i2 = 0; i2 < length4; i2++) {
      indexes.push(i2);
    }
    indexes.sort(
      (a2, b2) => xs[a2] < xs[b2] ? -1 : 1
    );
    const dxs = [];
    const ms = [];
    let dx;
    let dy;
    for (let i1 = 0; i1 < length4 - 1; i1++) {
      dx = xs[i1 + 1] - xs[i1];
      dy = ys[i1 + 1] - ys[i1];
      dxs.push(dx);
      ms.push(dy / dx);
    }
    const c1s = [
      ms[0]
    ];
    for (let i2 = 0; i2 < dxs.length - 1; i2++) {
      const m22 = ms[i2];
      const mNext = ms[i2 + 1];
      if (m22 * mNext <= 0) {
        c1s.push(0);
      } else {
        dx = dxs[i2];
        const dxNext = dxs[i2 + 1];
        const common = dx + dxNext;
        c1s.push(3 * common / ((common + dxNext) / m22 + (common + dx) / mNext));
      }
    }
    c1s.push(ms[ms.length - 1]);
    const c2s = [];
    const c3s = [];
    let m2;
    for (let i3 = 0; i3 < c1s.length - 1; i3++) {
      m2 = ms[i3];
      const c1 = c1s[i3];
      const invDx = 1 / dxs[i3];
      const common = c1 + c1s[i3 + 1] - m2 - m2;
      c2s.push((m2 - c1 - common) * invDx);
      c3s.push(common * invDx * invDx);
    }
    this.xs = xs;
    this.ys = ys;
    this.c1s = c1s;
    this.c2s = c2s;
    this.c3s = c3s;
  }
};
var ELEMENT_NODE$1 = 1;
function getNodeClientOffset$1(node) {
  const el = node.nodeType === ELEMENT_NODE$1 ? node : node.parentElement;
  if (!el) {
    return null;
  }
  const { top, left } = el.getBoundingClientRect();
  return {
    x: left,
    y: top
  };
}
function getEventClientOffset$1(e2) {
  return {
    x: e2.clientX,
    y: e2.clientY
  };
}
function isImageNode(node) {
  var ref;
  return node.nodeName === "IMG" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
  let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
  let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
  if (isSafari() && isImage) {
    dragPreviewHeight /= window.devicePixelRatio;
    dragPreviewWidth /= window.devicePixelRatio;
  }
  return {
    dragPreviewWidth,
    dragPreviewHeight
  };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
  const isImage = isImageNode(dragPreview);
  const dragPreviewNode = isImage ? sourceNode : dragPreview;
  const dragPreviewNodeOffsetFromClient = getNodeClientOffset$1(dragPreviewNode);
  const offsetFromDragPreview = {
    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
  };
  const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
  const { anchorX, anchorY } = anchorPoint;
  const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
  const calculateYOffset = () => {
    const interpolantY = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      // Dock to the top
      offsetFromDragPreview.y,
      // Align at the center
      offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
      // Dock to the bottom
      offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
    ]);
    let y2 = interpolantY.interpolate(anchorY);
    if (isSafari() && isImage) {
      y2 += (window.devicePixelRatio - 1) * dragPreviewHeight;
    }
    return y2;
  };
  const calculateXOffset = () => {
    const interpolantX = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      // Dock to the left
      offsetFromDragPreview.x,
      // Align at the center
      offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
      // Dock to the right
      offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
    ]);
    return interpolantX.interpolate(anchorX);
  };
  const { offsetX, offsetY } = offsetPoint;
  const isManualOffsetX = offsetX === 0 || offsetX;
  const isManualOffsetY = offsetY === 0 || offsetY;
  return {
    x: isManualOffsetX ? offsetX : calculateXOffset(),
    y: isManualOffsetY ? offsetY : calculateYOffset()
  };
}
var OptionsReader$1 = class OptionsReader {
  get window() {
    if (this.globalContext) {
      return this.globalContext;
    } else if (typeof window !== "undefined") {
      return window;
    }
    return void 0;
  }
  get document() {
    var ref;
    if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
      return this.globalContext.document;
    } else if (this.window) {
      return this.window.document;
    } else {
      return void 0;
    }
  }
  get rootElement() {
    var ref;
    return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
  }
  constructor(globalContext, options) {
    this.ownerDocument = null;
    this.globalContext = globalContext;
    this.optionsArgs = options;
  }
};
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    });
  }
  return target;
}
var HTML5BackendImpl = class {
  /**
  * Generate profiling statistics for the HTML5Backend.
  */
  profile() {
    var ref, ref1;
    return {
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      sourceNodeOptions: this.sourceNodeOptions.size,
      sourceNodes: this.sourceNodes.size,
      dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
      dropTargetIds: this.dropTargetIds.length,
      dragEnterTargetIds: this.dragEnterTargetIds.length,
      dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
    };
  }
  // public for test
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  /**
  * Get the root element to use for event subscriptions
  */
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const root = this.rootElement;
    if (root === void 0) {
      return;
    }
    if (root.__isReactDndBackendSetUp) {
      throw new Error("Cannot have two HTML5 backends at the same time.");
    }
    root.__isReactDndBackendSetUp = true;
    this.addEventListeners(root);
  }
  teardown() {
    const root = this.rootElement;
    if (root === void 0) {
      return;
    }
    root.__isReactDndBackendSetUp = false;
    this.removeEventListeners(this.rootElement);
    this.clearCurrentDragSourceNode();
    if (this.asyncEndDragFrameId) {
      var ref;
      (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
    }
  }
  connectDragPreview(sourceId, node, options) {
    this.sourcePreviewNodeOptions.set(sourceId, options);
    this.sourcePreviewNodes.set(sourceId, node);
    return () => {
      this.sourcePreviewNodes.delete(sourceId);
      this.sourcePreviewNodeOptions.delete(sourceId);
    };
  }
  connectDragSource(sourceId, node, options) {
    this.sourceNodes.set(sourceId, node);
    this.sourceNodeOptions.set(sourceId, options);
    const handleDragStart = (e2) => this.handleDragStart(e2, sourceId);
    const handleSelectStart = (e2) => this.handleSelectStart(e2);
    node.setAttribute("draggable", "true");
    node.addEventListener("dragstart", handleDragStart);
    node.addEventListener("selectstart", handleSelectStart);
    return () => {
      this.sourceNodes.delete(sourceId);
      this.sourceNodeOptions.delete(sourceId);
      node.removeEventListener("dragstart", handleDragStart);
      node.removeEventListener("selectstart", handleSelectStart);
      node.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(targetId, node) {
    const handleDragEnter = (e2) => this.handleDragEnter(e2, targetId);
    const handleDragOver = (e2) => this.handleDragOver(e2, targetId);
    const handleDrop = (e2) => this.handleDrop(e2, targetId);
    node.addEventListener("dragenter", handleDragEnter);
    node.addEventListener("dragover", handleDragOver);
    node.addEventListener("drop", handleDrop);
    return () => {
      node.removeEventListener("dragenter", handleDragEnter);
      node.removeEventListener("dragover", handleDragOver);
      node.removeEventListener("drop", handleDrop);
    };
  }
  addEventListeners(target) {
    if (!target.addEventListener) {
      return;
    }
    target.addEventListener("dragstart", this.handleTopDragStart);
    target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.addEventListener("dragend", this.handleTopDragEndCapture, true);
    target.addEventListener("dragenter", this.handleTopDragEnter);
    target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.addEventListener("dragover", this.handleTopDragOver);
    target.addEventListener("dragover", this.handleTopDragOverCapture, true);
    target.addEventListener("drop", this.handleTopDrop);
    target.addEventListener("drop", this.handleTopDropCapture, true);
  }
  removeEventListeners(target) {
    if (!target.removeEventListener) {
      return;
    }
    target.removeEventListener("dragstart", this.handleTopDragStart);
    target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
    target.removeEventListener("dragenter", this.handleTopDragEnter);
    target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.removeEventListener("dragover", this.handleTopDragOver);
    target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
    target.removeEventListener("drop", this.handleTopDrop);
    target.removeEventListener("drop", this.handleTopDropCapture, true);
  }
  getCurrentSourceNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
    return _objectSpread({
      dropEffect: this.altKeyPressed ? "copy" : "move"
    }, sourceNodeOptions || {});
  }
  getCurrentDropEffect() {
    if (this.isDraggingNativeItem()) {
      return "copy";
    }
    return this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
    return _objectSpread({
      anchorX: 0.5,
      anchorY: 0.5,
      captureDraggingState: false
    }, sourcePreviewNodeOptions || {});
  }
  isDraggingNativeItem() {
    const itemType = this.monitor.getItemType();
    return Object.keys(NativeTypes).some(
      (key) => NativeTypes[key] === itemType
    );
  }
  beginDragNativeItem(type, dataTransfer) {
    this.clearCurrentDragSourceNode();
    this.currentNativeSource = createNativeDragSource(type, dataTransfer);
    this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
    this.actions.beginDrag([
      this.currentNativeHandle
    ]);
  }
  setCurrentDragSourceNode(node) {
    this.clearCurrentDragSourceNode();
    this.currentDragSourceNode = node;
    const MOUSE_MOVE_TIMEOUT = 1e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var ref;
      return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
    }, MOUSE_MOVE_TIMEOUT);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      this.currentDragSourceNode = null;
      if (this.rootElement) {
        var ref;
        (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
        this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
      }
      this.mouseMoveTimeoutTimer = null;
      return true;
    }
    return false;
  }
  handleDragStart(e2, sourceId) {
    if (e2.defaultPrevented) {
      return;
    }
    if (!this.dragStartSourceIds) {
      this.dragStartSourceIds = [];
    }
    this.dragStartSourceIds.unshift(sourceId);
  }
  handleDragEnter(_e2, targetId) {
    this.dragEnterTargetIds.unshift(targetId);
  }
  handleDragOver(_e2, targetId) {
    if (this.dragOverTargetIds === null) {
      this.dragOverTargetIds = [];
    }
    this.dragOverTargetIds.unshift(targetId);
  }
  handleDrop(_e2, targetId) {
    this.dropTargetIds.unshift(targetId);
  }
  constructor(manager, globalContext, options) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map();
    this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
    this.sourceNodes = /* @__PURE__ */ new Map();
    this.sourceNodeOptions = /* @__PURE__ */ new Map();
    this.dragStartSourceIds = null;
    this.dropTargetIds = [];
    this.dragEnterTargetIds = [];
    this.currentNativeSource = null;
    this.currentNativeHandle = null;
    this.currentDragSourceNode = null;
    this.altKeyPressed = false;
    this.mouseMoveTimeoutTimer = null;
    this.asyncEndDragFrameId = null;
    this.dragOverTargetIds = null;
    this.lastClientOffset = null;
    this.hoverRafId = null;
    this.getSourceClientOffset = (sourceId) => {
      const source = this.sourceNodes.get(sourceId);
      return source && getNodeClientOffset$1(source) || null;
    };
    this.endDragNativeItem = () => {
      if (!this.isDraggingNativeItem()) {
        return;
      }
      this.actions.endDrag();
      if (this.currentNativeHandle) {
        this.registry.removeSource(this.currentNativeHandle);
      }
      this.currentNativeHandle = null;
      this.currentNativeSource = null;
    };
    this.isNodeInDocument = (node) => {
      return Boolean(node && this.document && this.document.body && this.document.body.contains(node));
    };
    this.endDragIfSourceWasRemovedFromDOM = () => {
      const node = this.currentDragSourceNode;
      if (node == null || this.isNodeInDocument(node)) {
        return;
      }
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.scheduleHover = (dragOverTargetIds) => {
      if (this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
        this.hoverRafId = requestAnimationFrame(() => {
          if (this.monitor.isDragging()) {
            this.actions.hover(dragOverTargetIds || [], {
              clientOffset: this.lastClientOffset
            });
          }
          this.hoverRafId = null;
        });
      }
    };
    this.cancelHover = () => {
      if (this.hoverRafId !== null && typeof cancelAnimationFrame !== "undefined") {
        cancelAnimationFrame(this.hoverRafId);
        this.hoverRafId = null;
      }
    };
    this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode();
      this.dragStartSourceIds = [];
    };
    this.handleTopDragStart = (e2) => {
      if (e2.defaultPrevented) {
        return;
      }
      const { dragStartSourceIds } = this;
      this.dragStartSourceIds = null;
      const clientOffset = getEventClientOffset$1(e2);
      if (this.monitor.isDragging()) {
        this.actions.endDrag();
        this.cancelHover();
      }
      this.actions.beginDrag(dragStartSourceIds || [], {
        publishSource: false,
        getSourceClientOffset: this.getSourceClientOffset,
        clientOffset
      });
      const { dataTransfer } = e2;
      const nativeType = matchNativeItemType(dataTransfer);
      if (this.monitor.isDragging()) {
        if (dataTransfer && typeof dataTransfer.setDragImage === "function") {
          const sourceId = this.monitor.getSourceId();
          const sourceNode = this.sourceNodes.get(sourceId);
          const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
          if (dragPreview) {
            const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();
            const anchorPoint = {
              anchorX,
              anchorY
            };
            const offsetPoint = {
              offsetX,
              offsetY
            };
            const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
            dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
          }
        }
        try {
          dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData("application/json", {});
        } catch (err) {
        }
        this.setCurrentDragSourceNode(e2.target);
        const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();
        if (!captureDraggingState) {
          setTimeout(
            () => this.actions.publishDragSource(),
            0
          );
        } else {
          this.actions.publishDragSource();
        }
      } else if (nativeType) {
        this.beginDragNativeItem(nativeType);
      } else if (dataTransfer && !dataTransfer.types && (e2.target && !e2.target.hasAttribute || !e2.target.hasAttribute("draggable"))) {
        return;
      } else {
        e2.preventDefault();
      }
    };
    this.handleTopDragEndCapture = () => {
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleTopDragEnterCapture = (e2) => {
      this.dragEnterTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      }
      const isFirstEnter = this.enterLeaveCounter.enter(e2.target);
      if (!isFirstEnter || this.monitor.isDragging()) {
        return;
      }
      const { dataTransfer } = e2;
      const nativeType = matchNativeItemType(dataTransfer);
      if (nativeType) {
        this.beginDragNativeItem(nativeType, dataTransfer);
      }
    };
    this.handleTopDragEnter = (e2) => {
      const { dragEnterTargetIds } = this;
      this.dragEnterTargetIds = [];
      if (!this.monitor.isDragging()) {
        return;
      }
      this.altKeyPressed = e2.altKey;
      if (dragEnterTargetIds.length > 0) {
        this.actions.hover(dragEnterTargetIds, {
          clientOffset: getEventClientOffset$1(e2)
        });
      }
      const canDrop = dragEnterTargetIds.some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      }
    };
    this.handleTopDragOverCapture = (e2) => {
      this.dragOverTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      }
    };
    this.handleTopDragOver = (e2) => {
      const { dragOverTargetIds } = this;
      this.dragOverTargetIds = [];
      if (!this.monitor.isDragging()) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = "none";
        }
        return;
      }
      this.altKeyPressed = e2.altKey;
      this.lastClientOffset = getEventClientOffset$1(e2);
      this.scheduleHover(dragOverTargetIds);
      const canDrop = (dragOverTargetIds || []).some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      } else if (this.isDraggingNativeItem()) {
        e2.preventDefault();
      } else {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = "none";
        }
      }
    };
    this.handleTopDragLeaveCapture = (e2) => {
      if (this.isDraggingNativeItem()) {
        e2.preventDefault();
      }
      const isLastLeave = this.enterLeaveCounter.leave(e2.target);
      if (!isLastLeave) {
        return;
      }
      if (this.isDraggingNativeItem()) {
        setTimeout(
          () => this.endDragNativeItem(),
          0
        );
      }
      this.cancelHover();
    };
    this.handleTopDropCapture = (e2) => {
      this.dropTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        e2.preventDefault();
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      } else if (matchNativeItemType(e2.dataTransfer)) {
        e2.preventDefault();
      }
      this.enterLeaveCounter.reset();
    };
    this.handleTopDrop = (e2) => {
      const { dropTargetIds } = this;
      this.dropTargetIds = [];
      this.actions.hover(dropTargetIds, {
        clientOffset: getEventClientOffset$1(e2)
      });
      this.actions.drop({
        dropEffect: this.getCurrentDropEffect()
      });
      if (this.isDraggingNativeItem()) {
        this.endDragNativeItem();
      } else if (this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleSelectStart = (e2) => {
      const target = e2.target;
      if (typeof target.dragDrop !== "function") {
        return;
      }
      if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return;
      }
      e2.preventDefault();
      target.dragDrop();
    };
    this.options = new OptionsReader$1(globalContext, options);
    this.actions = manager.getActions();
    this.monitor = manager.getMonitor();
    this.registry = manager.getRegistry();
    this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
  }
};
var emptyImage;
function getEmptyImage() {
  if (!emptyImage) {
    emptyImage = new Image();
    emptyImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
  }
  return emptyImage;
}
var HTML5Backend = function createBackend(manager, context, options) {
  return new HTML5BackendImpl(manager, context, options);
};
var ListenerType;
(function(ListenerType2) {
  ListenerType2["mouse"] = "mouse";
  ListenerType2["touch"] = "touch";
  ListenerType2["keyboard"] = "keyboard";
})(ListenerType || (ListenerType = {}));
var OptionsReader2 = class {
  get delay() {
    var _delay;
    return (_delay = this.args.delay) !== null && _delay !== void 0 ? _delay : 0;
  }
  get scrollAngleRanges() {
    return this.args.scrollAngleRanges;
  }
  get getDropTargetElementsAtPoint() {
    return this.args.getDropTargetElementsAtPoint;
  }
  get ignoreContextMenu() {
    var _ignoreContextMenu;
    return (_ignoreContextMenu = this.args.ignoreContextMenu) !== null && _ignoreContextMenu !== void 0 ? _ignoreContextMenu : false;
  }
  get enableHoverOutsideTarget() {
    var _enableHoverOutsideTarget;
    return (_enableHoverOutsideTarget = this.args.enableHoverOutsideTarget) !== null && _enableHoverOutsideTarget !== void 0 ? _enableHoverOutsideTarget : false;
  }
  get enableKeyboardEvents() {
    var _enableKeyboardEvents;
    return (_enableKeyboardEvents = this.args.enableKeyboardEvents) !== null && _enableKeyboardEvents !== void 0 ? _enableKeyboardEvents : false;
  }
  get enableMouseEvents() {
    var _enableMouseEvents;
    return (_enableMouseEvents = this.args.enableMouseEvents) !== null && _enableMouseEvents !== void 0 ? _enableMouseEvents : false;
  }
  get enableTouchEvents() {
    var _enableTouchEvents;
    return (_enableTouchEvents = this.args.enableTouchEvents) !== null && _enableTouchEvents !== void 0 ? _enableTouchEvents : true;
  }
  get touchSlop() {
    return this.args.touchSlop || 0;
  }
  get delayTouchStart() {
    var ref, ref1;
    var ref2, ref3;
    return (ref3 = (ref2 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayTouchStart) !== null && ref2 !== void 0 ? ref2 : (ref1 = this.args) === null || ref1 === void 0 ? void 0 : ref1.delay) !== null && ref3 !== void 0 ? ref3 : 0;
  }
  get delayMouseStart() {
    var ref, ref4;
    var ref5, ref6;
    return (ref6 = (ref5 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayMouseStart) !== null && ref5 !== void 0 ? ref5 : (ref4 = this.args) === null || ref4 === void 0 ? void 0 : ref4.delay) !== null && ref6 !== void 0 ? ref6 : 0;
  }
  get window() {
    if (this.context && this.context.window) {
      return this.context.window;
    } else if (typeof window !== "undefined") {
      return window;
    }
    return void 0;
  }
  get document() {
    var ref;
    if ((ref = this.context) === null || ref === void 0 ? void 0 : ref.document) {
      return this.context.document;
    }
    if (this.window) {
      return this.window.document;
    }
    return void 0;
  }
  get rootElement() {
    var ref;
    return ((ref = this.args) === null || ref === void 0 ? void 0 : ref.rootElement) || this.document;
  }
  constructor(args, context) {
    this.args = args;
    this.context = context;
  }
};
function distance(x1, y1, x2, y2) {
  return Math.sqrt(Math.pow(Math.abs(x2 - x1), 2) + Math.pow(Math.abs(y2 - y1), 2));
}
function inAngleRanges(x1, y1, x2, y2, angleRanges) {
  if (!angleRanges) {
    return false;
  }
  const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI + 180;
  for (let i2 = 0; i2 < angleRanges.length; ++i2) {
    const ar2 = angleRanges[i2];
    if (ar2 && (ar2.start == null || angle >= ar2.start) && (ar2.end == null || angle <= ar2.end)) {
      return true;
    }
  }
  return false;
}
var MouseButtons = {
  Left: 1,
  Right: 2,
  Center: 4
};
var MouseButton = {
  Left: 0,
  Center: 1,
  Right: 2
};
function eventShouldStartDrag(e2) {
  return e2.button === void 0 || e2.button === MouseButton.Left;
}
function eventShouldEndDrag(e2) {
  return e2.buttons === void 0 || (e2.buttons & MouseButtons.Left) === 0;
}
function isTouchEvent(e2) {
  return !!e2.targetTouches;
}
var ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
  const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
  if (!el) {
    return void 0;
  }
  const { top, left } = el.getBoundingClientRect();
  return {
    x: left,
    y: top
  };
}
function getEventClientTouchOffset(e2, lastTargetTouchFallback) {
  if (e2.targetTouches.length === 1) {
    return getEventClientOffset(e2.targetTouches[0]);
  } else if (lastTargetTouchFallback && e2.touches.length === 1) {
    if (e2.touches[0].target === lastTargetTouchFallback.target) {
      return getEventClientOffset(e2.touches[0]);
    }
  }
  return;
}
function getEventClientOffset(e2, lastTargetTouchFallback) {
  if (isTouchEvent(e2)) {
    return getEventClientTouchOffset(e2, lastTargetTouchFallback);
  } else {
    return {
      x: e2.clientX,
      y: e2.clientY
    };
  }
}
var supportsPassive = (() => {
  let supported = false;
  try {
    addEventListener("test", () => {
    }, Object.defineProperty({}, "passive", {
      get() {
        supported = true;
        return true;
      }
    }));
  } catch (e2) {
  }
  return supported;
})();
var eventNames = {
  [ListenerType.mouse]: {
    start: "mousedown",
    move: "mousemove",
    end: "mouseup",
    contextmenu: "contextmenu"
  },
  [ListenerType.touch]: {
    start: "touchstart",
    move: "touchmove",
    end: "touchend"
  },
  [ListenerType.keyboard]: {
    keydown: "keydown"
  }
};
var TouchBackendImpl = class _TouchBackendImpl {
  /**
  * Generate profiling statistics for the HTML5Backend.
  */
  profile() {
    var ref;
    return {
      sourceNodes: this.sourceNodes.size,
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      targetNodes: this.targetNodes.size,
      dragOverTargetIds: ((ref = this.dragOverTargetIds) === null || ref === void 0 ? void 0 : ref.length) || 0
    };
  }
  // public for test
  get document() {
    return this.options.document;
  }
  setup() {
    const root = this.options.rootElement;
    if (!root) {
      return;
    }
    invariant(!_TouchBackendImpl.isSetUp, "Cannot have two Touch backends at the same time.");
    _TouchBackendImpl.isSetUp = true;
    this.addEventListener(root, "start", this.getTopMoveStartHandler());
    this.addEventListener(root, "start", this.handleTopMoveStartCapture, true);
    this.addEventListener(root, "move", this.handleTopMove);
    this.addEventListener(root, "move", this.handleTopMoveCapture, true);
    this.addEventListener(root, "end", this.handleTopMoveEndCapture, true);
    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {
      this.addEventListener(root, "contextmenu", this.handleTopMoveEndCapture);
    }
    if (this.options.enableKeyboardEvents) {
      this.addEventListener(root, "keydown", this.handleCancelOnEscape, true);
    }
  }
  teardown() {
    const root = this.options.rootElement;
    if (!root) {
      return;
    }
    _TouchBackendImpl.isSetUp = false;
    this._mouseClientOffset = {};
    this.removeEventListener(root, "start", this.handleTopMoveStartCapture, true);
    this.removeEventListener(root, "start", this.handleTopMoveStart);
    this.removeEventListener(root, "move", this.handleTopMoveCapture, true);
    this.removeEventListener(root, "move", this.handleTopMove);
    this.removeEventListener(root, "end", this.handleTopMoveEndCapture, true);
    if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {
      this.removeEventListener(root, "contextmenu", this.handleTopMoveEndCapture);
    }
    if (this.options.enableKeyboardEvents) {
      this.removeEventListener(root, "keydown", this.handleCancelOnEscape, true);
    }
    this.uninstallSourceNodeRemovalObserver();
  }
  addEventListener(subject, event, handler, capture = false) {
    const options = supportsPassive ? {
      capture,
      passive: false
    } : capture;
    this.listenerTypes.forEach(function(listenerType) {
      const evt = eventNames[listenerType][event];
      if (evt) {
        subject.addEventListener(evt, handler, options);
      }
    });
  }
  removeEventListener(subject, event, handler, capture = false) {
    const options = supportsPassive ? {
      capture,
      passive: false
    } : capture;
    this.listenerTypes.forEach(function(listenerType) {
      const evt = eventNames[listenerType][event];
      if (evt) {
        subject.removeEventListener(evt, handler, options);
      }
    });
  }
  connectDragSource(sourceId, node) {
    const handleMoveStart = this.handleMoveStart.bind(this, sourceId);
    this.sourceNodes.set(sourceId, node);
    this.addEventListener(node, "start", handleMoveStart);
    return () => {
      this.sourceNodes.delete(sourceId);
      this.removeEventListener(node, "start", handleMoveStart);
    };
  }
  connectDragPreview(sourceId, node, options) {
    this.sourcePreviewNodeOptions.set(sourceId, options);
    this.sourcePreviewNodes.set(sourceId, node);
    return () => {
      this.sourcePreviewNodes.delete(sourceId);
      this.sourcePreviewNodeOptions.delete(sourceId);
    };
  }
  connectDropTarget(targetId, node) {
    const root = this.options.rootElement;
    if (!this.document || !root) {
      return () => {
      };
    }
    const handleMove = (e2) => {
      if (!this.document || !root || !this.monitor.isDragging()) {
        return;
      }
      let coords;
      switch (e2.type) {
        case eventNames.mouse.move:
          coords = {
            x: e2.clientX,
            y: e2.clientY
          };
          break;
        case eventNames.touch.move:
          var ref, ref1;
          coords = {
            x: ((ref = e2.touches[0]) === null || ref === void 0 ? void 0 : ref.clientX) || 0,
            y: ((ref1 = e2.touches[0]) === null || ref1 === void 0 ? void 0 : ref1.clientY) || 0
          };
          break;
      }
      const droppedOn = coords != null ? this.document.elementFromPoint(coords.x, coords.y) : void 0;
      const childMatch = droppedOn && node.contains(droppedOn);
      if (droppedOn === node || childMatch) {
        return this.handleMove(e2, targetId);
      }
    };
    this.addEventListener(this.document.body, "move", handleMove);
    this.targetNodes.set(targetId, node);
    return () => {
      if (this.document) {
        this.targetNodes.delete(targetId);
        this.removeEventListener(this.document.body, "move", handleMove);
      }
    };
  }
  getTopMoveStartHandler() {
    if (!this.options.delayTouchStart && !this.options.delayMouseStart) {
      return this.handleTopMoveStart;
    }
    return this.handleTopMoveStartDelay;
  }
  installSourceNodeRemovalObserver(node) {
    this.uninstallSourceNodeRemovalObserver();
    this.draggedSourceNode = node;
    this.draggedSourceNodeRemovalObserver = new MutationObserver(() => {
      if (node && !node.parentElement) {
        this.resurrectSourceNode();
        this.uninstallSourceNodeRemovalObserver();
      }
    });
    if (!node || !node.parentElement) {
      return;
    }
    this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {
      childList: true
    });
  }
  resurrectSourceNode() {
    if (this.document && this.draggedSourceNode) {
      this.draggedSourceNode.style.display = "none";
      this.draggedSourceNode.removeAttribute("data-reactid");
      this.document.body.appendChild(this.draggedSourceNode);
    }
  }
  uninstallSourceNodeRemovalObserver() {
    if (this.draggedSourceNodeRemovalObserver) {
      this.draggedSourceNodeRemovalObserver.disconnect();
    }
    this.draggedSourceNodeRemovalObserver = void 0;
    this.draggedSourceNode = void 0;
  }
  constructor(manager, context, options) {
    this.getSourceClientOffset = (sourceId) => {
      const element = this.sourceNodes.get(sourceId);
      return element && getNodeClientOffset(element);
    };
    this.handleTopMoveStartCapture = (e2) => {
      if (!eventShouldStartDrag(e2)) {
        return;
      }
      this.moveStartSourceIds = [];
    };
    this.handleMoveStart = (sourceId) => {
      if (Array.isArray(this.moveStartSourceIds)) {
        this.moveStartSourceIds.unshift(sourceId);
      }
    };
    this.handleTopMoveStart = (e2) => {
      if (!eventShouldStartDrag(e2)) {
        return;
      }
      const clientOffset = getEventClientOffset(e2);
      if (clientOffset) {
        if (isTouchEvent(e2)) {
          this.lastTargetTouchFallback = e2.targetTouches[0];
        }
        this._mouseClientOffset = clientOffset;
      }
      this.waitingForDelay = false;
    };
    this.handleTopMoveStartDelay = (e2) => {
      if (!eventShouldStartDrag(e2)) {
        return;
      }
      const delay = e2.type === eventNames.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;
      this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e2), delay);
      this.waitingForDelay = true;
    };
    this.handleTopMoveCapture = () => {
      this.dragOverTargetIds = [];
    };
    this.handleMove = (_evt, targetId) => {
      if (this.dragOverTargetIds) {
        this.dragOverTargetIds.unshift(targetId);
      }
    };
    this.handleTopMove = (e1) => {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      if (!this.document || this.waitingForDelay) {
        return;
      }
      const { moveStartSourceIds, dragOverTargetIds } = this;
      const enableHoverOutsideTarget = this.options.enableHoverOutsideTarget;
      const clientOffset = getEventClientOffset(e1, this.lastTargetTouchFallback);
      if (!clientOffset) {
        return;
      }
      if (this._isScrolling || !this.monitor.isDragging() && inAngleRanges(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, this.options.scrollAngleRanges)) {
        this._isScrolling = true;
        return;
      }
      if (!this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins
      this._mouseClientOffset.hasOwnProperty("x") && moveStartSourceIds && distance(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (this.options.touchSlop ? this.options.touchSlop : 0)) {
        this.moveStartSourceIds = void 0;
        this.actions.beginDrag(moveStartSourceIds, {
          clientOffset: this._mouseClientOffset,
          getSourceClientOffset: this.getSourceClientOffset,
          publishSource: false
        });
      }
      if (!this.monitor.isDragging()) {
        return;
      }
      const sourceNode = this.sourceNodes.get(this.monitor.getSourceId());
      this.installSourceNodeRemovalObserver(sourceNode);
      this.actions.publishDragSource();
      if (e1.cancelable)
        e1.preventDefault();
      const dragOverTargetNodes = (dragOverTargetIds || []).map(
        (key) => this.targetNodes.get(key)
      ).filter(
        (e2) => !!e2
      );
      const elementsAtPoint = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : this.document.elementsFromPoint(clientOffset.x, clientOffset.y);
      const elementsAtPointExtended = [];
      for (const nodeId in elementsAtPoint) {
        if (!elementsAtPoint.hasOwnProperty(nodeId)) {
          continue;
        }
        let currentNode = elementsAtPoint[nodeId];
        if (currentNode != null) {
          elementsAtPointExtended.push(currentNode);
        }
        while (currentNode) {
          currentNode = currentNode.parentElement;
          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {
            elementsAtPointExtended.push(currentNode);
          }
        }
      }
      const orderedDragOverTargetIds = elementsAtPointExtended.filter(
        (node) => dragOverTargetNodes.indexOf(node) > -1
      ).map(
        (node) => this._getDropTargetId(node)
      ).filter(
        (node) => !!node
      ).filter(
        (id, index, ids) => ids.indexOf(id) === index
      );
      if (enableHoverOutsideTarget) {
        for (const targetId in this.targetNodes) {
          const targetNode = this.targetNodes.get(targetId);
          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {
            orderedDragOverTargetIds.unshift(targetId);
            break;
          }
        }
      }
      orderedDragOverTargetIds.reverse();
      this.actions.hover(orderedDragOverTargetIds, {
        clientOffset
      });
    };
    this._getDropTargetId = (node) => {
      const keys = this.targetNodes.keys();
      let next = keys.next();
      while (next.done === false) {
        const targetId = next.value;
        if (node === this.targetNodes.get(targetId)) {
          return targetId;
        } else {
          next = keys.next();
        }
      }
      return void 0;
    };
    this.handleTopMoveEndCapture = (e2) => {
      this._isScrolling = false;
      this.lastTargetTouchFallback = void 0;
      if (!eventShouldEndDrag(e2)) {
        return;
      }
      if (!this.monitor.isDragging() || this.monitor.didDrop()) {
        this.moveStartSourceIds = void 0;
        return;
      }
      if (e2.cancelable)
        e2.preventDefault();
      this._mouseClientOffset = {};
      this.uninstallSourceNodeRemovalObserver();
      this.actions.drop();
      this.actions.endDrag();
    };
    this.handleCancelOnEscape = (e2) => {
      if (e2.key === "Escape" && this.monitor.isDragging()) {
        this._mouseClientOffset = {};
        this.uninstallSourceNodeRemovalObserver();
        this.actions.endDrag();
      }
    };
    this.options = new OptionsReader2(options, context);
    this.actions = manager.getActions();
    this.monitor = manager.getMonitor();
    this.sourceNodes = /* @__PURE__ */ new Map();
    this.sourcePreviewNodes = /* @__PURE__ */ new Map();
    this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
    this.targetNodes = /* @__PURE__ */ new Map();
    this.listenerTypes = [];
    this._mouseClientOffset = {};
    this._isScrolling = false;
    if (this.options.enableMouseEvents) {
      this.listenerTypes.push(ListenerType.mouse);
    }
    if (this.options.enableTouchEvents) {
      this.listenerTypes.push(ListenerType.touch);
    }
    if (this.options.enableKeyboardEvents) {
      this.listenerTypes.push(ListenerType.keyboard);
    }
  }
};
var TouchBackend = function createBackend2(manager, context = {}, options = {}) {
  return new TouchBackendImpl(manager, context, options);
};
var COLUMNS = "abcdefgh".split("");
var START_POSITION_OBJECT = {
  a8: "bR",
  b8: "bN",
  c8: "bB",
  d8: "bQ",
  e8: "bK",
  f8: "bB",
  g8: "bN",
  h8: "bR",
  a7: "bP",
  b7: "bP",
  c7: "bP",
  d7: "bP",
  e7: "bP",
  f7: "bP",
  g7: "bP",
  h7: "bP",
  a2: "wP",
  b2: "wP",
  c2: "wP",
  d2: "wP",
  e2: "wP",
  f2: "wP",
  g2: "wP",
  h2: "wP",
  a1: "wR",
  b1: "wN",
  c1: "wB",
  d1: "wQ",
  e1: "wK",
  f1: "wB",
  g1: "wN",
  h1: "wR"
};
var WHITE_COLUMN_VALUES = {
  a: 0,
  b: 1,
  c: 2,
  d: 3,
  e: 4,
  f: 5,
  g: 6,
  h: 7
};
var BLACK_COLUMN_VALUES = {
  a: 7,
  b: 6,
  c: 5,
  d: 4,
  e: 3,
  f: 2,
  g: 1,
  h: 0
};
var WHITE_ROWS = [7, 6, 5, 4, 3, 2, 1, 0];
var BLACK_ROWS = [0, 1, 2, 3, 4, 5, 6, 7];
var defaultPieces = {
  wP: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsx)("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: {
    opacity: "1",
    fill: "#ffffff",
    fillOpacity: "1",
    fillRule: "nonzero",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "miter",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }) })),
  wR: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    opacity: "1",
    fill: "#ffffff",
    fillOpacity: "1",
    fillRule: "evenodd",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 34,14 L 31,17 L 14,17 L 11,14" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 31,17 L 31,29.5 L 14,29.5 L 14,17", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11,14 L 34,14", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })),
  wN: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    opacity: "1",
    fill: "none",
    fillOpacity: "1",
    fillRule: "evenodd",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#000000", stroke: "#000000" } })] })) })),
  wB: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    opacity: "1",
    fill: "none",
    fillRule: "evenodd",
    fillOpacity: "1",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: { fill: "#ffffff", stroke: "#000000", strokeLinecap: "butt" } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), (0, import_jsx_runtime3.jsx)("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })),
  wQ: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    fill: "#ffffff",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinejoin: "round"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30", style: { fill: "none" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12,33.5 C 18,32.5 27,32.5 33,33.5", style: { fill: "none" } }), (0, import_jsx_runtime3.jsx)("circle", { cx: "6", cy: "12", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "14", cy: "9", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "22.5", cy: "8", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "31", cy: "9", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "39", cy: "12", r: "2" })] })) })),
  wK: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    fill: "none",
    fillOpacity: "1",
    fillRule: "evenodd",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: {
    fill: "#ffffff",
    stroke: "#000000",
    strokeLinecap: "butt",
    strokeLinejoin: "miter"
  } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30", style: { fill: "none", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5", style: { fill: "none", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#000000" } })] })) })),
  bP: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsx)("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: {
    opacity: "1",
    fill: "#000000",
    fillOpacity: "1",
    fillRule: "nonzero",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "miter",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }) })),
  bR: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    opacity: "1",
    fill: "#000000",
    fillOpacity: "1",
    fillRule: "evenodd",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z ", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12,35.5 L 33,35.5 L 33,35.5", style: {
    fill: "none",
    stroke: "#ffffff",
    strokeWidth: "1",
    strokeLinejoin: "miter"
  } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 13,31.5 L 32,31.5", style: {
    fill: "none",
    stroke: "#ffffff",
    strokeWidth: "1",
    strokeLinejoin: "miter"
  } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 14,29.5 L 31,29.5", style: {
    fill: "none",
    stroke: "#ffffff",
    strokeWidth: "1",
    strokeLinejoin: "miter"
  } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 14,16.5 L 31,16.5", style: {
    fill: "none",
    stroke: "#ffffff",
    strokeWidth: "1",
    strokeLinejoin: "miter"
  } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11,14 L 34,14", style: {
    fill: "none",
    stroke: "#ffffff",
    strokeWidth: "1",
    strokeLinejoin: "miter"
  } })] })) })),
  bN: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    opacity: "1",
    fill: "none",
    fillOpacity: "1",
    fillRule: "evenodd",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#ffffff", stroke: "#ffffff" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#ffffff", stroke: "#ffffff" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z ", style: { fill: "#ffffff", stroke: "none" } })] })) })),
  bB: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    opacity: "1",
    fill: "none",
    fillRule: "evenodd",
    fillOpacity: "1",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: { fill: "#000000", stroke: "#000000", strokeLinecap: "butt" } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), (0, import_jsx_runtime3.jsx)("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#ffffff", strokeLinejoin: "miter" } })] })) })),
  bQ: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    fill: "#000000",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z", style: { strokeLinecap: "butt", fill: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30" }), (0, import_jsx_runtime3.jsx)("path", { d: "m 12,33.5 c 6,-1 15,-1 21,0" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "6", cy: "12", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "14", cy: "9", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "22.5", cy: "8", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "31", cy: "9", r: "2" }), (0, import_jsx_runtime3.jsx)("circle", { cx: "39", cy: "12", r: "2" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11,38.5 A 35,35 1 0 0 34,38.5", style: { fill: "none", stroke: "#000000", strokeLinecap: "butt" } }), (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: { fill: "none", stroke: "#ffffff" } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 11,29 A 35,35 1 0 1 34,29" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,31.5 L 32.5,31.5" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 11.5,34.5 A 35,35 1 0 0 33.5,34.5" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 10.5,37.5 A 35,35 1 0 0 34.5,37.5" })] }))] })) })),
  bK: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime3.jsxs)("g", Object.assign({ style: {
    fill: "none",
    fillOpacity: "1",
    fillRule: "evenodd",
    stroke: "#000000",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "4",
    strokeDasharray: "none",
    strokeOpacity: "1"
  } }, { children: [(0, import_jsx_runtime3.jsx)("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" }, id: "path6570" }), (0, import_jsx_runtime3.jsx)("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: {
    fill: "#000000",
    fillOpacity: "1",
    strokeLinecap: "butt",
    strokeLinejoin: "miter"
  } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5", style: { fill: "none", stroke: "#ffffff" } }), (0, import_jsx_runtime3.jsx)("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#ffffff" } })] })) }))
};
function getRelativeCoords(boardOrientation, boardWidth, square) {
  const squareWidth = boardWidth / 8;
  const columns = boardOrientation === "white" ? WHITE_COLUMN_VALUES : BLACK_COLUMN_VALUES;
  const rows = boardOrientation === "white" ? WHITE_ROWS : BLACK_ROWS;
  const x2 = columns[square[0]] * squareWidth + squareWidth / 2;
  const y2 = rows[parseInt(square[1], 10) - 1] * squareWidth + squareWidth / 2;
  return { x: x2, y: y2 };
}
function isDifferentFromStart(newPosition) {
  let isDifferent = false;
  Object.keys(START_POSITION_OBJECT).forEach((square) => {
    if (newPosition[square] !== START_POSITION_OBJECT[square])
      isDifferent = true;
  });
  Object.keys(newPosition).forEach((square) => {
    if (START_POSITION_OBJECT[square] !== newPosition[square])
      isDifferent = true;
  });
  return isDifferent;
}
function getPositionDifferences(currentPosition, newPosition) {
  const difference = {
    removed: {},
    added: {}
  };
  Object.keys(currentPosition).forEach((square) => {
    if (newPosition[square] !== currentPosition[square])
      difference.removed[square] = currentPosition[square];
  });
  Object.keys(newPosition).forEach((square) => {
    if (currentPosition[square] !== newPosition[square])
      difference.added[square] = newPosition[square];
  });
  return difference;
}
function convertPositionToObject(position) {
  if (position === "start") {
    return START_POSITION_OBJECT;
  }
  if (typeof position === "string") {
    return fenToObj(position);
  }
  return position;
}
function fenToObj(fen) {
  if (!isValidFen(fen))
    return {};
  fen = fen.replace(/ .+$/, "");
  const rows = fen.split("/");
  const position = {};
  let currentRow = 8;
  for (let i2 = 0; i2 < 8; i2++) {
    const row = rows[i2].split("");
    let colIdx = 0;
    for (let j2 = 0; j2 < row.length; j2++) {
      if (row[j2].search(/[1-8]/) !== -1) {
        const numEmptySquares = parseInt(row[j2], 10);
        colIdx = colIdx + numEmptySquares;
      } else {
        const square = COLUMNS[colIdx] + currentRow;
        position[square] = fenToPieceCode(row[j2]);
        colIdx = colIdx + 1;
      }
    }
    currentRow = currentRow - 1;
  }
  return position;
}
function isValidFen(fen) {
  fen = fen.replace(/ .+$/, "");
  fen = expandFenEmptySquares(fen);
  const chunks = fen.split("/");
  if (chunks.length !== 8)
    return false;
  for (let i2 = 0; i2 < 8; i2++) {
    if (chunks[i2].length !== 8 || chunks[i2].search(/[^kqrnbpKQRNBP1]/) !== -1) {
      return false;
    }
  }
  return true;
}
function expandFenEmptySquares(fen) {
  return fen.replace(/8/g, "11111111").replace(/7/g, "1111111").replace(/6/g, "111111").replace(/5/g, "11111").replace(/4/g, "1111").replace(/3/g, "111").replace(/2/g, "11");
}
function fenToPieceCode(piece) {
  if (piece.toLowerCase() === piece) {
    return "b" + piece.toUpperCase();
  }
  return "w" + piece.toUpperCase();
}
var useArrows = (customArrows, areArrowsAllowed = true, onArrowsChange, customArrowColor) => {
  const [customArrowsSet, setCustomArrows] = (0, import_react6.useState)([]);
  const [arrows, setArrows] = (0, import_react6.useState)([]);
  const [newArrow, setNewArrow] = (0, import_react6.useState)();
  (0, import_react6.useEffect)(() => {
    if (Array.isArray(customArrows)) {
      setCustomArrows(
        //filter out arrows which starts and ends in the same square
        customArrows === null || customArrows === void 0 ? void 0 : customArrows.filter((arrow) => arrow[0] !== arrow[1])
      );
    }
  }, [customArrows]);
  (0, import_react6.useEffect)(() => {
    onArrowsChange === null || onArrowsChange === void 0 ? void 0 : onArrowsChange(arrows);
  }, [arrows]);
  function clearArrows() {
    setArrows([]);
    setNewArrow(void 0);
  }
  const drawNewArrow = (fromSquare, toSquare) => {
    if (!areArrowsAllowed)
      return;
    setNewArrow([fromSquare, toSquare, customArrowColor]);
  };
  const allBoardArrows = [...arrows, ...customArrowsSet];
  const onArrowDrawEnd = (fromSquare, toSquare) => {
    if (fromSquare === toSquare || !areArrowsAllowed)
      return;
    let arrowsCopy;
    const newArrow2 = [fromSquare, toSquare, customArrowColor];
    const isNewArrowUnique = allBoardArrows.every(([arrowFrom, arrowTo]) => {
      return !(arrowFrom === fromSquare && arrowTo === toSquare);
    });
    if (isNewArrowUnique) {
      arrowsCopy = [...arrows, newArrow2];
    } else {
      arrowsCopy = arrows.filter(([arrowFrom, arrowTo]) => {
        return !(arrowFrom === fromSquare && arrowTo === toSquare);
      });
    }
    setNewArrow(void 0);
    setArrows(arrowsCopy);
  };
  return {
    arrows: allBoardArrows,
    newArrow,
    clearArrows,
    drawNewArrow,
    setArrows,
    onArrowDrawEnd
  };
};
var ChessboardContext = (0, import_react6.createContext)({});
var useChessboard = () => (0, import_react6.useContext)(ChessboardContext);
var ChessboardProvider = (0, import_react6.forwardRef)(({ allowDragOutsideBoard = true, animationDuration = 300, areArrowsAllowed = true, arePiecesDraggable = true, arePremovesAllowed = false, autoPromoteToQueen = false, boardOrientation = "white", boardWidth, children, clearPremovesOnRightClick = true, customArrows, customArrowColor = "rgb(255,170,0)", customBoardStyle, customNotationStyle, customDarkSquareStyle = { backgroundColor: "#B58863" }, customDropSquareStyle = {
  boxShadow: "inset 0 0 1px 6px rgba(255,255,255,0.75)"
}, customLightSquareStyle = { backgroundColor: "#F0D9B5" }, customPieces, customPremoveDarkSquareStyle = { backgroundColor: "#A42323" }, customPremoveLightSquareStyle = { backgroundColor: "#BD2828" }, customSquare = "div", customSquareStyles, dropOffBoardAction = "snapback", id = 0, isDraggablePiece = () => true, getPositionObject = () => {
}, onArrowsChange = () => {
}, onDragOverSquare = () => {
}, onMouseOutSquare = () => {
}, onMouseOverSquare = () => {
}, onPieceClick = () => {
}, onPieceDragBegin = () => {
}, onPieceDragEnd = () => {
}, onPieceDrop = () => true, onPromotionCheck = (sourceSquare, targetSquare, piece) => {
  return (piece === "wP" && sourceSquare[1] === "7" && targetSquare[1] === "8" || piece === "bP" && sourceSquare[1] === "2" && targetSquare[1] === "1") && Math.abs(sourceSquare.charCodeAt(0) - targetSquare.charCodeAt(0)) <= 1;
}, onPromotionPieceSelect, onSquareClick = () => {
}, onSquareRightClick = () => {
}, position = "start", promotionDialogVariant = "default", promotionToSquare = null, showBoardNotation = true, showPromotionDialog = false, snapToCursor = true }, ref) => {
  const [currentPosition, setCurrentPosition] = (0, import_react6.useState)(convertPositionToObject(position));
  const [positionDifferences, setPositionDifferences] = (0, import_react6.useState)({ removed: {}, added: {} });
  const [lastPieceColour, setLastPieceColour] = (0, import_react6.useState)(void 0);
  const [showPromoteDialog, setShowPromoteDialog] = (0, import_react6.useState)(showPromotionDialog && !autoPromoteToQueen);
  const [promoteFromSquare, setPromoteFromSquare] = (0, import_react6.useState)(null);
  const [promoteToSquare, setPromoteToSquare] = (0, import_react6.useState)(promotionToSquare);
  const [premoves, setPremoves] = (0, import_react6.useState)([]);
  const premovesRef = (0, import_react6.useRef)(premoves);
  const [currentRightClickDown, setCurrentRightClickDown] = (0, import_react6.useState)();
  const [chessPieces, setChessPieces] = (0, import_react6.useState)(Object.assign(Object.assign({}, defaultPieces), customPieces));
  const [wasManualDrop, setWasManualDrop] = (0, import_react6.useState)(false);
  const [previousTimeout, setPreviousTimeout] = (0, import_react6.useState)();
  const [isWaitingForAnimation, setIsWaitingForAnimation] = (0, import_react6.useState)(false);
  (0, import_react6.useImperativeHandle)(ref, () => ({
    clearPremoves(clearLastPieceColour = true) {
      clearPremoves(clearLastPieceColour);
    }
  }));
  (0, import_react6.useEffect)(() => {
    setChessPieces(Object.assign(Object.assign({}, defaultPieces), customPieces));
  }, [customPieces]);
  (0, import_react6.useEffect)(() => {
    setShowPromoteDialog(showPromotionDialog);
    setPromoteToSquare(promotionToSquare);
  }, [promotionToSquare, showPromotionDialog]);
  (0, import_react6.useEffect)(() => {
    var _a, _b, _c;
    clearPromotion();
    const newPosition = convertPositionToObject(position);
    const differences = getPositionDifferences(currentPosition, newPosition);
    const newPieceColour = ((_a = Object.keys(differences.added)) === null || _a === void 0 ? void 0 : _a.length) <= 2 ? (_c = (_b = Object.entries(differences.added)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c[1][0] : void 0;
    if (isWaitingForAnimation) {
      setCurrentPosition(newPosition);
      setIsWaitingForAnimation(false);
      arePremovesAllowed && attemptPremove(newPieceColour);
      if (previousTimeout) {
        clearTimeout(previousTimeout);
      }
    } else {
      if (wasManualDrop) {
        setCurrentPosition(newPosition);
        setIsWaitingForAnimation(false);
        arePremovesAllowed && attemptPremove(newPieceColour);
      } else {
        if (isDifferentFromStart(newPosition) && lastPieceColour !== void 0) {
          setLastPieceColour(newPieceColour);
        } else if (!isDifferentFromStart(newPosition)) {
          setLastPieceColour("b");
        } else {
          setLastPieceColour(void 0);
        }
        setPositionDifferences(differences);
        setIsWaitingForAnimation(true);
        const newTimeout = setTimeout(() => {
          setCurrentPosition(newPosition);
          setIsWaitingForAnimation(false);
          arePremovesAllowed && attemptPremove(newPieceColour);
        }, animationDuration);
        setPreviousTimeout(newTimeout);
      }
    }
    setWasManualDrop(false);
    getPositionObject(newPosition);
    clearArrows();
    return () => {
      clearTimeout(previousTimeout);
    };
  }, [position]);
  const { arrows, newArrow, clearArrows, drawNewArrow, onArrowDrawEnd } = useArrows(customArrows, areArrowsAllowed, onArrowsChange, customArrowColor);
  function handleSetPosition(sourceSq, targetSq, piece, wasManualDropOverride) {
    if (sourceSq === targetSq) {
      return;
    }
    clearArrows();
    if (arePremovesAllowed && isWaitingForAnimation || arePremovesAllowed && (lastPieceColour === piece[0] || premovesRef.current.filter((p2) => p2.piece[0] === piece[0]).length > 0)) {
      const oldPremoves = [...premovesRef.current];
      oldPremoves.push({ sourceSq, targetSq, piece });
      premovesRef.current = oldPremoves;
      setPremoves([...oldPremoves]);
      clearPromotion();
      return;
    }
    if (!arePremovesAllowed && isWaitingForAnimation)
      return;
    const newOnDropPosition = Object.assign({}, currentPosition);
    setWasManualDrop(!!wasManualDropOverride);
    setLastPieceColour(piece[0]);
    if (onPieceDrop.length) {
      const isValidMove = onPieceDrop(sourceSq, targetSq, piece);
      if (!isValidMove) {
        clearPremoves();
        setWasManualDrop(false);
      }
    } else {
      if (dropOffBoardAction === "trash" && !targetSq) {
        delete newOnDropPosition[sourceSq];
      }
      delete newOnDropPosition[sourceSq];
      newOnDropPosition[targetSq] = piece;
      setCurrentPosition(newOnDropPosition);
    }
    clearPromotion();
    getPositionObject(newOnDropPosition);
  }
  function attemptPremove(newPieceColour) {
    if (premovesRef.current.length === 0)
      return;
    const premove = premovesRef.current[0];
    if (premove.piece[0] !== void 0 && premove.piece[0] !== newPieceColour && onPieceDrop.length) {
      setLastPieceColour(premove.piece[0]);
      setWasManualDrop(true);
      const isValidMove = onPieceDrop(premove.sourceSq, premove.targetSq, premove.piece);
      if (isValidMove) {
        const oldPremoves = [...premovesRef.current];
        oldPremoves.shift();
        premovesRef.current = oldPremoves;
        setPremoves([...oldPremoves]);
      } else {
        clearPremoves();
      }
    }
  }
  function clearPremoves(clearLastPieceColour = true) {
    if (clearLastPieceColour)
      setLastPieceColour(void 0);
    premovesRef.current = [];
    setPremoves([]);
  }
  function clearPromotion() {
    setPromoteFromSquare(null);
    setPromoteToSquare(null);
    setShowPromoteDialog(false);
  }
  function onRightClickDown(square) {
    setCurrentRightClickDown(square);
  }
  function onRightClickUp(square) {
    if (currentRightClickDown) {
      if (currentRightClickDown === square) {
        setCurrentRightClickDown(void 0);
        clearPremovesOnRightClick && clearPremoves(false);
        onSquareRightClick(square);
        return;
      }
    } else
      setCurrentRightClickDown(void 0);
  }
  function clearCurrentRightClickDown() {
    setCurrentRightClickDown(void 0);
  }
  const ChessboardProviderContextValue = {
    animationDuration,
    arePiecesDraggable,
    arePremovesAllowed,
    boardOrientation,
    boardWidth,
    customArrowColor,
    customBoardStyle,
    customNotationStyle,
    customDarkSquareStyle,
    customDropSquareStyle,
    customLightSquareStyle,
    customPremoveDarkSquareStyle,
    customPremoveLightSquareStyle,
    customSquare,
    customSquareStyles,
    id,
    isDraggablePiece,
    onDragOverSquare,
    onMouseOutSquare,
    onMouseOverSquare,
    onPieceClick,
    onPieceDragBegin,
    onPieceDragEnd,
    onPieceDrop,
    onPromotionCheck,
    onPromotionPieceSelect,
    onSquareClick,
    showBoardNotation,
    snapToCursor,
    promotionDialogVariant,
    allowDragOutsideBoard,
    arrows,
    newArrow,
    onArrowDrawEnd,
    chessPieces,
    clearArrows,
    drawNewArrow,
    clearCurrentRightClickDown,
    currentPosition,
    handleSetPosition,
    isWaitingForAnimation,
    lastPieceColour,
    onRightClickDown,
    onRightClickUp,
    positionDifferences,
    promoteFromSquare,
    promoteToSquare,
    premoves,
    setPromoteFromSquare,
    setPromoteToSquare,
    setShowPromoteDialog,
    showPromoteDialog,
    autoPromoteToQueen,
    currentRightClickDown
  };
  return (0, import_jsx_runtime3.jsx)(ChessboardContext.Provider, Object.assign({ value: ChessboardProviderContextValue }, { children }));
});
function Notation({ row, col }) {
  const { boardOrientation, boardWidth, customDarkSquareStyle, customLightSquareStyle, customNotationStyle } = useChessboard();
  const whiteColor = customLightSquareStyle.backgroundColor;
  const blackColor = customDarkSquareStyle.backgroundColor;
  const isRow = col === 0;
  const isColumn = row === 7;
  const isBottomLeftSquare = isRow && isColumn;
  function getRow() {
    return boardOrientation === "white" ? 8 - row : row + 1;
  }
  function getColumn() {
    return boardOrientation === "black" ? COLUMNS[7 - col] : COLUMNS[col];
  }
  function renderBottomLeft() {
    return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: whiteColor }), numericStyle(boardWidth, customNotationStyle)) }, { children: getRow() })), (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: whiteColor }), alphaStyle(boardWidth, customNotationStyle)) }, { children: getColumn() }))] });
  }
  function renderLetters() {
    return (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, { color: col % 2 !== 0 ? blackColor : whiteColor }), alphaStyle(boardWidth, customNotationStyle)) }, { children: getColumn() }));
  }
  function renderNumbers() {
    return (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, boardOrientation === "black" ? { color: row % 2 === 0 ? blackColor : whiteColor } : { color: row % 2 === 0 ? blackColor : whiteColor }), numericStyle(boardWidth, customNotationStyle)) }, { children: getRow() }));
  }
  if (isBottomLeftSquare) {
    return renderBottomLeft();
  }
  if (isColumn) {
    return renderLetters();
  }
  if (isRow) {
    return renderNumbers();
  }
  return null;
}
var alphaStyle = (width, customNotationStyle) => Object.assign({ alignSelf: "flex-end", paddingLeft: width / 8 - width / 48, fontSize: width / 48 }, customNotationStyle);
var numericStyle = (width, customNotationStyle) => Object.assign({ alignSelf: "flex-start", paddingRight: width / 8 - width / 48, fontSize: width / 48 }, customNotationStyle);
function Piece({ isPremovedPiece = false, piece, square, squares }) {
  const { animationDuration, arePiecesDraggable, boardWidth, boardOrientation, chessPieces, currentPosition, id, isDraggablePiece, isWaitingForAnimation, onPieceClick, onPieceDragBegin, onPieceDragEnd, positionDifferences, onPromotionCheck } = useChessboard();
  const [pieceStyle, setPieceStyle] = (0, import_react6.useState)({
    opacity: 1,
    zIndex: 5,
    touchAction: "none",
    cursor: arePiecesDraggable && isDraggablePiece({ piece, sourceSquare: square }) ? "-webkit-grab" : "default"
  });
  const [{ canDrag, isDragging }, drag, dragPreview] = useDrag(() => ({
    type: "piece",
    item: () => {
      onPieceDragBegin(piece, square);
      return { piece, square, id };
    },
    end: () => onPieceDragEnd(piece, square),
    collect: (monitor) => ({
      canDrag: isDraggablePiece({ piece, sourceSquare: square }),
      isDragging: !!monitor.isDragging()
    })
  }), [piece, square, currentPosition, id]);
  dragPreview(getEmptyImage(), { captureDraggingState: true });
  (0, import_react6.useEffect)(() => {
    setPieceStyle((oldPieceStyle) => Object.assign(Object.assign({}, oldPieceStyle), { opacity: isDragging ? 0 : 1 }));
  }, [isDragging]);
  (0, import_react6.useEffect)(() => {
    var _a;
    const removedPiece = (_a = positionDifferences.removed) === null || _a === void 0 ? void 0 : _a[square];
    if (!positionDifferences.added || !removedPiece)
      return;
    const newSquare = Object.entries(positionDifferences.added).find(([s2, p2]) => p2 === removedPiece || onPromotionCheck(square, s2, removedPiece));
    if (isWaitingForAnimation && removedPiece && newSquare && !isPremovedPiece) {
      const sourceSq = square;
      const targetSq = newSquare[0];
      if (sourceSq && targetSq) {
        const squareWidth = boardWidth / 8;
        setPieceStyle((oldPieceStyle) => Object.assign(Object.assign({}, oldPieceStyle), { transform: `translate(${(boardOrientation === "black" ? -1 : 1) * (targetSq.charCodeAt(0) - sourceSq.charCodeAt(0)) * squareWidth}px, ${(boardOrientation === "black" ? -1 : 1) * (Number(sourceSq[1]) - Number(targetSq[1])) * squareWidth}px)`, transition: `transform ${animationDuration}ms`, zIndex: 6 }));
      }
    }
  }, [positionDifferences]);
  (0, import_react6.useEffect)(() => {
    const { sourceSq } = getSingleSquareCoordinates();
    if (sourceSq) {
      setPieceStyle((oldPieceStyle) => Object.assign(Object.assign({}, oldPieceStyle), { transform: `translate(${0}px, ${0}px)`, transition: `transform ${0}ms` }));
    }
  }, [currentPosition]);
  (0, import_react6.useEffect)(() => {
    setPieceStyle((oldPieceStyle) => Object.assign(Object.assign({}, oldPieceStyle), { cursor: arePiecesDraggable && isDraggablePiece({ piece, sourceSquare: square }) ? "-webkit-grab" : "default" }));
  }, [square, currentPosition, arePiecesDraggable]);
  function getSingleSquareCoordinates() {
    return { sourceSq: squares[square] };
  }
  return (0, import_jsx_runtime3.jsx)("div", Object.assign({ ref: arePiecesDraggable ? canDrag ? drag : null : null, onClick: () => onPieceClick(piece, square), "data-piece": piece, style: pieceStyle }, { children: typeof chessPieces[piece] === "function" ? chessPieces[piece]({
    squareWidth: boardWidth / 8,
    isDragging,
    square
  }) : (0, import_jsx_runtime3.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: boardWidth / 8, height: boardWidth / 8 }, { children: (0, import_jsx_runtime3.jsx)("g", { children: chessPieces[piece] }) })) }));
}
function Square({ square, squareColor, setSquares, squareHasPremove, children }) {
  const squareRef = (0, import_react6.useRef)(null);
  const { autoPromoteToQueen, boardWidth, boardOrientation, clearArrows, currentPosition, currentRightClickDown, customBoardStyle, customDarkSquareStyle, customDropSquareStyle, customLightSquareStyle, customPremoveDarkSquareStyle, customPremoveLightSquareStyle, customSquare: CustomSquare, customSquareStyles, drawNewArrow, handleSetPosition, isWaitingForAnimation, lastPieceColour, onArrowDrawEnd, onDragOverSquare, onMouseOutSquare, onMouseOverSquare, onPieceDrop, onPromotionCheck, onRightClickDown, onRightClickUp, onSquareClick, setPromoteFromSquare, setPromoteToSquare, setShowPromoteDialog } = useChessboard();
  const [{ isOver }, drop] = useDrop(() => ({
    accept: "piece",
    drop: handleDrop,
    collect: (monitor) => ({
      isOver: !!monitor.isOver()
    })
  }), [
    square,
    currentPosition,
    onPieceDrop,
    isWaitingForAnimation,
    lastPieceColour
  ]);
  function handleDrop(item) {
    if (onPromotionCheck(item.square, square, item.piece)) {
      if (autoPromoteToQueen) {
        handleSetPosition(item.square, square, item.piece[0] === "w" ? "wQ" : "bQ");
      } else {
        setPromoteFromSquare(item.square);
        setPromoteToSquare(square);
        setShowPromoteDialog(true);
      }
    } else {
      handleSetPosition(item.square, square, item.piece, true);
    }
  }
  (0, import_react6.useEffect)(() => {
    if (squareRef.current) {
      const { x: x2, y: y2 } = squareRef.current.getBoundingClientRect();
      setSquares((oldSquares) => Object.assign(Object.assign({}, oldSquares), { [square]: { x: x2, y: y2 } }));
    }
  }, [boardWidth, boardOrientation]);
  const defaultSquareStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, borderRadius(square, boardOrientation, customBoardStyle)), squareColor === "black" ? customDarkSquareStyle : customLightSquareStyle), squareHasPremove && (squareColor === "black" ? customPremoveDarkSquareStyle : customPremoveLightSquareStyle)), isOver && customDropSquareStyle);
  return (0, import_jsx_runtime3.jsx)("div", Object.assign({ ref: drop, style: defaultSquareStyle, "data-square-color": squareColor, "data-square": square, onMouseOver: (e2) => {
    if (e2.buttons === 2 && currentRightClickDown) {
      drawNewArrow(currentRightClickDown, square);
    }
    if (e2.relatedTarget && e2.currentTarget.contains(e2.relatedTarget)) {
      return;
    }
    onMouseOverSquare(square);
  }, onMouseOut: (e2) => {
    if (e2.relatedTarget && e2.currentTarget.contains(e2.relatedTarget))
      return;
    onMouseOutSquare(square);
  }, onMouseDown: (e2) => {
    if (e2.button === 2)
      onRightClickDown(square);
  }, onMouseUp: (e2) => {
    if (e2.button === 2) {
      if (currentRightClickDown)
        onArrowDrawEnd(currentRightClickDown, square);
      onRightClickUp(square);
    }
  }, onDragEnter: () => onDragOverSquare(square), onClick: () => {
    const piece = currentPosition[square];
    onSquareClick(square, piece);
    clearArrows();
  }, onContextMenu: (e2) => {
    e2.preventDefault();
  } }, { children: typeof CustomSquare === "string" ? (0, import_jsx_runtime3.jsx)(
    CustomSquare,
    Object.assign({
      // Type is too complex to properly evaluate, so ignore this line.
      // @ts-ignore
      ref: squareRef,
      style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), !squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square]))
    }, { children })
  ) : (0, import_jsx_runtime3.jsx)(CustomSquare, Object.assign({ ref: squareRef, square, squareColor, style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), !squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square])) }, { children })) }));
}
var center = {
  display: "flex",
  justifyContent: "center"
};
var size = (width) => ({
  width: width / 8,
  height: width / 8
});
var borderRadius = (square, boardOrientation, customBoardStyle) => {
  if (!(customBoardStyle === null || customBoardStyle === void 0 ? void 0 : customBoardStyle.borderRadius))
    return {};
  if (square === "a1") {
    return boardOrientation === "white" ? { borderBottomLeftRadius: customBoardStyle.borderRadius } : { borderTopRightRadius: customBoardStyle.borderRadius };
  }
  if (square === "a8") {
    return boardOrientation === "white" ? { borderTopLeftRadius: customBoardStyle.borderRadius } : { borderBottomRightRadius: customBoardStyle.borderRadius };
  }
  if (square === "h1") {
    return boardOrientation === "white" ? { borderBottomRightRadius: customBoardStyle.borderRadius } : { borderTopLeftRadius: customBoardStyle.borderRadius };
  }
  if (square === "h8") {
    return boardOrientation === "white" ? { borderTopRightRadius: customBoardStyle.borderRadius } : { borderBottomLeftRadius: customBoardStyle.borderRadius };
  }
  return {};
};
function Squares() {
  const [squares, setSquares] = (0, import_react6.useState)({});
  const { arePremovesAllowed, boardOrientation, boardWidth, currentPosition, id, premoves, showBoardNotation } = useChessboard();
  const premovesHistory = (0, import_react6.useMemo)(() => {
    const result = [];
    if (!arePremovesAllowed)
      return [];
    premoves.forEach((premove, index) => {
      const { sourceSq, targetSq, piece } = premove;
      const relatedPremovedPiece = result.find((p2) => {
        var _a;
        return p2.piece === piece && ((_a = p2.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === sourceSq;
      });
      if (relatedPremovedPiece) {
        relatedPremovedPiece.premovesRoute.push({ sourceSq, targetSq, index });
      } else {
        result.push({
          piece,
          // index is useful for scenarios where two or more pieces are targeting the same square
          premovesRoute: [{ sourceSq, targetSq, index }]
        });
      }
    });
    return result;
  }, [premoves]);
  return (0, import_jsx_runtime3.jsx)("div", Object.assign({ "data-boardid": id }, { children: [...Array(8)].map((_2, r2) => {
    return (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: {
      display: "flex",
      flexWrap: "nowrap",
      width: boardWidth
    } }, { children: [...Array(8)].map((_3, c2) => {
      const square = boardOrientation === "black" ? COLUMNS[7 - c2] + (r2 + 1) : COLUMNS[c2] + (8 - r2);
      const squareColor = c2 % 2 === r2 % 2 ? "white" : "black";
      const squareHasPremove = premoves.find((p2) => p2.sourceSq === square || p2.targetSq === square);
      const squareHasPremoveTarget = premovesHistory.filter(({ premovesRoute }) => {
        var _a;
        return ((_a = premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === square;
      }).sort((a2, b2) => {
        var _a, _b;
        return ((_a = b2.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.index) - ((_b = a2.premovesRoute.at(-1)) === null || _b === void 0 ? void 0 : _b.index);
      }).at(0);
      return (0, import_jsx_runtime3.jsxs)(Square, Object.assign({ square, squareColor, setSquares, squareHasPremove: !!squareHasPremove }, { children: [!squareHasPremove && currentPosition[square] && (0, import_jsx_runtime3.jsx)(Piece, { piece: currentPosition[square], square, squares }), squareHasPremoveTarget && (0, import_jsx_runtime3.jsx)(Piece, { isPremovedPiece: true, piece: squareHasPremoveTarget.piece, square, squares }), showBoardNotation && (0, import_jsx_runtime3.jsx)(Notation, { row: r2, col: c2 })] }), `${c2}${r2}`);
    }) }), r2.toString());
  }) }));
}
var Arrows = () => {
  const { arrows, newArrow, boardOrientation, boardWidth, customArrowColor: primaryArrowCollor } = useChessboard();
  const arrowsList = [...arrows, newArrow].filter(Boolean);
  return (0, import_jsx_runtime3.jsx)("svg", Object.assign({ width: boardWidth, height: boardWidth, style: {
    position: "absolute",
    top: "0",
    left: "0",
    pointerEvents: "none",
    zIndex: "10"
  } }, { children: arrowsList.map((arrow, i2) => {
    const [arrowStartField, arrowEndField, arrowColor] = arrow;
    if (arrowStartField === arrowEndField)
      return null;
    const from6 = getRelativeCoords(boardOrientation, boardWidth, arrowStartField);
    const to2 = getRelativeCoords(boardOrientation, boardWidth, arrowEndField);
    let ARROW_LENGTH_REDUCER = boardWidth / 32;
    const isArrowActive = i2 === arrows.length;
    if (arrows.some((restArrow) => restArrow[0] !== arrowStartField && restArrow[1] === arrowEndField) && !isArrowActive) {
      ARROW_LENGTH_REDUCER = boardWidth / 16;
    }
    const dx = to2.x - from6.x;
    const dy = to2.y - from6.y;
    const r2 = Math.hypot(dy, dx);
    const end = {
      x: from6.x + dx * (r2 - ARROW_LENGTH_REDUCER) / r2,
      y: from6.y + dy * (r2 - ARROW_LENGTH_REDUCER) / r2
    };
    return (0, import_jsx_runtime3.jsxs)(import_react6.Fragment, { children: [(0, import_jsx_runtime3.jsx)("marker", Object.assign({ id: `arrowhead-${i2}`, markerWidth: "2", markerHeight: "2.5", refX: "1.25", refY: "1.25", orient: "auto" }, { children: (0, import_jsx_runtime3.jsx)("polygon", { points: "0.3 0, 2 1.25, 0.3 2.5", fill: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor }) })), (0, import_jsx_runtime3.jsx)("line", { x1: from6.x, y1: from6.y, x2: end.x, y2: end.y, opacity: isArrowActive ? "0.5" : "0.65", stroke: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor, strokeWidth: isArrowActive ? 0.9 * boardWidth / 40 : boardWidth / 40, markerEnd: `url(#arrowhead-${i2})` })] }, `${arrowStartField}-${arrowEndField}${isArrowActive ? "-active" : ""}`);
  }) }));
};
function PromotionOption({ option }) {
  const [isHover, setIsHover] = (0, import_react6.useState)(false);
  const { boardWidth, chessPieces, customDarkSquareStyle, customLightSquareStyle, handleSetPosition, onPromotionPieceSelect, promoteFromSquare, promoteToSquare, promotionDialogVariant } = useChessboard();
  const backgroundColor = () => {
    switch (option[1]) {
      case "Q":
        return customDarkSquareStyle.backgroundColor;
      case "R":
        return customLightSquareStyle.backgroundColor;
      case "N":
        return promotionDialogVariant === "default" ? customLightSquareStyle.backgroundColor : customDarkSquareStyle.backgroundColor;
      case "B":
        return promotionDialogVariant === "default" ? customDarkSquareStyle.backgroundColor : customLightSquareStyle.backgroundColor;
    }
  };
  return (0, import_jsx_runtime3.jsx)("div", Object.assign({ onClick: () => {
    (onPromotionPieceSelect === null || onPromotionPieceSelect === void 0 ? void 0 : onPromotionPieceSelect.length) ? onPromotionPieceSelect(option) : handleSetPosition(promoteFromSquare, promoteToSquare, option, true);
  }, onMouseOver: () => setIsHover(true), onMouseOut: () => setIsHover(false), "data-piece": option, style: {
    cursor: "pointer",
    backgroundColor: isHover ? backgroundColor() : `${backgroundColor()}aa`,
    borderRadius: "4px",
    transition: "all 0.1s ease-out"
  } }, { children: typeof chessPieces[option] === "function" ? (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: {
    transition: "all 0.1s ease-out",
    transform: isHover ? "scale(1)" : "scale(0.85)"
  } }, { children: chessPieces[option]({
    squareWidth: boardWidth / 8,
    isDragging: false
  }) })) : (0, import_jsx_runtime3.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: boardWidth / 8, height: boardWidth / 8, style: {
    transition: "all 0.1s ease-out",
    transform: isHover ? "scale(1)" : "scale(0.85)"
  } }, { children: (0, import_jsx_runtime3.jsx)("g", { children: chessPieces[option] }) })) }));
}
function PromotionDialog() {
  const { boardOrientation, boardWidth, promotionDialogVariant, promoteToSquare } = useChessboard();
  const promotePieceColor = (promoteToSquare === null || promoteToSquare === void 0 ? void 0 : promoteToSquare[1]) === "1" ? "b" : "w";
  const promotionOptions = [
    `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : "w"}Q`,
    `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : "w"}R`,
    `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : "w"}N`,
    `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : "w"}B`
  ];
  const dialogStyles = {
    default: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      transform: `translate(${-boardWidth / 8}px, ${-boardWidth / 8}px)`
    },
    vertical: {
      transform: `translate(${-boardWidth / 16}px, ${-boardWidth / 16}px)`
    },
    modal: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      transform: `translate(0px, ${3 * boardWidth / 8}px)`,
      width: "100%",
      height: `${boardWidth / 4}px`,
      top: 0,
      backgroundColor: "white",
      left: 0
    }
  };
  const dialogCoords = getRelativeCoords(boardOrientation, boardWidth, promoteToSquare || "a8");
  return (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: Object.assign({ position: "absolute", top: `${dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.y}px`, left: `${dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.x}px`, zIndex: 1e3 }, dialogStyles[promotionDialogVariant]), title: "Choose promotion piece" }, { children: promotionOptions.map((option) => (0, import_jsx_runtime3.jsx)(PromotionOption, { option }, option)) }));
}
var errorImage = {
  whiteKing: (0, import_jsx_runtime3.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", style: {
    shapeRendering: "geometricPrecision",
    textRendering: "geometricPrecision",
    imageRendering: "crisp-edges"
  }, viewBox: "0 0 4210 12970", x: "0px", y: "0px", fillRule: "evenodd", clipRule: "evenodd", width: "250", height: "250" }, { children: (0, import_jsx_runtime3.jsx)("g", { children: (0, import_jsx_runtime3.jsx)("path", { style: {
    fill: "black",
    fillRule: "nonzero"
  }, d: "M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z" }) }) }))
};
function ErrorBoundary({ children }) {
  try {
    return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children });
  } catch (error) {
    console.log(error);
    return (0, import_jsx_runtime3.jsx)(WhiteKing, { showError: true });
  }
}
function WhiteKing({ showError = false }) {
  return (0, import_jsx_runtime3.jsxs)("div", Object.assign({ style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "column"
  } }, { children: [(0, import_jsx_runtime3.jsx)("div", Object.assign({ style: {
    width: 250,
    height: 250,
    transform: "rotate(90deg)"
  } }, { children: errorImage.whiteKing })), showError && (0, import_jsx_runtime3.jsx)("h1", { children: "Something went wrong" })] }));
}
function Board() {
  const boardRef = (0, import_react6.useRef)(null);
  const { boardWidth, clearCurrentRightClickDown, onPromotionPieceSelect, setShowPromoteDialog, showPromoteDialog, customBoardStyle } = useChessboard();
  (0, import_react6.useEffect)(() => {
    function handleClickOutside(event) {
      if (boardRef.current && !boardRef.current.contains(event.target)) {
        clearCurrentRightClickDown();
      }
    }
    document.addEventListener("mouseup", handleClickOutside);
    return () => {
      document.removeEventListener("mouseup", handleClickOutside);
    };
  }, []);
  return boardWidth ? (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: { perspective: "1000px" } }, { children: (0, import_jsx_runtime3.jsxs)("div", Object.assign({ ref: boardRef, style: Object.assign(Object.assign({ position: "relative" }, boardStyles(boardWidth)), customBoardStyle) }, { children: [(0, import_jsx_runtime3.jsx)(Squares, {}), (0, import_jsx_runtime3.jsx)(Arrows, {}), showPromoteDialog && (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("div", { onClick: () => {
    setShowPromoteDialog(false);
    onPromotionPieceSelect === null || onPromotionPieceSelect === void 0 ? void 0 : onPromotionPieceSelect();
  }, style: {
    position: "absolute",
    top: "0",
    left: "0",
    zIndex: "100",
    backgroundColor: "rgba(22,21,18,.7)",
    width: boardWidth,
    height: boardWidth
  } }), (0, import_jsx_runtime3.jsx)(PromotionDialog, {})] })] })) })) : (0, import_jsx_runtime3.jsx)(WhiteKing, {});
}
var boardStyles = (width) => ({
  cursor: "default",
  height: width,
  width
});
function CustomDragLayer({ boardContainer }) {
  const { boardWidth, chessPieces, id, snapToCursor, allowDragOutsideBoard } = useChessboard();
  const collectedProps = useDragLayer((monitor) => ({
    item: monitor.getItem(),
    clientOffset: monitor.getClientOffset(),
    sourceClientOffset: monitor.getSourceClientOffset(),
    isDragging: monitor.isDragging()
  }));
  const { isDragging, item, clientOffset, sourceClientOffset } = collectedProps;
  const getItemStyle = (0, import_react6.useCallback)((clientOffset2, sourceClientOffset2) => {
    if (!clientOffset2 || !sourceClientOffset2)
      return { display: "none" };
    let { x: x2, y: y2 } = snapToCursor ? clientOffset2 : sourceClientOffset2;
    const halfSquareWidth = boardWidth / 8 / 2;
    if (snapToCursor) {
      x2 -= halfSquareWidth;
      y2 -= halfSquareWidth;
    }
    if (!allowDragOutsideBoard) {
      const { left, top } = boardContainer;
      const maxLeft = left - halfSquareWidth;
      const maxTop = top - halfSquareWidth;
      const maxRight = left + boardWidth - halfSquareWidth;
      const maxBottom = top + boardWidth - halfSquareWidth;
      x2 = Math.max(maxLeft, Math.min(x2, maxRight));
      y2 = Math.max(maxTop, Math.min(y2, maxBottom));
    }
    const transform = `translate(${x2}px, ${y2}px)`;
    return {
      transform,
      WebkitTransform: transform,
      touchAction: "none"
    };
  }, [boardWidth, allowDragOutsideBoard, snapToCursor, boardContainer]);
  return isDragging && item.id === id ? (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: {
    position: "fixed",
    pointerEvents: "none",
    zIndex: 10,
    left: 0,
    top: 0
  } }, { children: (0, import_jsx_runtime3.jsx)("div", Object.assign({ style: getItemStyle(clientOffset, sourceClientOffset) }, { children: typeof chessPieces[item.piece] === "function" ? chessPieces[item.piece]({
    squareWidth: boardWidth / 8,
    isDragging: true
  }) : (0, import_jsx_runtime3.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: boardWidth / 8, height: boardWidth / 8 }, { children: (0, import_jsx_runtime3.jsx)("g", { children: chessPieces[item.piece] }) })) })) })) : null;
}
var Chessboard = (0, import_react6.forwardRef)((props, ref) => {
  const { customDndBackend, customDndBackendOptions } = props, otherProps = __rest(props, ["customDndBackend", "customDndBackendOptions"]);
  const [clientWindow, setClientWindow] = (0, import_react6.useState)();
  const [backendSet, setBackendSet] = (0, import_react6.useState)(false);
  const [isMobile, setIsMobile] = (0, import_react6.useState)(false);
  const [boardWidth, setBoardWidth] = (0, import_react6.useState)(props.boardWidth);
  const boardRef = (0, import_react6.useRef)(null);
  const boardContainerRef = (0, import_react6.useRef)(null);
  const [boardContainerPos, setBoardContainerPos] = (0, import_react6.useState)({
    left: 0,
    top: 0
  });
  const metrics = (0, import_react6.useMemo)(() => {
    var _a;
    return (_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  }, [boardRef.current]);
  (0, import_react6.useEffect)(() => {
    setBoardContainerPos({
      left: (metrics === null || metrics === void 0 ? void 0 : metrics.left) ? metrics === null || metrics === void 0 ? void 0 : metrics.left : 0,
      top: (metrics === null || metrics === void 0 ? void 0 : metrics.top) ? metrics === null || metrics === void 0 ? void 0 : metrics.top : 0
    });
  }, [metrics]);
  (0, import_react6.useEffect)(() => {
    setIsMobile("ontouchstart" in window);
    setBackendSet(true);
    setClientWindow(window);
  }, []);
  (0, import_react6.useEffect)(() => {
    var _a;
    if (props.boardWidth === void 0 && ((_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth)) {
      const resizeObserver = new ResizeObserver(() => {
        var _a2;
        setBoardWidth((_a2 = boardRef.current) === null || _a2 === void 0 ? void 0 : _a2.offsetWidth);
      });
      resizeObserver.observe(boardRef.current);
      return () => {
        resizeObserver.disconnect();
      };
    }
  }, [boardRef.current, clientWindow]);
  const backend = customDndBackend || (isMobile ? TouchBackend : HTML5Backend);
  return backendSet && clientWindow ? (0, import_jsx_runtime3.jsx)(ErrorBoundary, { children: (0, import_jsx_runtime3.jsxs)("div", Object.assign({ ref: boardContainerRef, style: {
    display: "flex",
    flexDirection: "column",
    width: "100%"
  } }, { children: [(0, import_jsx_runtime3.jsx)("div", { ref: boardRef, style: { width: "100%" } }), (0, import_jsx_runtime3.jsx)(DndProvider, Object.assign({ backend, context: clientWindow, options: customDndBackend ? customDndBackendOptions : void 0 }, { children: boardWidth && (0, import_jsx_runtime3.jsxs)(ChessboardProvider, Object.assign({ boardWidth }, otherProps, { ref }, { children: [(0, import_jsx_runtime3.jsx)(CustomDragLayer, { boardContainer: boardContainerPos }), (0, import_jsx_runtime3.jsx)(Board, {})] })) }))] })) }) : null;
});

// src/components/ChessGame.tsx
var import_uuid2 = __toESM(require_uuid(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var ChessGame = ({ credential, context }) => {
  console.log("ChessGame.");
  const { agent } = (0, import_veramo_react3.useVeramo)();
  const { token } = import_antd3.theme.useToken();
  const [validVotes, setValidVotes] = React9.useState([]);
  const { title, pollOptions } = credential.verifiableCredential.credentialSubject;
  const credHash = credential.hash;
  const [game, setGame] = React9.useState(new import_chess.Chess());
  const { data: moves, refetch } = (0, import_react_query2.useQuery)(
    [
      "chessMoves",
      { credHash, agentId: agent?.context.name }
    ],
    () => agent?.dataStoreORMGetVerifiableCredentialsByClaims({
      where: [
        {
          column: "type",
          value: ["inviteHash"]
        },
        {
          column: "value",
          value: [credHash]
        },
        {
          column: "credentialType",
          value: ["VerifiableCredential,ChessGameMove"]
        }
      ],
      order: [{ column: "issuanceDate", direction: "ASC" }]
    })
  );
  React9.useEffect(() => {
    if (moves) {
      console.log("found moves: ", moves);
      setGame(new import_chess.Chess());
      moves.forEach((move) => {
        console.log("make move: ", move.verifiableCredential.credentialSubject.move);
        const moveData = move.verifiableCredential.credentialSubject.move;
        makeAMove(moveData);
      });
    }
  }, [moves]);
  function makeAMove(move) {
    const gameCopy = { ...game };
    const result = gameCopy.move(move);
    setGame(gameCopy);
    return result;
  }
  function onDrop(sourceSquare, targetSquare, piece) {
    const preGameCopy = { ...game };
    let issuer = "";
    let opponent = "";
    if (game.turn() === "b") {
      issuer = credential.verifiableCredential.credentialSubject.black;
      opponent = credential.verifiableCredential.credentialSubject.white;
    } else {
      issuer = credential.verifiableCredential.credentialSubject.white;
      opponent = credential.verifiableCredential.credentialSubject.black;
    }
    const move = makeAMove({
      from: sourceSquare,
      to: targetSquare,
      promotion: "q"
      // always promote to a queen for example simplicity
    });
    if (move === null)
      return false;
    async function issueAndSendMoveCredential() {
      console.log("preGameCopy: ", preGameCopy);
      const identifier = await agent?.didManagerGet({ did: issuer });
      const usableProofs = await agent?.listUsableProofFormats(identifier);
      const proofFormat = usableProofs?.includes("jwt") ? "jwt" : usableProofs[0];
      const moveCredential = await agent?.createVerifiableCredential({
        proofFormat,
        credential: {
          issuer,
          type: ["VerifiableCredential", "ChessGameMove"],
          credentialSubject: {
            inviteHash: credHash,
            move
          }
        }
      });
      if (moveCredential) {
        const res = await agent?.dataStoreSaveVerifiableCredential({ verifiableCredential: moveCredential });
        console.log("res: ", res);
        const shareMessage = {
          type: "https://didcomm.org/chess/1.0/move",
          from: issuer,
          created_time: (/* @__PURE__ */ new Date()).getTime(),
          to: opponent,
          id: (0, import_uuid2.v4)(),
          thid: credHash,
          attachments: [{
            media_type: "credential+ld+json",
            data: { json: moveCredential }
          }]
        };
        const packedMessage = await agent?.packDIDCommMessage({
          message: shareMessage,
          packing: "authcrypt"
        });
        const sendRes = await agent?.sendDIDCommMessage({
          packedMessage,
          messageId: shareMessage.id,
          recipientDidUrl: opponent
        });
        await agent?.dataStoreSaveMessage({ message: {
          type: shareMessage.type,
          from: issuer,
          to: opponent,
          id: shareMessage.id,
          threadId: shareMessage.thid,
          data: {},
          attachments: shareMessage.attachments
        } });
        import_antd3.notification.success({
          message: "Message sent"
        });
      }
    }
    issueAndSendMoveCredential();
    return true;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { style: { marginTop: token.margin }, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Chessboard, { position: game.fen(), onPieceDrop: onDrop }) });
};

// src/components/ChessGamePage.tsx
var import_react7 = __toESM(require_react(), 1);
var import_react_router_dom3 = __toESM(require_react_router_dom(), 1);
var import_veramo_react5 = __toESM(require_veramo_react(), 1);
var import_pro_components2 = __toESM(require_pro_components(), 1);
var import_antd5 = __toESM(require_antd(), 1);
var import_agent_explorer_plugin5 = __toESM(require_agent_explorer_plugin(), 1);
var import_react8 = __toESM(require_react(), 1);

// src/components/Votes.tsx
var import_react_query3 = __toESM(require_react_query(), 1);
var import_veramo_react4 = __toESM(require_veramo_react(), 1);
var import_antd4 = __toESM(require_antd(), 1);
var import_agent_explorer_plugin4 = __toESM(require_agent_explorer_plugin(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var Votes = ({ hash: hash2 }) => {
  const { agent } = (0, import_veramo_react4.useVeramo)();
  const { data: credentials, isLoading, refetch } = (0, import_react_query3.useQuery)(
    [
      "credentialReactionCredentials",
      { hash: hash2, agentId: agent?.context.name }
    ],
    () => agent?.dataStoreORMGetVerifiableCredentialsByClaims({
      where: [
        {
          column: "type",
          value: ["pollHash"]
        },
        {
          column: "value",
          value: [hash2]
        },
        {
          column: "credentialType",
          value: ["VerifiableCredential,WitnessPollResponse"]
        }
      ]
    })
  );
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    import_antd4.List,
    {
      itemLayout: "vertical",
      size: "large",
      dataSource: credentials,
      renderItem: (item) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: { marginTop: "20px" }, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_agent_explorer_plugin4.VerifiableCredentialComponent, { credential: item }) })
    }
  );
};

// src/components/ChessGamePage.tsx
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var ChessGamePage = () => {
  const { hash: hash2 } = (0, import_react_router_dom3.useParams)();
  const { agents, agent } = (0, import_veramo_react5.useVeramo)();
  const [refDrawerOpen, setRefDrawerOpen] = (0, import_react7.useState)(false);
  const [game, setGame] = (0, import_react7.useState)(null);
  const { token } = import_antd5.theme.useToken();
  const [sidebar, setSidebar] = (0, import_react7.useState)(null);
  const [loading, setLoading] = (0, import_react7.useState)(true);
  const localAgent = import_react7.default.useMemo(() => {
    return agents.find((agent2) => agent2.context.id === "web3Agent");
  }, [agents]);
  if (!agent)
    return null;
  if (!localAgent)
    return null;
  if (!hash2)
    return null;
  (0, import_react8.useEffect)(() => {
    setLoading(true);
    const load = async () => {
      try {
        const gameCredential = await agent.dataStoreGetVerifiableCredential({ hash: hash2 });
        setGame({ hash: hash2, verifiableCredential: gameCredential });
      } catch (e2) {
        console.log("unknown game.");
      }
      setLoading(false);
    };
    load();
  }, [hash2, agent]);
  if (loading)
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_antd5.Spin, {});
  if (!game)
    return null;
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
    import_pro_components2.PageContainer,
    {
      loading,
      style: { paddingTop: 10 },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ResponsiveContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_antd5.Row, { gutter: 16, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_antd5.Col, { xs: 24, sm: 16, style: {
          overflow: "hidden",
          marginBottom: token.margin
        }, children: game && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_agent_explorer_plugin5.VerifiableCredentialComponent, { credential: game }) }) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          import_antd5.Drawer,
          {
            title: "Moves",
            placement: "right",
            onClose: () => setRefDrawerOpen(false),
            open: refDrawerOpen,
            width: 800,
            destroyOnClose: true,
            children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Votes, { hash: hash2 })
          }
        )
      ]
    }
  );
};
var ResponsiveContainer = ({
  children
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_antd5.Row, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      import_antd5.Col,
      {
        lg: 3
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      import_antd5.Col,
      {
        lg: 18,
        sm: 24,
        xs: 24,
        style: { position: "relative" },
        children
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      import_antd5.Col,
      {
        lg: 3
      }
    )
  ] });
};

// node_modules/.pnpm/@veramo+core-types@6.0.0/node_modules/@veramo/core-types/build/coreEvents.js
var CoreEvents = {
  /**
   * This event type is used to signal an error to event listeners.
   *
   * @public
   */
  error: "ev_err",
  /**
   * This event type is used to signal a warning to event listeners.
   *
   * @public
   */
  warning: "ev_warn"
};

// node_modules/.pnpm/@veramo+message-handler@6.0.0/node_modules/@veramo/message-handler/build/message-handler.js
var import_debug2 = __toESM(require_browser(), 1);
var debug2 = (0, import_debug2.default)("veramo:message-handler");
var EventTypes = {
  validatedMessage: "validatedMessage",
  savedMessage: "savedMessage",
  error: CoreEvents.error
};

// node_modules/.pnpm/@veramo+message-handler@6.0.0/node_modules/@veramo/message-handler/build/abstract-message-handler.js
var import_debug3 = __toESM(require_browser(), 1);
var debug3 = (0, import_debug3.default)("veramo:message-handler");
var unsupportedMessageTypeError = new Error("Unsupported message type");
var AbstractMessageHandler = class {
  nextMessageHandler;
  setNext(messageHandler) {
    this.nextMessageHandler = messageHandler;
    return messageHandler;
  }
  async handle(message2, context) {
    if (this.nextMessageHandler)
      return this.nextMessageHandler.handle(message2, context);
    debug3("can't handle message: ", message2);
    return Promise.reject(unsupportedMessageTypeError);
  }
};

// src/saveMessageHandler.ts
var SaveMessageHandler = class extends AbstractMessageHandler {
  /**
   * Handles a new packed DIDCommV2 Message (also Alpha support but soon deprecated).
   * - Tests whether raw message is a DIDCommV2 message
   * - Unpacks raw message (JWM/JWE/JWS, or plain JSON).
   * -
   */
  async handle(message2, context) {
    if (message2.type === CHESS_INVITE_MESSAGE_TYPE || message2.type === CHESS_MOVE_MESSAGE_TYPE) {
      console.log("found chess message");
      let localMessage;
      try {
        localMessage = await context.agent.dataStoreGetMessage({ id: message2.id });
      } catch (ex) {
        console.log("incoming message not already saved.");
      }
      if (!localMessage) {
        console.log("Saving message", message2);
        await context.agent.dataStoreSaveMessage({ message: message2 });
        if (message2.attachments && message2.attachments.length > 0) {
          console.log("attachments found");
          for (const attachment of message2.attachments) {
            if (attachment.media_type === "credential+ld+json") {
              const credential = await context.agent.dataStoreSaveVerifiableCredential({ verifiableCredential: attachment.data.json });
              console.log("saved attached credential: ", credential);
            }
          }
        }
      }
    }
    return super.handle(message2, context);
  }
};

// src/index.tsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var Plugin = {
  init: () => {
    return {
      name: "Chess",
      config: {
        enabled: true,
        url: "core://chess"
      },
      description: "Chess game plugin",
      requiredMethods: [],
      icon: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SketchOutlined_default2, {}),
      messageHandlers: [new SaveMessageHandler()],
      routes: [
        {
          path: "/chess/games",
          element: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Games, {})
        },
        {
          path: "/chess/games/:hash",
          element: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ChessGamePage, {})
        }
      ],
      menuItems: [
        {
          name: "Chess",
          path: "/chess/games",
          icon: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SketchOutlined_default2, {})
        }
      ],
      hasCss: true,
      getCredentialComponent: (credential) => {
        if (credential.verifiableCredential.type?.includes("ChessGameInvite")) {
          return ChessGame;
        }
        return void 0;
      }
    };
  }
};
var src_default = Plugin;
export {
  src_default as default
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
